<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>处理SIGCHLD信号 | Jagger's Blog</title>
<meta name=keywords content="UNP,tcpcliserv"><meta name=description content='处理SIGCHLD信号 1 2 3 4 5 6 7 8 9 10 11 12 void sig_chld(int signo) { pid_t pid; int stat; // wait()是为了清理僵死进程 // pid = wait(&amp;stat); // printf("child %d terminated\n", pid); while ((pid = waitpid(-1, &amp;stat, WNOHANG)) > 0) printf("child %d terminated\n", pid); return; } wait版本行不通的原因 若服务器和客户端在同一主机上，则该信号处理函数只执行过一次（根据UNP的描述是这样的，但是本人实测，信号处理器函数执行了两次）。 但是如果我们在不同的主机上运行客户和服务器，那么信号处理器函数一般执行两次：一次是由第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因为该处理函数仅仅再被调用一次，从而留下3个僵死进程。 不过有的时候，根据FIN到达主机的时机，信号处理函数可能会执行3次甚至4次
根据本人猜想，如果在相同主机测试，由于没有网络数据传播时延的影响，本机的客户端所有五个FIN都几乎在同一时间传递给服务器， 从而使得服务器的5个子进程基本在同一时刻终止，从而5个SIGCHLD在同一时刻发送给父进程，都在第一个信号处理函数执行之前发生， 而Unix信号一般是不排队的（这里详见TLPI对应的小节），因此信号处理函数只执行一次。
但是如果在不同主机测试，由于网络数据传播，各个FIN到达服务器的时间差较大一些，导致FIN以不可忽略的时差到达服务器。 例如在处理第一个SIGCHLD信号时，其他FIN才到达，从而引起信号处理函数执行多次。
1 2 3 4 5 6 7 ➜ bin git:(main) ✗ ./TCPSERV03 & [1] 65001 ➜ bin git:(main) ✗ .'><meta name=author content="Jagger"><link rel=canonical href=https://fireflyyh.top/posts/unp/sigchldwaitpid/><link crossorigin=anonymous href=/assets/css/stylesheet.85106b68d21097b36df07bae454e1c50c6b1bdee98f9081be69e9968653bd3a0.css integrity="sha256-hRBraNIQl7Nt8HuuRU4cUMaxve6Y+Qgb5p6ZaGU706A=" rel="preload stylesheet" as=style><link rel=icon href=https://fireflyyh.top/img/yuan.jpg><link rel=icon type=image/png sizes=16x16 href=https://fireflyyh.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://fireflyyh.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://fireflyyh.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://fireflyyh.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://fireflyyh.top/posts/unp/sigchldwaitpid/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?87f1888ba5320e03987ecde7525fde2d",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y30PKHXBN4"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y30PKHXBN4")</script><meta property="og:title" content="处理SIGCHLD信号"><meta property="og:description" content='处理SIGCHLD信号 1 2 3 4 5 6 7 8 9 10 11 12 void sig_chld(int signo) { pid_t pid; int stat; // wait()是为了清理僵死进程 // pid = wait(&amp;stat); // printf("child %d terminated\n", pid); while ((pid = waitpid(-1, &amp;stat, WNOHANG)) > 0) printf("child %d terminated\n", pid); return; } wait版本行不通的原因 若服务器和客户端在同一主机上，则该信号处理函数只执行过一次（根据UNP的描述是这样的，但是本人实测，信号处理器函数执行了两次）。 但是如果我们在不同的主机上运行客户和服务器，那么信号处理器函数一般执行两次：一次是由第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因为该处理函数仅仅再被调用一次，从而留下3个僵死进程。 不过有的时候，根据FIN到达主机的时机，信号处理函数可能会执行3次甚至4次
根据本人猜想，如果在相同主机测试，由于没有网络数据传播时延的影响，本机的客户端所有五个FIN都几乎在同一时间传递给服务器， 从而使得服务器的5个子进程基本在同一时刻终止，从而5个SIGCHLD在同一时刻发送给父进程，都在第一个信号处理函数执行之前发生， 而Unix信号一般是不排队的（这里详见TLPI对应的小节），因此信号处理函数只执行一次。
但是如果在不同主机测试，由于网络数据传播，各个FIN到达服务器的时间差较大一些，导致FIN以不可忽略的时差到达服务器。 例如在处理第一个SIGCHLD信号时，其他FIN才到达，从而引起信号处理函数执行多次。
1 2 3 4 5 6 7 ➜ bin git:(main) ✗ ./TCPSERV03 & [1] 65001 ➜ bin git:(main) ✗ .'><meta property="og:type" content="article"><meta property="og:url" content="https://fireflyyh.top/posts/unp/sigchldwaitpid/"><meta property="og:image" content="https://fireflyyh.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-31T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-31T00:00:00+00:00"><meta property="og:site_name" content="Jagger's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fireflyyh.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="处理SIGCHLD信号"><meta name=twitter:description content='处理SIGCHLD信号 1 2 3 4 5 6 7 8 9 10 11 12 void sig_chld(int signo) { pid_t pid; int stat; // wait()是为了清理僵死进程 // pid = wait(&amp;stat); // printf("child %d terminated\n", pid); while ((pid = waitpid(-1, &amp;stat, WNOHANG)) > 0) printf("child %d terminated\n", pid); return; } wait版本行不通的原因 若服务器和客户端在同一主机上，则该信号处理函数只执行过一次（根据UNP的描述是这样的，但是本人实测，信号处理器函数执行了两次）。 但是如果我们在不同的主机上运行客户和服务器，那么信号处理器函数一般执行两次：一次是由第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因为该处理函数仅仅再被调用一次，从而留下3个僵死进程。 不过有的时候，根据FIN到达主机的时机，信号处理函数可能会执行3次甚至4次
根据本人猜想，如果在相同主机测试，由于没有网络数据传播时延的影响，本机的客户端所有五个FIN都几乎在同一时间传递给服务器， 从而使得服务器的5个子进程基本在同一时刻终止，从而5个SIGCHLD在同一时刻发送给父进程，都在第一个信号处理函数执行之前发生， 而Unix信号一般是不排队的（这里详见TLPI对应的小节），因此信号处理函数只执行一次。
但是如果在不同主机测试，由于网络数据传播，各个FIN到达服务器的时间差较大一些，导致FIN以不可忽略的时差到达服务器。 例如在处理第一个SIGCHLD信号时，其他FIN才到达，从而引起信号处理函数执行多次。
1 2 3 4 5 6 7 ➜ bin git:(main) ✗ ./TCPSERV03 & [1] 65001 ➜ bin git:(main) ✗ .'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fireflyyh.top/posts/"},{"@type":"ListItem","position":2,"name":"处理SIGCHLD信号","item":"https://fireflyyh.top/posts/unp/sigchldwaitpid/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"处理SIGCHLD信号","name":"处理SIGCHLD信号","description":"处理SIGCHLD信号 1 2 3 4 5 6 7 8 9 10 11 12 void sig_chld(int signo) { pid_t pid; int stat; // wait()是为了清理僵死进程 // pid = wait(\u0026amp;stat); // printf(\u0026#34;child %d terminated\\n\u0026#34;, pid); while ((pid = waitpid(-1, \u0026amp;stat, WNOHANG)) \u0026gt; 0) printf(\u0026#34;child %d terminated\\n\u0026#34;, pid); return; } wait版本行不通的原因 若服务器和客户端在同一主机上，则该信号处理函数只执行过一次（根据UNP的描述是这样的，但是本人实测，信号处理器函数执行了两次）。 但是如果我们在不同的主机上运行客户和服务器，那么信号处理器函数一般执行两次：一次是由第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因为该处理函数仅仅再被调用一次，从而留下3个僵死进程。 不过有的时候，根据FIN到达主机的时机，信号处理函数可能会执行3次甚至4次\n根据本人猜想，如果在相同主机测试，由于没有网络数据传播时延的影响，本机的客户端所有五个FIN都几乎在同一时间传递给服务器， 从而使得服务器的5个子进程基本在同一时刻终止，从而5个SIGCHLD在同一时刻发送给父进程，都在第一个信号处理函数执行之前发生， 而Unix信号一般是不排队的（这里详见TLPI对应的小节），因此信号处理函数只执行一次。\n但是如果在不同主机测试，由于网络数据传播，各个FIN到达服务器的时间差较大一些，导致FIN以不可忽略的时差到达服务器。 例如在处理第一个SIGCHLD信号时，其他FIN才到达，从而引起信号处理函数执行多次。\n1 2 3 4 5 6 7 ➜ bin git:(main) ✗ ./TCPSERV03 \u0026amp; [1] 65001 ➜ bin git:(main) ✗ .","keywords":["UNP","tcpcliserv"],"articleBody":"处理SIGCHLD信号 1 2 3 4 5 6 7 8 9 10 11 12 void sig_chld(int signo) { pid_t pid; int stat; // wait()是为了清理僵死进程 // pid = wait(\u0026stat); // printf(\"child %d terminated\\n\", pid); while ((pid = waitpid(-1, \u0026stat, WNOHANG)) \u003e 0) printf(\"child %d terminated\\n\", pid); return; } wait版本行不通的原因 若服务器和客户端在同一主机上，则该信号处理函数只执行过一次（根据UNP的描述是这样的，但是本人实测，信号处理器函数执行了两次）。 但是如果我们在不同的主机上运行客户和服务器，那么信号处理器函数一般执行两次：一次是由第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因为该处理函数仅仅再被调用一次，从而留下3个僵死进程。 不过有的时候，根据FIN到达主机的时机，信号处理函数可能会执行3次甚至4次\n根据本人猜想，如果在相同主机测试，由于没有网络数据传播时延的影响，本机的客户端所有五个FIN都几乎在同一时间传递给服务器， 从而使得服务器的5个子进程基本在同一时刻终止，从而5个SIGCHLD在同一时刻发送给父进程，都在第一个信号处理函数执行之前发生， 而Unix信号一般是不排队的（这里详见TLPI对应的小节），因此信号处理函数只执行一次。\n但是如果在不同主机测试，由于网络数据传播，各个FIN到达服务器的时间差较大一些，导致FIN以不可忽略的时差到达服务器。 例如在处理第一个SIGCHLD信号时，其他FIN才到达，从而引起信号处理函数执行多次。\n1 2 3 4 5 6 7 ➜ bin git:(main) ✗ ./TCPSERV03 \u0026 [1] 65001 ➜ bin git:(main) ✗ ./TCPCLI04 127.0.0.1 hell hell child 65324 terminated child 65325 terminated waitpid()版本行得通 清理僵尸进程 1 2 while ((pid = waitpid(-1, \u0026stat, WNOHANG)) \u003e 0) printf(\"child %d terminated\\n\", pid); waitpid(-1, \u0026stat, WNOHANG)：这部分代码是关键。waitpid 函数用于等待子进程的状态改变。\npid = -1：表示等待任何子进程。 \u0026stat：是一个指向 int 的指针，用于存储子进程的终止状态。 WNOHANG：这个选项告诉 waitpid 非阻塞运行。如果没有子进程终止，waitpid 将立即返回，而不是阻塞等待。 while 循环：这个循环会一直执行，直到没有子进程终止为止。waitpid 返回值会是：\n大于 0 的值：表示终止的子进程的 PID，表明有一个子进程结束。 0：表示没有子进程终止。 -1：表示没有更多的子进程或者调用失败。 代码总结 这段代码实现了一个信号处理函数 sig_chld，用于处理 SIGCHLD 信号。当一个子进程终止时，父进程会收到 SIGCHLD 信号，触发这个处理函数。该函数使用 waitpid 结合 WNOHANG 选项来处理所有终止的子进程，并避免产生僵尸进程。僵尸进程会占用系统资源，因此在接收到 SIGCHLD 信号时及时清理子进程的退出状态是很重要的。\n这种处理方式确保了父进程可以继续处理多个子进程的终止，而不会因为某个子进程的终止而导致阻塞，从而避免产生僵尸进程。\n运行结果：\n1 2 3 4 5 6 7 8 9 10 ➜ bin git:(main) ✗ ./TCPSERV04 \u0026 [1] 56786 ➜ bin git:(main) ✗ ./TCPCLI04 127.0.0.1 htl htl child 56992 terminated child 56993 terminated child 56994 terminated child 56995 terminated child 56996 terminated 不在循环内部使用wait()的原因 在信号处理函数中使用 waitpid() 而不是 wait() 的原因主要涉及到以下几个方面：\n1. 避免遗漏子进程的终止 waitpid() 在循环中与 WNOHANG 选项一起使用，可以确保所有已终止的子进程都被处理。因为 waitpid() 在每次调用时返回一个已终止的子进程的 PID，当没有更多子进程终止时返回 0。通过循环调用 waitpid()，你可以确保每个已终止的子进程都被正确处理，从而避免遗漏。\n相比之下，wait() 只能一次等待一个子进程终止。如果有多个子进程在短时间内终止，而 wait() 只被调用一次，可能会遗漏处理其中的一些子进程。这些未处理的子进程就会成为僵尸进程，浪费系统资源。\n2. 非阻塞的等待 waitpid() 与 WNOHANG 选项结合使用是非阻塞的，它允许信号处理程序检查所有子进程是否终止，而不会因没有终止的子进程而阻塞。这样，信号处理函数可以迅速返回，继续处理其他任务。\n在没有循环时，调用wait()不会导致出现阻塞等待，因为当进入该处理函数时，说明必然有函数终止了，只不过是1个还是多个的问题 无论是一个还是多个，wait()都只能处理掉一个，然后返回，退出处理器函数\n如果在循环中调用 wait()，一旦没有子进程终止，wait() 就会阻塞，这会导致整个信号处理程序挂起，不能立即返回。 例如，第一个进程终止后，父进程进入了处理器函数，处理了第一个进程之后，便会继续循环等待下一个终止进程， 若是下一个进程迟迟不进入终止状态，则父进程则需要一直阻塞等待。 阻塞在信号处理程序中通常是不被推荐的，因为这可能导致系统其他部分的延迟或不良的响应时间。\n3. 处理多个子进程的终止 在某些情况下，多个子进程可能在非常短的时间内几乎同时终止。如果仅调用 wait()，信号处理程序可能只能处理一个子进程的终止。使用 waitpid() 的循环可以确保处理所有已终止的子进程。 4. 控制和灵活性 waitpid() 提供了更多的控制和灵活性。例如，使用 waitpid() 可以指定等待特定的子进程，或根据不同的选项处理子进程。相比之下，wait() 的功能比较有限，只能简单地等待任意一个子进程的终止。 ","wordCount":"227","inLanguage":"en","image":"https://fireflyyh.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-07-31T00:00:00Z","dateModified":"2024-07-31T00:00:00Z","author":{"@type":"Person","name":"Jagger"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fireflyyh.top/posts/unp/sigchldwaitpid/"},"publisher":{"@type":"Organization","name":"Jagger's Blog","logo":{"@type":"ImageObject","url":"https://fireflyyh.top/img/yuan.jpg"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y30PKHXBN4"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y30PKHXBN4")</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fireflyyh.top/ accesskey=h title="Jagger's Blog (Alt + H)"><img src=https://fireflyyh.top/img/laugh.jpg alt aria-label=logo height=35>Jagger's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://fireflyyh.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://fireflyyh.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://fireflyyh.top/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://fireflyyh.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://fireflyyh.top/about/ title=About><span>About</span></a></li><li><a href=https://github.com/starsYHyh/Jagger/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fireflyyh.top/>Home</a>&nbsp;»&nbsp;<a href=https://fireflyyh.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">处理SIGCHLD信号</h1><div class=post-meta><span title='2024-07-31 00:00:00 +0000 UTC'>July 31, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;227 words&nbsp;·&nbsp;Jagger&nbsp;|&nbsp;<a href=https://github.com/starsYHyh/Jagger/tree/main/content/posts/UNP/sigchldwaitpid.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%a4%84%e7%90%86sigchld%e4%bf%a1%e5%8f%b7 aria-label=处理SIGCHLD信号>处理SIGCHLD信号</a></li><li><a href=#wait%e7%89%88%e6%9c%ac%e8%a1%8c%e4%b8%8d%e9%80%9a%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label=wait版本行不通的原因>wait版本行不通的原因</a></li><li><a href=#waitpid%e7%89%88%e6%9c%ac%e8%a1%8c%e5%be%97%e9%80%9a aria-label=waitpid()版本行得通><code>waitpid()</code>版本行得通</a><ul><li><a href=#%e6%b8%85%e7%90%86%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b aria-label=清理僵尸进程><strong>清理僵尸进程</strong></a></li><li><a href=#%e4%bb%a3%e7%a0%81%e6%80%bb%e7%bb%93 aria-label=代码总结><strong>代码总结</strong></a></li></ul></li><li><a href=#%e4%b8%8d%e5%9c%a8%e5%be%aa%e7%8e%af%e5%86%85%e9%83%a8%e4%bd%bf%e7%94%a8wait%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label=不在循环内部使用wait()的原因>不在循环内部使用<code>wait()</code>的原因</a><ul><li><a href=#1-%e9%81%bf%e5%85%8d%e9%81%97%e6%bc%8f%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%bb%88%e6%ad%a2 aria-label="1. 避免遗漏子进程的终止">1. <strong>避免遗漏子进程的终止</strong></a></li><li><a href=#2-%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%9a%84%e7%ad%89%e5%be%85 aria-label="2. 非阻塞的等待">2. <strong>非阻塞的等待</strong></a></li><li><a href=#3-%e5%a4%84%e7%90%86%e5%a4%9a%e4%b8%aa%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%bb%88%e6%ad%a2 aria-label="3. 处理多个子进程的终止">3. <strong>处理多个子进程的终止</strong></a></li><li><a href=#4-%e6%8e%a7%e5%88%b6%e5%92%8c%e7%81%b5%e6%b4%bb%e6%80%a7 aria-label="4. 控制和灵活性">4. <strong>控制和灵活性</strong></a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=处理sigchld信号>处理SIGCHLD信号<a hidden class=anchor aria-hidden=true href=#处理sigchld信号>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sig_chld</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>stat</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// wait()是为了清理僵死进程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// pid = wait(&amp;stat);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// printf(&#34;child %d terminated\n&#34;, pid);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stat</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child %d terminated</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=wait版本行不通的原因>wait版本行不通的原因<a hidden class=anchor aria-hidden=true href=#wait版本行不通的原因>#</a></h2><blockquote><p>若服务器和客户端在同一主机上，则该信号处理函数只执行过一次（根据UNP的描述是这样的，但是本人实测，信号处理器函数执行了两次）。
但是如果我们在不同的主机上运行客户和服务器，那么信号处理器函数一般执行两次：一次是由第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因为该处理函数仅仅再被调用一次，从而留下3个僵死进程。
不过有的时候，根据FIN到达主机的时机，信号处理函数可能会执行3次甚至4次</p></blockquote><p>根据本人猜想，如果在相同主机测试，由于没有网络数据传播时延的影响，本机的客户端所有五个FIN都几乎在同一时间传递给服务器，
从而使得服务器的5个子进程基本在同一时刻终止，从而5个SIGCHLD在同一时刻发送给父进程，都在第一个信号处理函数执行之前发生，
而Unix信号一般是不排队的（这里详见TLPI对应的小节），因此信号处理函数只执行一次。</p><p>但是如果在不同主机测试，由于网络数据传播，各个FIN到达服务器的时间差较大一些，导致FIN以不可忽略的时差到达服务器。
例如在处理第一个SIGCHLD信号时，其他FIN才到达，从而引起信号处理函数执行多次。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>➜  bin git:<span class=o>(</span>main<span class=o>)</span> ✗ ./TCPSERV03 <span class=p>&amp;</span>       
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>65001</span>
</span></span><span class=line><span class=cl>➜  bin git:<span class=o>(</span>main<span class=o>)</span> ✗ ./TCPCLI04 127.0.0.1
</span></span><span class=line><span class=cl>hell
</span></span><span class=line><span class=cl>hell
</span></span><span class=line><span class=cl>child <span class=m>65324</span> terminated                                   
</span></span><span class=line><span class=cl>child <span class=m>65325</span> terminated
</span></span></code></pre></td></tr></table></div></div><h2 id=waitpid版本行得通><code>waitpid()</code>版本行得通<a hidden class=anchor aria-hidden=true href=#waitpid版本行得通>#</a></h2><h3 id=清理僵尸进程><strong>清理僵尸进程</strong><a hidden class=anchor aria-hidden=true href=#清理僵尸进程>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stat</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child %d terminated</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p><code>waitpid(-1, &amp;stat, WNOHANG)</code>：这部分代码是关键。<code>waitpid</code> 函数用于等待子进程的状态改变。</p><ul><li><code>pid = -1</code>：表示等待任何子进程。</li><li><code>&amp;stat</code>：是一个指向 <code>int</code> 的指针，用于存储子进程的终止状态。</li><li><code>WNOHANG</code>：这个选项告诉 <code>waitpid</code> 非阻塞运行。如果没有子进程终止，<code>waitpid</code> 将立即返回，而不是阻塞等待。</li></ul></li><li><p><code>while</code> 循环：这个循环会一直执行，直到没有子进程终止为止。<code>waitpid</code> 返回值会是：</p><ul><li>大于 0 的值：表示终止的子进程的 PID，表明有一个子进程结束。</li><li>0：表示没有子进程终止。</li><li>-1：表示没有更多的子进程或者调用失败。</li></ul></li></ul><h3 id=代码总结><strong>代码总结</strong><a hidden class=anchor aria-hidden=true href=#代码总结>#</a></h3><p>这段代码实现了一个信号处理函数 <code>sig_chld</code>，用于处理 <code>SIGCHLD</code> 信号。当一个子进程终止时，父进程会收到 <code>SIGCHLD</code> 信号，触发这个处理函数。该函数使用 <code>waitpid</code> 结合 <code>WNOHANG</code> 选项来处理所有终止的子进程，并避免产生僵尸进程。僵尸进程会占用系统资源，因此在接收到 <code>SIGCHLD</code> 信号时及时清理子进程的退出状态是很重要的。</p><p>这种处理方式确保了父进程可以继续处理多个子进程的终止，而不会因为某个子进程的终止而导致阻塞，从而避免产生僵尸进程。</p><p>运行结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>➜  bin git:<span class=o>(</span>main<span class=o>)</span> ✗ ./TCPSERV04 <span class=p>&amp;</span>       
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>56786</span>
</span></span><span class=line><span class=cl>➜  bin git:<span class=o>(</span>main<span class=o>)</span> ✗ ./TCPCLI04 127.0.0.1
</span></span><span class=line><span class=cl>htl
</span></span><span class=line><span class=cl>htl
</span></span><span class=line><span class=cl>child <span class=m>56992</span> terminated                                   
</span></span><span class=line><span class=cl>child <span class=m>56993</span> terminated
</span></span><span class=line><span class=cl>child <span class=m>56994</span> terminated
</span></span><span class=line><span class=cl>child <span class=m>56995</span> terminated
</span></span><span class=line><span class=cl>child <span class=m>56996</span> terminated
</span></span></code></pre></td></tr></table></div></div><h2 id=不在循环内部使用wait的原因>不在循环内部使用<code>wait()</code>的原因<a hidden class=anchor aria-hidden=true href=#不在循环内部使用wait的原因>#</a></h2><p>在信号处理函数中使用 <code>waitpid()</code> 而不是 <code>wait()</code> 的原因主要涉及到以下几个方面：</p><h3 id=1-避免遗漏子进程的终止>1. <strong>避免遗漏子进程的终止</strong><a hidden class=anchor aria-hidden=true href=#1-避免遗漏子进程的终止>#</a></h3><ul><li><p><code>waitpid()</code> 在循环中与 <code>WNOHANG</code> 选项一起使用，可以确保所有已终止的子进程都被处理。因为 <code>waitpid()</code> 在每次调用时返回一个已终止的子进程的 PID，当没有更多子进程终止时返回 0。通过循环调用 <code>waitpid()</code>，你可以确保每个已终止的子进程都被正确处理，从而避免遗漏。</p></li><li><p>相比之下，<code>wait()</code> 只能一次等待一个子进程终止。如果有多个子进程在短时间内终止，而 <code>wait()</code> 只被调用一次，可能会遗漏处理其中的一些子进程。这些未处理的子进程就会成为僵尸进程，浪费系统资源。</p></li></ul><h3 id=2-非阻塞的等待>2. <strong>非阻塞的等待</strong><a hidden class=anchor aria-hidden=true href=#2-非阻塞的等待>#</a></h3><ul><li><p><code>waitpid()</code> 与 <code>WNOHANG</code> 选项结合使用是非阻塞的，它允许信号处理程序检查所有子进程是否终止，而不会因没有终止的子进程而阻塞。这样，信号处理函数可以迅速返回，继续处理其他任务。</p></li><li><p>在没有循环时，调用<code>wait()</code>不会导致出现阻塞等待，因为当进入该处理函数时，说明必然有函数终止了，只不过是1个还是多个的问题
无论是一个还是多个，<code>wait()</code>都只能处理掉一个，然后返回，退出处理器函数</p></li><li><p>如果在循环中调用 <code>wait()</code>，一旦没有子进程终止，<code>wait()</code> 就会阻塞，这会导致整个信号处理程序挂起，不能立即返回。
例如，第一个进程终止后，父进程进入了处理器函数，处理了第一个进程之后，便会继续循环等待下一个终止进程，
若是下一个进程迟迟不进入终止状态，则父进程则需要一直阻塞等待。
阻塞在信号处理程序中通常是不被推荐的，因为这可能导致系统其他部分的延迟或不良的响应时间。</p></li></ul><h3 id=3-处理多个子进程的终止>3. <strong>处理多个子进程的终止</strong><a hidden class=anchor aria-hidden=true href=#3-处理多个子进程的终止>#</a></h3><ul><li>在某些情况下，多个子进程可能在非常短的时间内几乎同时终止。如果仅调用 <code>wait()</code>，信号处理程序可能只能处理一个子进程的终止。使用 <code>waitpid()</code> 的循环可以确保处理所有已终止的子进程。</li></ul><h3 id=4-控制和灵活性>4. <strong>控制和灵活性</strong><a hidden class=anchor aria-hidden=true href=#4-控制和灵活性>#</a></h3><ul><li><code>waitpid()</code> 提供了更多的控制和灵活性。例如，使用 <code>waitpid()</code> 可以指定等待特定的子进程，或根据不同的选项处理子进程。相比之下，<code>wait()</code> 的功能比较有限，只能简单地等待任意一个子进程的终止。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://fireflyyh.top/tags/unp/>UNP</a></li><li><a href=https://fireflyyh.top/tags/tcpcliserv/>Tcpcliserv</a></li></ul><nav class=paginav><a class=prev href=https://fireflyyh.top/posts/tlpi/t_sigaltstack/><span class=title>« Prev</span><br><span>在备选栈中处理信号</span>
</a><a class=next href=https://fireflyyh.top/posts/blog_configuration/deploy/><span class=title>Next »</span><br><span>将博客部署到阿里云服务器</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://fireflyyh.top/>Jagger's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function i(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(n),s.appendChild(t)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(s.appendChild(n),e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t)):(s.appendChild(n),e.parentNode.appendChild(t)))})</script></body></html>