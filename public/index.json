[{"content":"摘要 我们设计并实现了谷歌文件系统，这是一个可扩展的分布式文件系统，适用于大型分布式数据密集型应用。该系统可在廉价的商品硬件上运行，同时提供容错功能，并能为大量客户端提供高聚合性能。\n我们的设计目标与之前的分布式文件系统有许多相同之处，但我们对应用工作负载和技术环境（包括当前和预期环境）的观察结果表明，我们的设计明显偏离了之前的一些文件系统假设。这促使我们重新审视传统的选择，探索完全不同的设计要点。\n文件系统成功地满足了我们的存储需求。它在谷歌内部被广泛部署，作为生成和处理我们的服务所使用的数据以及需要大型数据集的研发工作的存储平台。迄今为止，最大的集群在一千多台机器上的数千个磁盘上提供了数百 TB 的存储空间，并被数百个客户端并发访问。\n在本文中，我们介绍了为支持分布式应用而设计的文件系统接口扩展，讨论了我们设计的许多方面，并报告了微基准测试和实际使用的测量结果。\n1. 引言 我们设计并实施了谷歌文件系统（GFS），以满足谷歌快速增长的数据处理需求。GFS 与以前的分布式文件系统有许多相同的目标，如性能、可扩展性、可靠性和可用性。但是，在设计 GFS 时，我们对当前和预期的应用工作负载和技术环境进行了重要观察，这反映出我们明显偏离了之前的一些文件系统设计假设。我们重新审视了传统的选择，并探索了设计空间中完全不同的点。\n首先，组件故障是常态而非例外。文件系统由数百甚至数千台存储机组成，这些存储机都是用廉价的商品部件制造的，并被数量相当的客户机访问。这些组件的数量和质量几乎可以保证，在任何特定时间都会有一些组件无法正常工作，而且有些组件无法从当前故障中恢复。我们见过应用程序错误、操作系统错误、人为错误以及磁盘、内存、连接器、网络和电源故障造成的问题。因此，持续监控、错误检测、容错和自动恢复必须成为系统的组成部分。\n其次，按照传统的标准，文件是巨大的。多 GB 的文件很常见。每个文件通常包含许多应用对象，如网络文档。当我们经常处理由数十亿个对象组成的多 TB 快速增长的数据集时，即使文件系统可以支持，要管理数十亿个约 KB 大小的文件也很不方便。因此，必须重新审视 I/O 操作和块大小等设计假设和参数。\n第三，大多数文件都是通过添加新数据而不是覆盖现有数据来改变的。文件内的随机写入几乎不存在。文件一旦写入，就只能读取，而且通常只能按顺序读取。各种数据都具有这些特征。有些可能是数据分析程序扫描过的大型存储库。有些可能是运行中的应用程序持续生成的数据流。有些可能是档案数据。有些可能是在一台机器上生成并在另一台机器上处理的中间结果，无论是同时处理还是稍后处理。鉴于巨型文件的这种访问模式，追加成为性能优化和原子性保证的重点，而在客户端缓存数据块则失去了吸引力。\n第四，共同设计应用程序和文件系统 API 可以提高我们的灵活性，从而使整个系统受益。例如，我们放宽了 GFS 的一致性模型，大大简化了文件系统，而不会给应用程序带来沉重负担。我们还引入了原子追加操作，使多个客户端可以同时追加文件，而无需额外的同步。本文稍后将详细讨论这些内容。\n目前，为不同目的部署了多个 GFS 集群。最大的集群有超过 1000 个存储节点，超过 300 TB 的磁盘存储空间，数百个客户端在不同的机器上持续大量访问。\n2. 设计概述 2.1 假设 在设计满足我们需求的文件系统时，我们遵循的假设既是挑战也是机遇。我们在前面提到了一些重要的观察结果，现在详细介绍一下我们的假设。\n该系统由许多经常发生故障的廉价商品组件构成。系统必须不断进行自我监控，日常检测、容忍和及时恢复组件故障。 系统存储的大文件数量不多。我们预计会有几百万个文件，每个文件的大小通常为 100 MB 或更大。多 GB 文件是常见情况，应得到有效管理。我们必须支持小文件，但无需对其进行优化。 工作负载主要包括两种读取：大型流式读取和小型随机读取。在大数据流读取中，单个操作通常读取数百 KB，更常见的是 1 MB 或更多。来自同一客户端的连续操作通常会读取文件的连续区域。小型随机读取通常在某个任意偏移位置读取几个 KB 的数据。注重性能的应用程序通常会对小规模读取进行批处理和排序，以稳定地读取文件，而不是来回读取。 这些工作负载中还有许多向文件追加数据的大型连续写入操作。典型的操作大小与读取类似。文件一旦写入，就很少再修改。支持在文件任意位置进行小规模写入，但不一定要高效。 系统必须有效地实现多个客户端同时追加到同一文件的定义明确的语义。我们的文件通常用作生产者-消费者队列或多路合并。数以百计的生产者（每台机器运行一个）将同时追加到一个文件。同步开销最小的原子性至关重要。文件可能会在稍后被读取，或者消费者可能会同时读取文件。 高持续带宽比低延迟更重要。我们的大多数目标应用都非常重视高速批量处理数据，而很少有应用对单个读取或写入的响应时间有严格要求。 2.2 接口 GFS 提供了一个熟悉的文件系统接口，尽管它没有实现标准的 API（如 POSIX）。文件在目录中按层次组织，并用路径名标识。我们支持创建、删除、打开、关闭、读取和写入文件的常规操作。\n此外，GFS 还有快照和记录追加操作。快照以低成本创建文件或目录树的副本。记录追加允许多个客户端同时向同一个文件追加数据，同时保证每个客户端追加的原子性。它适用于实现多向合并结果和生产者-消费者队列，许多客户端可以同时追加数据而无需额外锁定。我们发现，这些类型的文件在构建大型分布式应用时非常有用。快照追加和记录追加将分别在第 3.4 节和第 3.3 节中进一步讨论。\n2.3 架构 如图 1 所示，GFS 集群由一个主服务器和多个分块服务器组成，并由多个客户端访问。每个客户端通常是一台运行用户级服务器进程的商用 Linux 机器。只要机器资源允许，并且可以接受运行可能不稳定的应用程序代码所带来的较低可靠性，在同一台机器上同时运行分块服务器和客户端是很容易的。\n文件被分成固定大小的块。每个分块都由主服务器程序在创建分块时分配的不可更改且全球唯一的 64 位分块句柄来标识。分块服务器将分块作为 Linux 文件存储在本地磁盘上，并读取或写入由分块句柄和字节范围指定的分块数据。为了保证可靠性，每个数据块都会在多个数据块服务器上复制。默认情况下，我们会存储三个副本，但用户可以为文件命名空间的不同区域指定不同的复制级别。\n主文件系统维护所有文件系统元数据。其中包括命名空间、访问控制信息、文件到分块的映射以及分块的当前位置。主服务器还控制着全系统的活动，如块租约管理、孤儿块的垃圾回收以及块服务器之间的块迁移。主服务器会定期通过 HeartBeat 消息与每个块服务器进行通信，向其下达指令并收集其状态。\n连接到每个应用程序的 GFS 客户端代码实现文件系统 API，并与主服务器程序和块服务器通信，代表应用程序读取或写入数据。客户端与主服务器交互元数据操作，但所有数据通信都直接与块服务器进行。我们不提供 POSIX API，因此无需连接 Linux vnode 层。\n客户端和分块服务器都不缓存文件数据。客户端缓存的好处不大，因为大多数应用程序都会流式处理大量文件，或者工作集过大而无法缓存。没有缓存可以消除缓存一致性问题，从而简化客户端和整个系统。（但客户端会缓存元数据）。块服务器无需缓存文件数据，因为块是以本地文件的形式存储的，因此 Linux 的缓冲缓存已经将经常访问的数据保存在内存中。\n2.4 单个主服务器 单个主服务器大大简化了我们的设计，并使主服务器能够利用全局知识做出复杂的分块放置和复制决策。不过，我们必须尽量减少主服务器程序对读写的参与，以免其成为瓶颈。客户端从不通过主服务器读写文件数据。相反，客户端会询问主服务器它应该联系哪些分块服务器。客户端会在有限的时间内缓存这些信息，并在随后的许多操作中直接与分块服务器交互。\n让我们参照图 1 来解释一下简单读取的交互过程。首先，客户端使用固定的块大小，将应用程序指定的文件名和字节偏移转化为文件中的块索引。然后，客户端向主服务器程序发送包含文件名和块索引的请求。主服务器会回复相应的块句柄和副本位置。客户端使用文件名和块索引作为密钥缓存这些信息。\n然后，客户端向其中一个副本（很可能是最近的副本）发送请求。该请求指定了数据块句柄和该数据块内的字节范围。在缓存信息过期或文件重新打开之前，对同一数据块的进一步读取不再需要客户端与主服务器端之间的交互。事实上，客户端通常会在同一个请求中请求多个数据块，主服务器程序也可以包含紧随其后的数据块信息。这些额外的信息可以避免今后客户端与主服务器端之间的多次交互，而且几乎没有额外成本。\n2.5 分块大小 块大小是关键设计参数之一。我们选择了 64 MB，这比典型的文件系统块大小大得多。每个块副本都作为普通 Linux 文件存储在块服务器上，并且仅在需要时进行扩展。懒惰空间分配可避免因内部碎片而浪费空间，这可能是对如此大的块大小的最大反对意见。\n大块大小具有几个重要优势。首先，它减少了客户端与主服务器程序交互的需要，因为对同一分块的读写只需向主服务器程序发出一次初始请求，以获取分块位置信息。这对我们的工作负载来说意义尤其重大，因为应用程序大多是顺序读写大文件。即使是小规模的随机读取，客户端也能轻松缓存多 TB 工作集的所有分块定位信息。其次，由于在大块上，客户端更有可能对给定的大块执行许多操作，因此可以通过长时间保持与大块服务器的持久 TCP 连接来减少网络开销。第三，它可以减少存储在主服务器上的元数据的大小。这样我们就能将元数据保存在内存中，从而带来其他优势，我们将在第 2.6.1 节中讨论。\n另一方面，即使使用懒惰空间分配，大块大小也有其缺点。小文件由少量的块组成，也许只有一个。如果有很多客户端访问同一个文件，存储这些分块的分块服务器可能会成为热点。在实际应用中，热点并不是一个大问题，因为我们的应用程序大多是按顺序读取大型多块文件。\n然而，当 GFS 首次用于批处理队列系统时，确实出现了热点：一个可执行文件以单块文件的形式写入 GFS，然后在数百台机器上同时启动。数以百计的同时请求使存储该可执行文件的少数主块服务器不堪重负。我们通过使用更高的复制系数来存储此类可执行文件，并让批队列系统错开应用程序的启动时间，从而解决了这一问题。一个潜在的长期解决方案是允许客户端在这种情况下从其他客户端读取数据。\n2.6 元数据 主服务器存储三种主要类型的元数据：文件和块命名空间、从文件到块的映射以及每个块的副本的位置。所有元数据都保存在主服务器的内存中。前两种类型（命名空间和文件到块的映射）也通过将变化记录到存储在主服务器本地磁盘上的操作日志中并复制到远程机器上来保持持久性。使用日志使我们能够简单、可靠地更新主服务器状态，并且在主服务器崩溃时不会冒不一致的风险。主服务器不会持久存储块位置信息。相反，它会在主服务器启动时以及每当有块服务器加入集群时向每个块服务器询问其块。\n2.6.1 内存数据结构 由于元数据存储在内存中，因此主服务器操作速度很快。此外，主服务器在后台定期扫描其整个状态也非常简单高效。这种周期性扫描被用来实现垃圾块收集、在主块服务器出现故障时进行重新复制以及主块迁移，以平衡主块服务器之间的负载和磁盘空间使用。第4.3节和第4.4节将进一步讨论这些活动。\n这种只使用内存的方法可能存在的一个问题是，分块的数量以及整个系统的容量都受到主服务器内存容量的限制。实际上，这并不是一个严重的限制。主文件会为每个 64 MB 的数据块维护少于 64 字节的元数据。大多数分块都是满的，因为大多数文件包含许多分块，只有最后一个分块可能被部分填满。同样，文件命名空间数据通常每个文件只需要少于 64 字节，因为它使用前缀压缩紧凑地存储了文件名。\n如果有必要支持更大的文件系统，为主文件系统增加额外内存的成本并不高，但却能通过在内存中存储元数据而获得简单性、可靠性、性能和灵活性。\n2.6.2 分块位置 主服务器程序不会持续记录哪些分块服务器拥有某个分块的副本。它只需在启动时轮询各块服务器以获取该信息。由于主服务器控制着所有的分块放置，并通过定期的 HeartBeat 信息监控分块服务器的状态，因此主服务器可以随时更新自己的信息。\n我们最初尝试在主服务器端持久保存块位置信息，但后来发现，在启动时和之后定期从块服务器请求数据要简单得多。这样就解决了主服务器和块服务器在块服务器加入、离开集群、更名、故障、重启等情况下保持同步的问题。在拥有数百台服务器的集群中，这些事件经常发生。\n理解这一设计决定的另一种方法是认识到，对于自己的磁盘上是否有数据块，数据块服务器拥有最终决定权。试图在主服务器上保持对这些信息的一致看法是没有意义的，因为数据块服务器上的错误可能会导致数据块自发消失（例如，磁盘坏掉并被禁用），或者操作员可能会重命名数据块服务器。\n2.6.3 操作日志 操作日志包含关键元数据更改的历史记录。它是 GFS 的核心。它不仅是元数据的唯一持久记录，还是定义并发操作顺序的逻辑时间线。文件和数据块以及它们的版本（见第 4.5 节）都以它们创建的逻辑时间为唯一且永恒的标识。\n由于操作日志至关重要，因此我们必须可靠地存储操作日志，并且在元数据更改持久化之前，不能让客户端看到更改。否则，即使数据块本身存活下来，我们也会丢失整个文件系统或最近的客户端操作。因此，我们将日志复制到多台远程机器上，只有在本地和远程将相应的日志记录刷新到磁盘后，才能响应客户端操作。在刷新之前，主服务器程序会将多条日志记录集中在一起，从而减少刷新和复制对整个系统吞吐量的影响。\n主服务器通过重放操作日志来恢复其文件系统状态。为了最大限度地缩短启动时间，我们必须保持日志较小。每当日志超过一定大小时，主服务器都会检查其状态，以便它可以通过从本地磁盘加载最新的检查点并在此之后仅重放有限数量的日志记录来恢复。检查点采用紧凑的 B 树形式，可以直接映射到内存中并用于命名空间查找，而无需额外解析。这进一步加快了恢复速度并提高了可用性。\n由于创建一个检查点可能需要一段时间，因此主服务器的内部状态结构应能在不耽误接收传入的变更的情况下创建新的检查点。主服务器会切换到新的日志文件，并在单独的线程中创建新的检查点。新的检查点包括切换前的所有变更。对于拥有几百万个文件的集群来说，一分钟左右就能创建完毕。完成后，它将被写入本地和远程磁盘。\n恢复只需要最新的完整检查点和后续日志文件。较早的检查点和日志文件可以随意删除，但我们会保留一些以防万一。检查点过程中的故障不会影响正确性，因为恢复代码会检测并跳过不完整的检查点。\n2.7 一致性模型 GFS 有一个宽松的一致性模型，可以很好地支持我们的高度分布式应用，而且实现起来相对简单高效。我们现在讨论 GFS 的保证及其对应用程序的意义。我们还将重点介绍 GFS 如何维护这些保证，但具体细节将留待本文其他部分讨论。\n2.7.1 GFS的保证 文件命名空间的变更（如文件创建）是原子性的。它们完全由主服务器程序处理：命名空间锁定保证了原子性和正确性（第 4.1 节）；主服务器程序的操作日志定义了这些操作的全局总顺序（第 2.6.3 节）。\n文件区域在数据变更后的状态取决于变更的类型、变更是否成功，以及是否存在并发变更。表1总结了结果。如果所有客户端无论从哪个副本读取数据都始终看到相同的数据，则文件区域是一致的（consistent）。在文件数据变更后，如果区域是一致的，并且客户端能够完整地看到其变更所写入的内容，则该区域是确定的（defined）。当一个变更在没有并发写入者干扰的情况下成功时，受影响的区域则为确定的（包含了一致性）：所有客户端将始终看到变更所写入的内容。并发成功的变更使区域不确定但仍然一致：所有客户端看到相同的数据，但这些数据可能无法反映任何单个变更的内容。通常，这些数据由多个变更的混合片段组成。失败的变更使区域变得不一致（因此也不确定）：不同的客户端可能在不同的时间看到不同的数据。下面我们将描述我们的应用程序如何区分确定与不确定区域。应用程序不需要进一步区分不同类型的不确定区域。\n数据变更可以是写入操作或记录追加操作。写入操作会在应用程序指定的文件偏移位置写入数据。记录追加操作会在存在并发变更的情况下，以原子方式至少追加一次数据（即“记录”），但写入的位置由 GFS 选择（见第3.3节）。（与此相反，\u0026ldquo;常规 \u0026ldquo;追加只是在客户端认为是当前文件末尾的偏移位置进行写入）。偏移量会返回给客户端，并标志着包含记录的确定区域的开始。此外，GFS 还可能在中间插入填充或重复记录。它们占据的区域被认为是不一致的，与用户数据量相比通常相形见绌。\n在一连串成功的变更之后，变更后的文件区域保证是已确定的，并包含最后一次变更所写入的数据。GFS 通过以下方式实现这一目标：(a) 在所有副本上以相同顺序对一个主块进行变异（第 3.1 节）；(b) 使用主块版本号来检测因其主块服务器宕机而错过变异的副本（第 4.5 节）。陈旧副本绝不会参与变更，也不会提供给向主服务器询问主块位置的客户端。它们会尽早被垃圾回收。\n由于客户端会缓存块定位，因此可能会在信息刷新前从陈旧的副本中读取信息。这个窗口会受到缓存条目超时和下一次打开文件的限制，因为下一次打开文件会从缓存中清除该文件的所有分块信息。此外，由于我们的大多数文件都是仅附加的，因此陈旧的副本通常会返回一个过早结束的分块，而不是过时的数据。当阅读器重试并联系主文件时，它将立即获得当前的分块位置。\n当然，在成功变更后的很长一段时间内，组件故障仍有可能损坏或毁坏数据。GFS 通过主服务器与所有主服务器之间的定期握手来识别故障的主服务器，并通过校验和来检测数据损坏（第 5.2 节）。一旦出现问题，就会尽快从有效副本中恢复数据（第 4.3 节）。只有当数据块的所有副本在 GFS 作出反应前丢失（通常在几分钟内），数据块才会不可逆转地丢失。即使在这种情况下，数据块也是不可用的，而不是损坏的：应用程序收到的是明确的错误，而不是损坏的数据。\n2.7.2 对应用的影响 GFS 应用程序可以通过其他用途所需的一些简单技术来适应宽松的一致性模型：依靠追加而不是覆盖、检查点以及写入自验证、自识别记录。\n实际上，我们所有的应用程序都是通过追加而不是覆盖来改变文件的。在一个典型的应用中，写入器从头到尾生成一个文件。在写入所有数据后，它会以原子方式将文件重命名为永久名称，或定期检查已成功写入多少数据。检查点还可能包括应用级校验和。读取器只验证和处理上一个检查点之前的文件区域，因为已知该区域处于确定的状态。无论一致性和并发性问题如何，这种方法都很有效。与随机写入相比，追加的效率要高得多，对应用程序故障的恢复能力也更强。检查点允许写入程序以增量方式重新启动，并防止读取程序处理从应用程序角度来看仍不完整的已成功写入文件数据。\n在另一种典型用途中，许多写入器同时向文件追加合并结果或作为生产者-消费者队列。记录追加的 \u0026ldquo;至少追加一次 \u0026ldquo;语义保留了每个写入器的输出。读取器会按如下方式处理偶尔出现的填充和重复。写入器编写的每条记录都包含校验和等额外信息，以便验证其有效性。阅读器可以使用校验和来识别和丢弃额外的填充和记录片段。如果不能容忍偶尔出现的重复记录（例如，如果重复记录会触发非幂等操作），则可以使用记录中的唯一标识符将其过滤掉。记录 I/O 的这些功能（除重复删除外）都在我们应用程序共享的库代码中，也适用于谷歌的其他文件接口实现。有了这些功能，我们就能始终向记录阅读器提供相同序列的记录，以及极少数的重复记录。\n3. 系统交互 我们在设计系统时尽量减少主服务器对所有操作的参与。有了上述背景，我们现在来介绍客户端、主服务器端和分块服务器是如何交互实现数据变更、原子记录追加和快照的。\n3.1 租约和变更顺序 变更是指更改数据块内容或元数据的操作，例如写入或追加操作。每次变更都会在所有数据块的副本上执行。我们使用租约来维护副本之间一致的变更顺序。主服务器将一个数据块的租约授予其中一个副本，我们称之为主副本。主副本为所有对该数据块的变更选择一个串行顺序。所有副本在应用变更时都遵循这个顺序。因此，全局变更顺序首先由主服务器选择的租约授予顺序定义，而在一个租约内，则由主副本分配的序列号来定义。\n租约机制旨在最小化主服务器的管理开销。租约的初始超时时间为60秒。然而，只要数据块正在被变更，主副本可以向主服务器请求并通常能够获得无限期的租约延长。这些延长请求和授予通过主服务器与所有数据块服务器定期交换的 HeartBeat 消息进行捆绑。当主服务器希望在文件重命名时禁用对该文件的变更时，有时会尝试在租约到期前撤销租约。即使主服务器与主副本失去通信，在旧租约到期后，它也可以安全地将新租约授予另一个副本。\n在图 2 中，我们按照写入的控制流，通过这些编号步骤来说明这一过程。\n客户端向主服务器询问当前哪个数据块服务器持有该数据块的租约，以及其他副本的位置。如果没有副本持有租约，主服务器将向它选择的一个副本授予租约（未显示）。 主服务器会回复主副本的身份和其他（次级）副本的位置。客户端将这些数据缓存以供将来的变更使用。只有在主副本变得不可达或回复称不再持有租约时，客户端才需要再次联系主服务器。 客户端将数据推送到所有副本。客户端可以按照任意顺序进行此操作。每个数据块服务器会在内部的LRU缓存中存储数据，直到数据被使用或过期。通过将数据流与控制流解耦，我们可以根据网络拓扑优化昂贵的数据流调度，而不依赖于哪个数据块服务器是主副本。第3.2节对此进行了进一步讨论。 一旦所有副本确认接收到数据，客户端会向主副本发送写请求。该请求标识了之前推送给所有副本的数据。主副本为接收到的所有变更（可能来自多个客户端）分配连续的序列号，以提供必要的序列化。它按照序列号的顺序将变更应用到其本地状态中。 主副本将写入请求转发给所有次级副本。每个次级副本按照主副本分配的序列号顺序应用变更。 所有次级副本都会回复主副本，表示它们已完成操作。 主副本会向客户端回复。任何在副本处遇到的错误都会报告给客户端。在发生错误的情况下，写操作可能在主副本成功，而在任意数量的次级副本中失败。（如果主副本的写操作失败，它将不会被分配序列号并进行转发。）客户端请求被视为失败，修改区域将处于不一致状态。我们的客户端代码通过重试失败的变更来处理这些错误。它会在步骤（3）到（7）之间进行几次尝试，然后才会回退到从写操作开始重新尝试。 如果应用程序的写操作较大或跨越了数据块边界，GFS客户端代码会将其分解为多个写操作。所有操作都会遵循上述控制流程，但可能与其他客户端的并发操作交错或被覆盖。因此，虽然副本之间的内容会保持一致（因为所有操作在所有副本上都以相同的顺序成功完成），共享文件区域可能最终包含来自不同客户端的片段。正如第2.7节提到的，这会使文件区域处于一致但未确定的状态。\n3.2 数据流 我们将数据流与控制流解耦，以更高效地利用网络资源。控制流从客户端传递到主副本，再从主副本传递到所有次级副本；而数据则以流水线的方式沿着精心选择的链式数据块服务器线性推送。我们的目标是充分利用每台机器的网络带宽，避免网络瓶颈和高延迟连接，并尽量减少推送全部数据的延迟。\n为了充分利用每台机器的网络带宽，数据被沿着一条数据块服务器链线性推送，而不是通过其他拓扑结构（例如树形结构）分发。这样，每台机器的全部出站带宽都用于尽可能快速地传输数据，而不是被分配给多个接收者。\n为了尽可能避免网络瓶颈和高延迟链路（例如，交换机间链路往往同时存在），每台机器都会将数据转发给网络拓扑结构中尚未接收数据的 \u0026ldquo;最近 的\u0026quot;机器。假设客户端正在向分块服务器 S1 至 S4 推送数据。客户端将数据发送到最近的分块服务器，如 S1。S1 将数据转发给离 S1 最近的分块服务器 S2 至 S4，即 S2。同样，S2 将数据转发给离 S2 最近的 S3 或 S4，以此类推。我们的网络结构非常简单，\u0026ldquo;距离 \u0026ldquo;可以通过 IP 地址准确估算。\n为了最大限度地减少延迟，我们通过 TCP 连接进行数据传输的流水线化处理。一旦数据块服务器接收到一部分数据，它就会立即开始转发。流水线机制对我们特别有帮助，因为我们使用的是带有全双工链路的交换网络。立即发送数据不会降低接收速率。在没有网络拥塞的情况下，将 B 字节的数据传输到 R 个副本的理想时间为 B/T + RL，其中 T 是网络吞吐量，L 是两台机器之间传输数据的延迟。我们网络的典型链路速率为 100 Mbps (T)，而L远低于 1 毫秒。因此，1 MB 的数据理想情况下可以在大约 80ms 内分发完成。\n3.3 原子记录追加 GFS 提供了一种称为记录追加的原子追加操作。在传统的写操作中，客户端指定数据写入的偏移量。对于同一区域的并发写操作，无法实现可序列化：该区域可能最终包含来自多个客户端的数据片段。然而，在记录追加操作中，客户端只需指定数据。GFS 会以原子方式（即作为一个连续的字节序列）至少一次将数据追加到文件中，偏移量由 GFS 决定，并将该偏移量返回给客户端。这类似于在 Unix 系统中以 O_APPEND 模式打开文件进行写操作，但避免了多个写入者同时操作时的竞争条件。\n我们的分布式应用程序大量使用记录追加功能，其中不同机器上的许多客户端会同时追加到同一个文件。如果客户端采用传统的写入方式，则需要额外复杂而昂贵的同步，例如通过分布式锁管理器。在我们的工作负载中，此类文件通常用作多生产者/单消费者队列，或包含来自许多不同客户端的合并结果。\n记录追加是一种变更，它遵循第 3.1 节中的控制流，只在主副本有一些额外的逻辑。客户端将数据推送到文件最后一个分块的所有副本中，然后将请求发送给主副本。主副本会检查将记录追加到当前数据块是否会导致数据块超过最大容量（64 MB）。如果会，它就会将分块填充到最大大小，告诉辅助分块也这样做，并回复客户端，说明应在下一个分块上重试操作。（记录追加的大小最多只能是最大分块大小的四分之一，以便将最坏情况下的碎片保持在可接受的水平）。如果记录符合最大大小（这是常见的情况），主副本就会将数据追加到其副本中，并告诉次节点在其确切偏移量处写入数据，最后向客户端回复成功。\n如果任何副本的记录追加失败，客户端会重试操作。因此，同一分块的副本可能包含不同的数据，其中可能包括同一记录的全部或部分副本。GFS 并不保证所有副本在字节上完全相同。它只保证数据作为一个原子单元至少被写入一次。这一特性很容易从简单的观察中得出：要使操作报告成功，数据必须在某个数据块的所有副本上以相同的偏移量写入。此外，在此之后，所有副本的长度至少与记录末尾的长度相同，因此，即使后来不同的副本成为主副本，未来的记录也会被分配到更高的偏移量或不同的分块。就一致性保证而言，成功进行记录追加操作并写入数据的区域是确定的（因此是一致的），而中间区域则是不一致的（因此是未确定的）。正如我们在第 2.7.2 节中所讨论的，我们的应用程序可以处理不一致的区域。\n3.4 快照 快照操作几乎可以瞬间复制文件或目录树（\u0026ldquo;源\u0026rdquo;），同时最大限度地减少对正在进行的变更的干扰。我们的用户用它来快速创建庞大数据集的分支副本（通常是这些副本的递归副本），或者在尝试更改之前对当前状态进行检查，这些更改随后可以很容易地提交或回滚。\n与 AFS [5] 一样，我们使用标准的写时复制技术来实现快照。当主服务器接收到快照请求时，它首先会撤销即将快照文件中的数据块上的所有未完成的租约。这确保了对这些数据块的任何后续写入都需要与主服务器进行交互，以查找租约持有者。这将主服务器就有机会首先创建数据块的新副本。\n租约撤销或过期后，主服务器会将操作记录到磁盘上。然后，它通过复制源文件或目录树的元数据，将此日志记录应用到内存状态。新创建的快照文件指向与源文件相同的块。\n当客户端第一次想要在快照操作之后写入数据块 C 时，它会向主服务器发送请求以查找当前的租约持有者。主服务器注意到数据块 C 的引用计数大于1。它推迟了对客户端请求的回复，而是选择了一个新的数据块句柄 C\u0026rsquo;。然后，主服务器要求每个拥有 C 当前副本的数据块服务器创建一个名为 C\u0026rsquo; 的新数据块。通过在与原始数据块相同的数据块服务器上创建新数据块，我们确保数据可以在本地复制，而不是通过网络复制（我们的磁盘速度约是100 Mb 以太网链接的三倍）。从这一点开始，请求处理与任何数据块的处理没有区别：主服务器将新的数据块 C\u0026rsquo; 的租约授予其中一个副本，并回复客户端，客户端可以正常写入该数据块，而不知道它刚刚是从现有数据块创建的。\n4. 主服务器操作 主服务器执行所有命名空间操作。此外，它还负责管理整个系统中的分块副本：做出放置决定、创建新的分块和副本、协调各种全系统活动以保持分块完全复制、平衡所有分块服务器的负载以及回收未使用的存储空间。下面我们将逐一讨论这些主题。\n4.1 命名空间管理和锁定 许多主服务器操作可能需要较长时间：例如，快照操作必须撤销覆盖快照的所有数据块服务器上的租约。我们不希望在这些操作运行时延迟其他主服务器操作。因此，我们允许多个操作同时进行，并在命名空间的区域上使用锁来确保适当的序列化。\n与许多传统文件系统不同，GFS 没有每个目录的数据显示结构来列出该目录中的所有文件。它也不支持同一个文件或目录的别名（即 Unix 术语中的硬链接或符号链接）。GFS 在逻辑上将其命名空间表示为一个查找表，该表将完整路径名映射到元数据。通过前缀压缩，该表可以高效地在内存中表示。命名空间树中的每个节点（无论是绝对文件名还是绝对目录名）都有一个关联的读写锁。\n每个主操作都会在运行前获取一组锁。通常情况下，如果涉及 /d1/d2/.../dn/leaf，它将获得目录名 /d1、/d1/d2、\u0026hellip;、/d1/d2/.../dn 的读锁，以及完整路径名 /d1/d2/.../dn/leaf 的读锁或写锁。请注意，根据操作的不同，leaf 可以是文件或目录。\n现在，我们将说明这种锁定机制如何防止 /home/user/foo 文件在 /home/user 被快照到 /save/user时被创建。快照操作会获取/home 和 /save 上的读锁，以及 /home/user 和 /save/user 上的写锁。文件创建会获取/home 和 /home/user 上的读锁，以及 /home/user/foo 上的写锁。这两个操作将被正确序列化，因为它们试图获取 /home/user 上的冲突锁。文件创建不需要对父级目录加写锁，因为没有 \u0026ldquo;目录 \u0026ldquo;或类似于 inode 的数据结构需要防止修改。对名称的读取锁足以保护父目录不被删除。\n该锁机制的一个优点是它允许在同一目录中同时进行并发的修改。例如，可以在同一目录中同时执行多个文件创建操作：每个操作都会对目录名称获取读锁，并对文件名称获取写锁。对目录名称的读锁足以防止目录被删除、重命名或快照。而对文件名称的写锁则能序列化（排队）防止两次创建同名文件的尝试。\n由于命名空间可能有很多节点，因此读写锁对象的分配比较懒惰，一旦不使用就会被删除。此外，为防止死锁，获取锁的总顺序是一致的：首先按命名空间树中的层级排序，然后在同一层级内按字典序排序。\n4.2 副本放置 一个 GFS 集群在多个层面上高度分布化。它通常拥有数百个分布在多个机架上的数据块服务器。这些数据块服务器又可能被来自同一机架或不同机架的数百个客户端访问。位于不同机架的两台机器之间的通信可能需要通过一个或多个网络交换机。此外，进入或离开某个机架的带宽可能小于该机架内所有机器的总带宽。多层级的分布化为数据分布带来了独特的挑战，涉及到可扩展性、可靠性和可用性的需求。\n分块副本放置策略有两个目的：最大化数据的可靠性和可用性，以及最大化网络带宽的利用。为此，仅将副本分布在不同机器上是不够的，这样只能防止磁盘或机器故障并充分利用每台机器的网络带宽。我们还必须将块副本分布在不同的机架上。这可以确保即使整个机架发生故障或下线（例如，由于共享资源故障，如网络交换机或电路问题），块的一些副本仍能存活并保持可用性。这也意味着某个块的流量，尤其是读操作，可以利用多个机架的总带宽。然而，写操作的流量需要通过多个机架，这是我们愿意接受的权衡。\n4.3 创建、再复制、再平衡 数据块副本的创建有三个原因：块创建、重新复制和再平衡。\n当主服务器创建一个数据块时，它会选择放置初始空副本的位置，并考虑几个因素：(1) 我们希望将新副本放置在磁盘利用率低于平均水平的块服务器上。随着时间推移，这将使各块服务器的磁盘利用率趋于平衡。(2) 我们希望限制每个块服务器上“最近”创建的副本数量。虽然创建本身成本低，但它能可靠地预测即将到来的大量写入流量，因为数据块是在写入需求时创建的，并且在我们的“一次追加-多次读取”工作负载中，一旦完全写入，它们通常会变成几乎只读。(3) 如上所述，我们希望将数据块的副本分散到不同的机架上。\n主服务器会在可用副本数量低于用户指定目标时立即重新复制数据块。这可能由于多种原因发生：数据块服务器变得不可用、报告其副本可能已损坏、某个磁盘因错误被禁用，或复制目标增加。每个需要重新复制的数据块会根据多个因素进行优先级排序。其中一个因素是它距离复制目标的远近。例如，我们会优先处理失去两个副本的数据块，而不是仅失去一个副本的数据块。此外，我们更倾向于优先重新复制活动文件的数据块，而不是属于最近删除文件的数据块（见第 4.4 节）。最后，为了最小化故障对正在运行的应用程序的影响，我们会提高任何阻塞客户端进展的数据块的优先级。\n主服务器会选择优先级最高的数据块，并通过指示某个数据块服务器直接从现有有效副本复制数据块来“克隆”它。新副本的放置目标与创建时类似：平衡磁盘空间利用率、限制任何单个数据块服务器上的活动克隆操作，以及在机架间分散副本。为了防止克隆流量压倒客户端流量，主服务器限制了集群和每个数据块服务器上的活动克隆操作数量。此外，每个数据块服务器通过限制对源数据块服务器的读取请求，来控制每个克隆操作所使用的带宽。\n最后，主服务器会定期重新平衡副本：它会检查当前的副本分布，并移动副本以实现更好的磁盘空间和负载平衡。在这个过程中，主服务器逐步填充新的数据块服务器，而不是立即用新数据块和随之而来的大量写入流量淹没它。新副本的放置标准与上述讨论的相似。此外，主服务器还必须选择移除哪个现有副本。一般来说，它更倾向于移除那些在磁盘空间低于平均水平的数据块服务器上的副本，以便平衡磁盘空间的使用。\n4.4 垃圾回收 删除文件后，GFS 不会立即回收可用的物理存储空间。它只会在文件和块级的定期垃圾回收过程中懒惰地回收。我们发现，这种方法让系统变得更简单、更可靠。\n4.4.1 机制 当应用程序删除一个文件时，主服务器会立即记录删除操作，就像其他更改一样。然而，主服务器并不会立即回收资源，而是将文件重命名为一个包含删除时间戳的隐藏名称。在主服务器定期扫描文件系统命名空间时，它会移除任何存在超过三天（该时间间隔是可配置的） 的隐藏文件。在此之前，该文件仍可以通过新的特殊名称进行读取，并且可以通过重命名恢复为正常文件。当隐藏文件从命名空间中移除时，其内存中的元数据会被擦除，这有效地切断了与所有数据块的链接。\n在对数据块命名空间进行类似的定期扫描时，主服务器会识别孤立的数据块（即那些无法从任何文件访问的数据块），并擦除这些数据块的元数据。在与主服务器定期交换的心跳消息中，每个数据块服务器会报告它所拥有的一部分数据块，而主服务器则回复所有不再存在于其元数据中的数据块的身份。数据块服务器可以自由地删除这些孤立数据块的副本。\n4.4.2 讨论 尽管分布式垃圾回收在编程语言中是一个难题，需要复杂的解决方案，但在我们的情况下却相对简单。我们可以轻松识别所有对数据块的引用：它们在由主服务器独占维护的文件到数据块的映射中。此外，我们也可以轻松识别所有的数据块副本：它们是每个数据块服务器上指定目录下的Linux文件。任何不被主服务器知晓的副本都可以视为“垃圾”。\n这种垃圾回收的方法在存储回收方面相比于急切删除具有几个优势。首先，在组件故障常见的大规模分布式系统中，它简单且可靠。数据块的创建可能在某些数据块服务器上成功，但在其他服务器上失败，导致主服务器不知道存在的副本。副本删除消息可能会丢失，主服务器需要记住在故障（包括自身和数据块服务器的故障）后重新发送这些消息。垃圾回收提供了一种统一且可靠的方式来清理任何不被认为有用的副本。其次，它将存储回收与主服务器的常规后台活动（如命名空间的定期扫描和与数据块服务器的握手）合并。因此，回收操作是在批处理过程中进行的，成本被摊销。此外，它只在主服务器相对空闲时进行，从而使主服务器能够更迅速地响应需要及时关注的客户端请求。第三，回收存储的延迟提供了一个安全网，防止意外和不可逆的删除。\n根据我们的经验，主要缺点是延迟有时会妨碍用户在存储空间紧张时对使用情况进行微调。反复创建和删除临时文件的应用程序可能无法立即重新使用存储空间。为了解决这些问题，如果删除的文件被再次明确删除，我们就会加快存储空间的回收。我们还允许用户对命名空间的不同部分应用不同的复制和回收策略。例如，用户可以指定某些目录树中的所有文件块都不进行复制存储，任何被删除的文件都会立即从文件系统状态中不可撤销地移除。\n4.5 过时副本检测 如果一个分块服务器发生故障，并在宕机期间错过了对分块的变更，那么分块副本就可能成为过期副本。对于每个数据块，主服务器都会维护一个数据块版本号，以区分最新和过时的副本。\n每当主服务器为某个数据块授予新的租约时，它会增加该数据块的版本号，并通知最新的副本。主服务器和这些副本都会在其持久状态中记录新的版本号。这一过程发生在任何客户端被通知之前，因此在客户端开始写入数据块之前。如果某个副本当前不可用，则该副本的版本号将不会被提升。当该数据块服务器重新启动并报告其数据块及其相关版本号时，主服务器将检测到该数据块服务器拥有一个过时的副本。如果主服务器看到某个版本号高于其记录中的版本号，它会假设在授予租约时发生了故障，因此会将更高的版本视为最新版本。\n主服务器在其定期的垃圾回收过程中会移除过时的副本。在此之前，主服务器在回复客户端关于数据块信息的请求时，实际上会认为过时的副本根本不存在。作为另一种保护措施，主服务器在告知客户端哪个数据块服务器持有某个数据块的租约或在指示某个数据块服务器从另一数据块服务器读取数据块进行克隆操作时，会包含数据块的版本号。客户端或数据块服务器在执行操作时会验证版本号，以确保始终访问最新的数据。\n5. 容错与诊断 我们在设计系统时面临的最大挑战之一就是处理频繁的组件故障。组件的质量和数量使得这些问题变得更加普遍，而不是偶尔出现：我们不能完全信任机器，也不能完全信任磁盘。组件故障可能导致系统不可用，或更糟糕的是，数据损坏。我们讨论如何应对这些挑战，以及我们在系统中内置的工具，用于在问题不可避免地发生时对其进行诊断。\n5.1 高度可用性 5.1.1 快速恢复 无论主服务器和分块服务器是如何终止的，它们都能在数秒内恢复状态并启动。事实上，我们并不区分正常终止和非正常终止；服务器通常只需杀死进程即可关闭。客户端和其他服务器在未处理请求超时、重新连接到重新启动的服务器并重试时，都会经历一个小插曲。第 6.2.2 节报告了观察到的启动时间。\n5.1.2 分块复制 如前所述，每个数据块会在不同机架的多个块服务器上进行复制。用户可以为文件命名空间的不同部分指定不同的复制级别，默认值为三。主服务器根据需要克隆现有副本，以保持每个数据块的完全复制，尤其是在块服务器离线或通过校验和验证检测到副本损坏时（参见第5.2节）。虽然复制技术一直表现良好，但我们正在探索其他形式的跨服务器冗余，如奇偶校验或纠删码，以满足日益增长的只读存储需求。我们预计在我们这种松耦合的系统中实施这些更复杂的冗余方案既具有挑战性又是可管理的，因为我们的流量主要是追加和读取，而不是小规模随机写入。\n主服务器的状态被复制以确保可靠性。其操作日志和检查点会在多个机器上进行复制。只有当状态的日志记录已在本地及所有主服务器副本上刷新到磁盘后，状态的变更才被视为已提交。为了简化管理，只有一个主进程负责所有变更操作以及如垃圾回收等内部系统活动。当主服务器发生故障时，它几乎可以立即重新启动。如果其所在的机器或磁盘故障，GFS之外的监控基础设施会在其他地方启动一个新的主进程，并使用复制的操作日志。客户端只使用主服务器的规范名称（例如 gfs-test），这是一个可以在主服务器迁移到另一台机器时更改的DNS别名。\n此外，“影子”主服务器在基本主服务器宕机时提供只读访问文件系统。它们被称为影子，而非镜像，因为它们可能会稍微滞后于主服务器，通常是几分之一秒。影子主服务器提高了对于未被积极修改的文件的读取可用性，或者对于不介意稍微陈旧结果的应用程序而言，增强了可用性。实际上，由于文件内容是从数据块服务器读取的，应用程序并不会观察到陈旧的文件内容。短时间内可能出现陈旧的，是文件元数据，比如目录内容或访问控制信息。\n为了保持信息更新，影子主服务器读取正在增长的操作日志的副本，并以与主服务器完全相同的顺序将更改应用到其数据结构中。像主服务器一样，它在启动时（以及之后不频繁地）轮询块服务器以定位块副本，并与它们交换频繁的握手消息以监控其状态。影子主服务器仅依赖主服务器提供的副本位置更新，这些更新源于主服务器对副本的创建和删除决策。\n5.2 数据完整性 每个块服务器使用校验和来检测存储数据的损坏。考虑到GFS集群通常有数千个磁盘分布在数百台机器上，它定期会经历磁盘故障，这会导致读写路径上的数据损坏或丢失（见第7节了解一个原因）。我们可以通过其他块副本来恢复损坏的数据，但通过比较块服务器之间的副本来检测损坏是不切实际的。此外，差异副本可能是合法的：GFS变更的语义，特别是之前讨论的原子记录追加，并不保证副本完全相同。因此，每个块服务器必须通过维护校验和独立验证其自身副本的完整性。\n一个数据块被分成 64 KB 的块。每个块都有相应的 32 位校验和。与其他元数据一样，校验和也保存在内存中，并与日志一起持久存储，与用户数据分开。\n对于读取，在向请求者（无论是客户端还是其他分块服务器）返回任何数据之前，分块服务器会验证与读取范围重叠的数据块的校验和。因此，数据块服务器不会将损坏传播给其他机器。如果数据块与记录的校验和不匹配，分块服务器会向请求者返回错误信息，并向主服务器报告不匹配情况。作为回应，请求者将从其他副本中读取，而主服务器将从另一个副本中克隆该块。在有效的新副本就位后，主服务器会指示报告不匹配的分块服务器删除其副本。\n校验和对读取性能影响不大，原因有几个。由于我们的大多数读取至少跨越几个块，因此我们只需要读取和校验相对少量的额外数据以进行验证。GFS 客户端代码通过尝试在校验和块边界处对齐读取来进一步减少这种开销。此外，分块服务器上校验和的查找和比较无需任何 I/O，校验和计算通常可以与 I/O 重叠。\n校验和计算针对附加到块末尾的写入（相对于覆盖现有数据的写入）进行了大量优化，因为它们在我们的工作负载中占主导地位。我们只需增量更新最后一个部分校验和块的校验和，并为附加所填充的全新校验和块计算新的校验和。即使最后一个部分校验和区块已经损坏，并且我们现在没有检测到，新的校验和值也不会与存储的数据匹配，而且在下一次读取该区块时，也会像往常一样检测到损坏。\n相反，如果写入的内容覆盖了数据块的现有范围，我们就必须先读取并校验被覆盖范围的第一个和最后一个数据块，然后执行写入操作，最后计算并记录新的校验和。如果我们在部分覆盖首尾区块之前不对其进行校验，新的校验和可能会掩盖未被覆盖区域中存在的损坏。\n在空闲期间，数据块服务器可以扫描并验证非活动数据块的内容。这样，我们就能检测到很少被读取的数据块的损坏。一旦检测到损坏，主控程序就可以创建一个新的未损坏副本，并删除损坏的副本。这样就能防止不活动但已损坏的数据块副本欺骗主服务器，让它以为自己有足够多的数据块有效副本。\n5.4 诊断工具 广泛而细致的诊断日志在问题隔离、调试和性能分析方面发挥了不可估量的作用，而其成本却非常低。没有日志的话，很难理解机器之间瞬时且不可重复的交互。GFS 服务器生成诊断日志，记录许多重要事件（例如分块服务器的启动和关闭）以及所有的 RPC 请求和回复。这些诊断日志可以随意删除，而不会影响系统的正确性。然而，我们尽量在空间允许的情况下保留这些日志。\n除了正在读取或写入的文件数据外，RPC 日志包括在线路上发送的确切请求和响应。通过匹配请求和回复，并整理不同机器上的 RPC 记录，我们可以重建整个交互历史，从而诊断问题。日志还可作为负载测试和性能分析的跟踪记录。\n日志记录对性能的影响极小（并且其好处远远超过影响），因为这些日志是以顺序和异步方式写入的。最近的事件还保存在内存中，可用于持续的在线监控。\n6. 测量 在本节中，我们将介绍一些微型基准测试，以说明 GFS 架构和实施中固有的瓶颈，以及谷歌实际使用的集群中的一些数据。\n6.1 微基准测试 我们在由一个主服务器、两个主服务器副本、16 个块服务器和 16 个客户端组成的 GFS 集群上测量了性能。请注意，这种配置是为了便于测试而设置的。典型的集群有数百个块服务器和数百个客户端。\n所有机器都配置了双 1.4 GHz PIII 处理器、2 GB 内存、两个 80 GB 5400 rpm 磁盘，以及连接到 HP 2524 交换机的 100 Mbps 全双工以太网。所有 19 台 GFS 服务器连接到一台交换机，所有 16 台客户机连接到另一台交换机。两台交换机通过 1 Gbps 链路连接。\n6.1.1 读 N 个客户端同时从文件系统读取数据。每个客户端从 320 GB 的文件集中随机读取 4 MB 区域。此过程重复 256 次，因此每个客户端最终读取 1 GB 的数据。所有块服务器加起来只有 32 GB 的内存，因此我们预计 Linux 缓冲区缓存的命中率最多为 10%。我们的结果应该接近冷缓存结果。\n图 3(a) 显示了 N 个客户端的总读取速率及其理论极限。当两个交换机之间的 1 Gbps 链路达到饱和时，极限值达到 125 MB/s，或当每个客户端的 100 Mbps 网络接口达到饱和时，极限值达到 12.5 MB/s。当只有一个客户端在读取数据时，观察到的读取速率为 10 MB/s，即每个客户端上限的 80%。16 个读取器的总读取速率达到 94 MB/s，约为 125 MB/s 链路限值的 75%，即每个客户端 6 MB/s。效率从 80% 下降到 75%，是因为随着读取器数量的增加，多个读取器同时从同一个分块服务器读取数据的概率也在增加。\n6.1.2 写 N 个客户端同时向 N 个不同的文件写入数据。每个客户端通过一系列 1 MB 的写入将 1 GB 的数据写入新文件。图 3(b) 显示了总写入速率及其理论极限。极限稳定在 67 MB/s，因为我们需要将每个字节写入 16 个块服务器中的 3 个，每个块服务器的输入连接为 12.5 MB/s。\n一个客户端的写入速率为 6.3 MB/s，约为极限的一半。造成这种情况的主要原因是我们的网络栈。它与我们用于将数据推送到块副本的流水线方案交互效果不佳。将数据从一个副本传播到另一个副本的延迟会降低整体写入速率。16 个客户端的总写入速率达到 35 MB/s（或每个客户端 2.2 MB/s），约为理论极限的一半。与读取的情况一样，随着客户端数量的增加，多个客户端同时写入同一个块服务器的可能性变得更大。此外，由于每次写入涉及三个不同的副本，因此 16 个写入者比 16 个读取者更容易发生冲突。\n写入速度比我们预期的要慢。实际上，这并不是一个大问题，因为即使它增加了单个客户端看到的延迟，也不会显著影响系统向大量客户端提供的总写入带宽。\n6.1.3 记录追加 图 3(c) 显示了记录附加性能。N 个客户端同时附加到单个文件。性能受存储文件最后一块的块服务器的网络带宽限制，与客户端数量无关。对于一个客户端，它从 6.0 MB/s 开始，对于 16 个客户端，它下降到 4.8 MB/s，这主要是由于拥塞和不同客户端看到的网络传输速率差异。\n我们的应用通常会同时生成多个这样的文件。换句话说，N 个客户端会同时附加数据到 M 个共享文件中，N 和 M 的数量可以达到数十甚至上百。因此，在实际应用中，分块服务器的网络拥堵问题并不显著，因为当一个文件的分块服务器繁忙时，客户端仍然可以继续在其他文件上写入数据。\n6.2 真实世界集群 我们现在研究 Google 内部使用的两个集群，它们代表了其他几个类似的集群。集群 A 经常被一百多名工程师用于研究和开发。一个典型的任务由人类用户发起，运行时间长达几个小时。它读取几 MB 到几 TB 的数据，转换或分析数据，并将结果写回集群。集群 B 主要用于生产数据处理。任务持续时间更长，并且持续生成和处理多 TB 数据集，仅偶尔需要人工干预。在这两种情况下，单个“任务”都由多台机器上的许多进程组成，这些进程同时读取和写入许多文件。\n6.2.1 存储 如表2中的前五个条目所示，两个集群都有数百个分块服务器，支持许多 TB 的磁盘空间，而且都相当满，但不是完全满。\u0026ldquo;已用空间 \u0026ldquo;包括所有的分块复制。几乎所有文件都复制了三次。因此，集群分别存储了 18 TB 和 52 TB 的文件数据。\n这两个集群的文件数量相似，但 B 集群的死文件比例更大，即已被删除或被新版本取代但其存储尚未被回收的文件。此外，由于 B 的文件往往较大，因此它的块数也更多。\n6.2.2 元数据 分块服务器总共存储了数十 GB 的元数据，其中大部分是 64 KB 用户数据块的校验和。分块服务器中保存的唯一其他元数据是第 4.5 节中讨论的块版本号。\n主服务器上保存的元数据要小得多，只有几十 MB，平均每个文件大约 100 字节。这符合我们的假设，即主服务器内存的大小实际上不会限制系统的容量。大多数文件元数据是以前缀压缩形式存储的文件名。其他元数据包括文件所有权和权限、从文件到块的映射以及每个块的当前版本。此外，对于每个块，我们存储当前副本位置和引用计数以实现写时复制。\n每个单独的服务器（包括块服务器和主服务器）只有 50 到 100 MB 的元数据。因此恢复速度很快：在服务器能够回答查询之前，只需几秒钟就可以从磁盘读取这些元数据。但是，主服务器在一段时间内会有些不顺畅（通常为 30 到 60 秒），直到它从所有块服务器获取块位置信息。\n6.2.3 读写速率 表 3 显示了不同时间段的读写速率。在进行这些测量时，两个集群都已运行了一周左右。（最近，为了升级到新版 GFS，集群被重新启动）。\n自重启以来，平均写入速率不到 30 MB/s。当我们进行这些测量时，B 正处于写入活动的爆发期，产生了大约每秒 100 MB 的数据，由于写入会传播到三个副本，因此产生了每秒 300 MB 的网络负载。\n读取速率远高于写入速率。正如我们所假设的，总工作负载由更多的读取而不是写入组成。两个集群都处于大量读取活动之中。特别是，A 在前一周一直保持着 580 MB/s 的读取速率。其网络配置可以支持 750 MB/s，因此它正在高效地利用其资源。集群 B 可以支持 1300 MB/s 的峰值读取速率，但其应用程序仅使用了 380 MB/s。\n6.2.4 主服务器负载 表 3 还显示，发送给主服务器的操作速率约为每秒 200 到 500 次操作。主服务器可以轻松跟上这个速率，因此不会成为这些工作负载的瓶颈。 在 GFS 的早期版本中，主服务器偶尔会成为某些工作负载的瓶颈。它大部分时间都在按顺序扫描大型目录（其中包含数十万个文件）以查找特定文件。此后，我们更改了主服务器数据结构，以允许通过命名空间进行高效的二分搜索。它现在可以轻松支持每秒数千次文件访问。如有必要，我们可以通过在命名空间数据结构前面放置名称查找缓存来进一步加快速度。\n6.2.5 恢复时间 在块服务器发生故障后，某些块将变得复制不充分，必须进行克隆才能恢复其复制级别。恢复所有这些块所需的时间取决于资源量。在一次实验中，我们关闭了集群 B 中的单个块服务器。该块服务器有大约 15000 个块，包含 600 GB 的数据。为了限制对正在运行的应用程序的影响并为调度决策提供余地，我们的默认参数将此集群限制为 91 个并发克隆（块服务器数量的 40%），其中每个克隆操作最多允许消耗 6.25 MB/s（50 Mbps）。所有块在 23.2 分钟内恢复，有效复制速率为 440 MB/s。\n在另一个实验中，我们关闭了两个分块服务器，每个服务器大约有 16000 个数据块和 660 GB 的数据。此双重故障导致 266 个数据块仅剩一个副本。这 266 个数据块被优先克隆，并在 2 分钟内全部恢复到至少 2 倍的副本数量，从而使集群恢复到可以容忍另一个分块服务器故障而不会导致数据丢失的状态。\n6.3 工作负载细分 在本节中，我们将详细分析两个 GFS 集群的工作负载，它们与第 6.2 节中的集群类似但不完全相同。集群 X 用于研发，而集群 Y 用于生产数据处理。\n6.3.1 方法与注意事项 这些结果仅包括客户端发起的请求，因此它们反映了我们的应用程序为整个文件系统生成的工作负载。它们不包括执行客户端请求的服务器间请求或内部后台活动，例如转发写入或重新平衡。\n关于 I/O 操作的统计数据基于从 GFS 服务器记录的实际 RPC 请求中通过启发式方法重建的信息。例如，GFS 客户端代码可能会将一次读取分解成多个 RPC，以提高并行性，从中我们可以推断出原始读取。由于我们的访问模式具有高度的固定化特征，因此预期任何误差都微乎其微。应用程序进行显式日志记录可能会提供稍微更准确的数据，但在实际操作中，要重新编译并重启数千个正在运行的客户端并不现实，同时从这么多机器上收集结果也十分繁琐。\n需要注意的是，不应过度泛化我们的工作负载。由于 Google 完全控制 GFS 及其应用程序，因此这些应用程序往往针对 GFS 进行了优化，反过来，GFS 也是为这些应用程序量身设计的。这种相互影响在通用应用程序和文件系统之间也可能存在，但在我们这种情况下，这种影响可能更加明显。\n6.3.2 分块服务器工作负载 表 4 显示了按大小分列的操作分布情况。读取大小呈现双峰分布。小规模读取（64 KB 以下）来自查找密集型客户端，它们在庞大的文件中查找小块数据。大读取（超过 512 KB）来自对整个文件的长时间连续读取。\n在集群 Y 中，大量读取操作没有返回任何数据。我们的应用程序（尤其是生产系统中的应用程序）经常使用文件作为生产者-消费者队列。生产者同时将数据附加到文件，而消费者则读取文件末尾。偶尔，当消费者超过生产者时，不会返回任何数据。集群 X 出现这种情况的频率较低，因为它通常用于短期数据分析任务，而不是长期分布式应用程序。\n写入大小也呈现双峰分布。大写入量（超过 256 KB）通常是写入器内部大量缓冲造成的。写入器缓冲数据较少、检查点或同步频率较高，或仅生成较少数据，则导致写入量较小（64 KB 以下）。\n对于记录追加操作，集群 Y 的大记录追加操作比例比集群 X 高得多，因为我们的生产系统使用集群 Y，并且对 GFS 的优化更加积极。\n表 5 显示了各种大小的操作中传输的数据总量。对于所有类型的操作，较大的操作（超过 256 KB）通常占传输的字节数的大部分。由于随机寻道工作负载，较小的读取（低于 64 KB）确实传输了一小部分但相当可观的读取数据。\n6.3.3 追加与写入 记录追加操作在我们的生产系统中被大量使用。在集群 X 中，按传输字节计算，写操作与记录追加的比率为 108:1，按操作次数计算为 8:1。而在生产系统使用的集群 Y 中，这些比率分别为 3.7:1 和 2.5:1。此外，这些比率表明在两个集群中记录追加操作往往比写操作更大。然而，对于集群 X，在测量期间记录追加的总体使用率相对较低，因此结果可能会因一两个特定选择了特定缓冲区大小的应用程序而有所偏差。\n不出所料，我们的数据变更工作量主要是追加而不是覆盖。我们测量了主副本上被覆盖的数据量。这近似于客户端故意覆盖以前写入的数据而不是追加新数据的情况。对于集群 X，覆盖量占变异字节的 0.0001%，占变异操作的 0.0003%。对于集群 Y，这两个比例都是 0.05%。虽然这个比例很小，但仍然高于我们的预期。事实证明，这些覆盖操作大多来自客户端因错误或超时而进行的重试。它们本身并不是工作量的一部分，而是重试机制的结果。\n6.3.4 主服务器工作负载 表 6 显示了向主服务器发出的请求类型的明细。大多数请求询问数据块位置（FindLocation）以进行读取，以及租约持有者信息（FindLeaseLocker）以进行数据变更。\n集群 X 和 Y 的删除（Delete）请求数量存在显著差异，因为集群 Y 存储的生产数据集会定期重新生成并替换为新版本。部分差异进一步隐藏在打开请求的差异中，因为文件的旧版本可能会通过从头开始打开进行写入（Unix 打开术语中的模式“w”）而被隐式删除。\nFindMatchingFiles 是一种支持 “ls” 和类似文件系统操作的模式匹配请求。与主服务器的其他请求不同，它可能需要处理命名空间的很大一部分，因此开销可能较大。集群 Y 上这种请求更为常见，因为自动化数据处理任务通常会检查文件系统的部分内容以了解全局应用状态。相比之下，集群 X 的应用更受用户控制，通常提前知道所需文件的名称。\n7. 经历 在建立和部署GFS 的过程中，我们遇到了各种各样的问题，有些是操作问题，有些是技术问题。\n最初，GFS 被设计为我们生产系统的后端文件系统。随着时间的推移，其用途逐渐扩展到研究和开发任务。最初它几乎不支持权限和配额之类的功能，但现在包含了这些功能的基本形式。虽然生产系统管理有序且受控，但用户有时并非如此。需要更多的基础设施来防止用户相互干扰。\n我们遇到的最大问题与磁盘和 Linux 有关。我们的许多磁盘都向 Linux 驱动程序声称它们支持一系列 IDE 协议版本，但实际上它们只对较新的版本做出可靠响应。由于协议版本非常相似，这些驱动器大部分情况下都能正常工作，但偶尔不匹配会导致驱动器和内核对驱动器状态产生分歧。这会由于内核中的问题而悄无声息地损坏数据。这个问题促使我们使用校验和来检测数据损坏，同时我们修改了内核来处理这些协议不匹配。\n之前，我们在使用 Linux 2.2 内核时遇到了一些问题，这是由于 fsync() 的成本所致。其成本与文件大小成正比，而不是与修改部分的大小成正比。这对于我们的大型操作日志来说是一个问题，尤其是在我们实施检查点之前。我们曾一度通过使用同步写入来解决这个问题，并最终迁移到 Linux 2.4。\n另一个 Linux 问题是单一的读写锁。在地址空间内的任一线程从磁盘调入页面时（读锁）或在调用 mmap() 时修改地址空间（写锁），都必须持有此锁。在轻负载下，我们的系统出现了瞬时超时现象，并且我们花了很多精力寻找资源瓶颈或偶发的硬件故障。最终发现，该单一锁阻止了主网络线程将新数据映射到内存中，因为磁盘线程正在调入先前映射的数据。由于我们的瓶颈主要在网络接口，而非内存复制带宽，我们通过用 pread()替换 mmap() 解决了这个问题，代价是增加了一次额外的数据复制。\n尽管偶尔会出现问题，但 Linux 代码的可用性一次又一次地帮助我们探索和理解系统行为。在适当的时候，我们会对内核进行改进，并与开源社区分享这些变化。\n8. 相关工作 与其他大型分布式文件系统（如 AFS [5]）类似，GFS 提供了位置无关的命名空间，使得数据可以为负载平衡或容错而透明地移动。与 AFS 不同的是，GFS 将文件的数据分布在多个存储服务器上，这种方式更类似于 xFS [1] 和 Swift [3]，以实现聚合性能并提高容错能力。\n由于磁盘相对便宜，且复制比更复杂的 RAID [9] 方法更简单，GFS 目前仅使用复制来实现冗余，因此比 xFS 或 Swift 消耗更多的原始存储。\n与 AFS、xFS、Frangipani [12] 和 Intermezzo [6] 等系统相比，GFS 不提供文件系统接口下的任何缓存。我们的目标工作负载在单个应用程序运行中几乎没有重用性，因为它们要么流经大型数据集，要么随机在其中查找并每次读取少量数据。\n一些分布式文件系统，如 Frangipani、xFS、Minnesota 的 GFS[11] 和 GPFS [10] 移除了集中式服务器，并依靠分布式算法来实现一致性和管理。我们选择集中式方法是为了简化设计、提高可靠性并获得灵活性。特别是，集中式主服务器可以更轻松地实现复杂的块放置和复制策略，因为主服务器已经拥有大部分相关信息并控制其更改方式。我们通过保持主服务器状态较小并在其他机器上完全复制来解决容错问题。我们的影子主服务器机制目前提供可扩展性和高可用性（对于读取）。通过附加到预写日志，可以持久保存对主服务器状态的更新。因此，我们可以采用 Harp [7] 中的主副本方案，以提供比我们当前方案具有更强一致性保证的高可用性。\n我们正在解决与 Lustre [8] 类似的问题，即为大量客户提供总体性能。但是，我们通过专注于应用程序的需求而不是构建符合 POSIX 标准的文件系统，大大简化了这个问题。此外，GFS 假设存在大量不可靠的组件，因此容错是我们设计的核心。\nGFS 最接近 NASD 架构 [4]。虽然 NASD 架构基于网络连接的磁盘驱动器，但 GFS 使用商用机器作为分块服务器，这与 NASD 原型类似。与 NASD 工作不同的是，GFS 的分块服务器使用懒惰分配的固定大小块，而不是可变长度对象。此外，GFS 实现了生产环境中所需的负载均衡、复制和恢复等功能。\n与 Minnesota 的 GFS 和 NASD 不同，我们并不寻求改变存储设备的模型。我们专注于利用现有的商品组件满足复杂分布式系统的日常数据处理需求。\n由原子记录附加功能启用的生产者-消费者队列解决了与 River [2] 中的分布式队列类似的问题。虽然 River 使用分布在机器上的基于内存的队列和谨慎的数据流控制，但 GFS 使用可由许多生产者同时附加的持久文件。River 模型支持 m 对 n 分布式队列，但缺乏持久存储带来的容错能力，而 GFS 仅有效地支持 m 对 1 队列。多个消费者可以读取同一个文件，但他们必须协调以划分传入的负载。\n9. 结论 Google 文件系统展示了在商用硬件上支持大规模数据处理工作负载所必需的品质。虽然一些设计决策特定于我们的独特环境，但许多设计决策可能适用于具有类似规模和成本意识的数据处理任务。\n我们首先根据当前和预期的应用程序工作负载和技术环境重新审视了传统的文件系统假设。我们的观察结果在设计领域中得出了截然不同的观点。我们将组件故障视为常态而非例外，针对大多数情况下追加（可能并发）然后读取（通常顺序）的大型文件进行优化，并扩展和放宽标准文件系统接口以改进整个系统。\n我们的系统通过持续监控、复制关键数据以及快速自动恢复来提供容错能力。块复制使我们能够容忍块服务器故障。这些故障的频率促使我们开发了一种新颖的在线修复机制，该机制定期透明地修复损坏并尽快补偿丢失的副本。此外，我们使用校验和来检测磁盘或 IDE 子系统级别的数据损坏，考虑到系统中的磁盘数量，这种情况变得非常常见。\n我们的设计为执行各种任务的众多并发读取器和写入器提供了很高的整体吞吐量。我们通过将文件系统控制（通过主服务器）与数据传输（直接在块服务器和客户端之间传递）分开来实现这一点。通过较大的块大小和块租借（将数据变更的权限委托给主副本），主服务器对常见操作的参与被最小化。这使得简单、集中的主服务器成为可能，而不会成为瓶颈。我们相信，我们网络栈的改进将解除当前单个客户端看到的写入吞吐量的限制。\nGFS 成功满足了我们的存储需求，在 Google 内部被广泛用作研发和生产数据处理的存储平台。它是我们能够继续创新和攻克整个网络规模问题的重要工具。\n参考文献 [1] Thomas Anderson, Michael Dahlin, Jeanna Neefe, David Patterson, Drew Roselli, and Randolph Wang. Serverless network file systems. In Proceedings of the 15th ACM Symposium on Operating System Principles, pages 109–126, Copper Mountain Resort, Colorado, December 1995.\n[2] Remzi H. Arpaci-Dusseau, Eric Anderson, Noah Treuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River: Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS \u0026lsquo;99), pages 10–22, Atlanta, Georgia, May 1999.\n[3] Luis-Felipe Cabrera and Darrell D. E. Long. Swift: Using distributed diskstriping to provide high I/O data rates. Computer Systems, 4(4):405–436, 1991.\n[4] Garth A. Gibson, David F. Nagle, Khalil Amiri, Jeff Butler, Fay W. Chang, Howard Gobioff, Charles Hardin, ErikRiedel, David Rochberg, and Jim Zelenka. A cost-effective, high-bandwidth storage architecture. In Proceedings of the 8th Architectural Support for Programming Languages and Operating Systems, pages 92–103, San Jose, California, October 1998.\n[5] John Howard, Michael Kazar, Sherri Menees, David Nichols, Mahadev Satyanarayanan, Robert Sidebotham, and Michael West. Scale and performance in a distributed file system. ACM Transactions on Computer Systems, 6(1):51–81, February 1988.\n[6] InterMezzo. https://www.inter-mezzo.org, 2003.\n[7] Barbara Liskov, Sanjay Ghemawat, Robert Gruber, Paul Johnson, Liuba Shrira, and Michael Williams. Replication in the Harp file system. In 13th Symposium on Operating System Principles, pages 226–238, Pacific Grove, CA, October 1991.\n[8] Lustre. http://www.lustreorg, 2003.\n[9] David A. Patterson, Garth A. Gibson, and Randy H. Katz. A case for redundant arrays of inexpensive disks (RAID). In Proceedings of the 1988 ACM SIGMOD International Conference on Management of Data, pages 109–116, Chicago, Illinois, September 1988.\n[10] FrankSchmuckand Roger Haskin. GPFS: A shared-diskfile system for large computing clusters. In Proceedings of the First USENIX Conference on File and Storage Technologies, pages 231–244, Monterey, California, January 2002.\n[11] Steven R. Soltis, Thomas M. Ruwart, and Matthew T. O’Keefe. The Gobal File System. In Proceedings of the Fifth NASA Goddard Space Flight Center Conference on Mass Storage Systems and Technologies, College Park, Maryland, September 1996.\n[12] Chandramohan A. Thekkath, Timothy Mann, and Edward K. Lee. Frangipani: A scalable distributed file system. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 224–237, Saint-Malo, France, October 1997.\n","permalink":"https://fireflyyh.top/posts/distributionsystem/gfs/","summary":"摘要 我们设计并实现了谷歌文件系统，这是一个可扩展的分布式文件系统，适用于大型分布式数据密集型应用。该系统可在廉价的商品硬件上运行，同时提供容错功能，并能为大量客户端提供高聚合性能。\n我们的设计目标与之前的分布式文件系统有许多相同之处，但我们对应用工作负载和技术环境（包括当前和预期环境）的观察结果表明，我们的设计明显偏离了之前的一些文件系统假设。这促使我们重新审视传统的选择，探索完全不同的设计要点。\n文件系统成功地满足了我们的存储需求。它在谷歌内部被广泛部署，作为生成和处理我们的服务所使用的数据以及需要大型数据集的研发工作的存储平台。迄今为止，最大的集群在一千多台机器上的数千个磁盘上提供了数百 TB 的存储空间，并被数百个客户端并发访问。\n在本文中，我们介绍了为支持分布式应用而设计的文件系统接口扩展，讨论了我们设计的许多方面，并报告了微基准测试和实际使用的测量结果。\n1. 引言 我们设计并实施了谷歌文件系统（GFS），以满足谷歌快速增长的数据处理需求。GFS 与以前的分布式文件系统有许多相同的目标，如性能、可扩展性、可靠性和可用性。但是，在设计 GFS 时，我们对当前和预期的应用工作负载和技术环境进行了重要观察，这反映出我们明显偏离了之前的一些文件系统设计假设。我们重新审视了传统的选择，并探索了设计空间中完全不同的点。\n首先，组件故障是常态而非例外。文件系统由数百甚至数千台存储机组成，这些存储机都是用廉价的商品部件制造的，并被数量相当的客户机访问。这些组件的数量和质量几乎可以保证，在任何特定时间都会有一些组件无法正常工作，而且有些组件无法从当前故障中恢复。我们见过应用程序错误、操作系统错误、人为错误以及磁盘、内存、连接器、网络和电源故障造成的问题。因此，持续监控、错误检测、容错和自动恢复必须成为系统的组成部分。\n其次，按照传统的标准，文件是巨大的。多 GB 的文件很常见。每个文件通常包含许多应用对象，如网络文档。当我们经常处理由数十亿个对象组成的多 TB 快速增长的数据集时，即使文件系统可以支持，要管理数十亿个约 KB 大小的文件也很不方便。因此，必须重新审视 I/O 操作和块大小等设计假设和参数。\n第三，大多数文件都是通过添加新数据而不是覆盖现有数据来改变的。文件内的随机写入几乎不存在。文件一旦写入，就只能读取，而且通常只能按顺序读取。各种数据都具有这些特征。有些可能是数据分析程序扫描过的大型存储库。有些可能是运行中的应用程序持续生成的数据流。有些可能是档案数据。有些可能是在一台机器上生成并在另一台机器上处理的中间结果，无论是同时处理还是稍后处理。鉴于巨型文件的这种访问模式，追加成为性能优化和原子性保证的重点，而在客户端缓存数据块则失去了吸引力。\n第四，共同设计应用程序和文件系统 API 可以提高我们的灵活性，从而使整个系统受益。例如，我们放宽了 GFS 的一致性模型，大大简化了文件系统，而不会给应用程序带来沉重负担。我们还引入了原子追加操作，使多个客户端可以同时追加文件，而无需额外的同步。本文稍后将详细讨论这些内容。\n目前，为不同目的部署了多个 GFS 集群。最大的集群有超过 1000 个存储节点，超过 300 TB 的磁盘存储空间，数百个客户端在不同的机器上持续大量访问。\n2. 设计概述 2.1 假设 在设计满足我们需求的文件系统时，我们遵循的假设既是挑战也是机遇。我们在前面提到了一些重要的观察结果，现在详细介绍一下我们的假设。\n该系统由许多经常发生故障的廉价商品组件构成。系统必须不断进行自我监控，日常检测、容忍和及时恢复组件故障。 系统存储的大文件数量不多。我们预计会有几百万个文件，每个文件的大小通常为 100 MB 或更大。多 GB 文件是常见情况，应得到有效管理。我们必须支持小文件，但无需对其进行优化。 工作负载主要包括两种读取：大型流式读取和小型随机读取。在大数据流读取中，单个操作通常读取数百 KB，更常见的是 1 MB 或更多。来自同一客户端的连续操作通常会读取文件的连续区域。小型随机读取通常在某个任意偏移位置读取几个 KB 的数据。注重性能的应用程序通常会对小规模读取进行批处理和排序，以稳定地读取文件，而不是来回读取。 这些工作负载中还有许多向文件追加数据的大型连续写入操作。典型的操作大小与读取类似。文件一旦写入，就很少再修改。支持在文件任意位置进行小规模写入，但不一定要高效。 系统必须有效地实现多个客户端同时追加到同一文件的定义明确的语义。我们的文件通常用作生产者-消费者队列或多路合并。数以百计的生产者（每台机器运行一个）将同时追加到一个文件。同步开销最小的原子性至关重要。文件可能会在稍后被读取，或者消费者可能会同时读取文件。 高持续带宽比低延迟更重要。我们的大多数目标应用都非常重视高速批量处理数据，而很少有应用对单个读取或写入的响应时间有严格要求。 2.2 接口 GFS 提供了一个熟悉的文件系统接口，尽管它没有实现标准的 API（如 POSIX）。文件在目录中按层次组织，并用路径名标识。我们支持创建、删除、打开、关闭、读取和写入文件的常规操作。\n此外，GFS 还有快照和记录追加操作。快照以低成本创建文件或目录树的副本。记录追加允许多个客户端同时向同一个文件追加数据，同时保证每个客户端追加的原子性。它适用于实现多向合并结果和生产者-消费者队列，许多客户端可以同时追加数据而无需额外锁定。我们发现，这些类型的文件在构建大型分布式应用时非常有用。快照追加和记录追加将分别在第 3.4 节和第 3.3 节中进一步讨论。","title":"[论文翻译]The Google File System"},{"content":" 部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。\nexercise8-1 用 read、write、open 和 close 系统调用代替标准库中功能等价的函数，重写第 7 章的 cat 程序，并通过实验比较两个版本的相对执行速度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void filecopy(int ifp, int ofp) { char buf[BUFSIZE]; int n; while ((n = read(ifp, buf, BUFSIZE)) \u0026gt; 0) if (write(ofp, buf, n) != n) error(\u0026#34;cp: write error on file2\u0026#34;); } int main(int argc, char *argv[]) { int fd; char *prog = argv[0]; /* program name for errors */ if (argc == 1) /* no args; copy standard input */ filecopy(STDIN_FILENO, STDOUT_FILENO); else while (--argc \u0026gt; 0) if ((fd = open(*++argv, O_RDONLY, 0)) == -1) { fprintf(stderr, \u0026#34;%s: can\u0026#39;t open %s\\n\u0026#34;, prog, *argv); exit(1); } else { filecopy(fd, STDOUT_FILENO); close(fd); } if (ferror(stdout)) { fprintf(stderr, \u0026#34;%s: error writing stdout\\n\u0026#34;, prog); exit(2); } exit(0); } 运行：\n1 2 3 4 ➜ ch08 git:(main) ✗ ./Exercise8-1 test01.txt test02.txt This is test01.txt Good idea.This is test02.txt Bad idea. exercise8-2 用字段代替显式的按位操作，重写 fopen 和_fillbuf 函数。比较相应代码的长度和执行速度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 struct flags { unsigned int _READ : 1; /* file open for reading */ unsigned int _WRITE : 1; /* file open for writing */ unsigned int _UNBUF : 1; /* file is unbuffered */ unsigned int _EOF : 1; /* EOF has occurred on this file */ unsigned int _ERR : 1; /* error occurred on this file */ }; FILE *fopen(char *name, char *mode) { int fd; FILE *fp; if (*mode != \u0026#39;r\u0026#39; \u0026amp;\u0026amp; *mode != \u0026#39;w\u0026#39; \u0026amp;\u0026amp; *mode != \u0026#39;a\u0026#39;) return NULL; for (fp = _iob; fp \u0026lt; _iob + OPEN_MAX; fp++) if ((flagsempty(fp-\u0026gt;flag) \u0026amp; (_READ | _WRITE)) == 0) break; /* found free slot */ if (fp \u0026gt;= _iob + OPEN_MAX) /* no free slots */ return NULL; if (*mode == \u0026#39;w\u0026#39;) fd = creat(name, PERMS); else if (*mode == \u0026#39;a\u0026#39;) { if ((fd = open(name, O_WRONLY, 0)) == -1) fd = creat(name, PERMS); lseek(fd, 0L, 2); } else fd = open(name, O_RDONLY, 0); if (fd == -1) /* couldn\u0026#39;t access name */ return NULL; fp-\u0026gt;fd = fd; fp-\u0026gt;cnt = 0; fp-\u0026gt;base = NULL; fp-\u0026gt;flag._READ = (*mode == \u0026#39;r\u0026#39;) ? 1 : 0; fp-\u0026gt;flag._WRITE = (*mode == \u0026#39;w\u0026#39;) ? 1 : 0; return fp; } /* _fillbuf: allocate and fill input buffer */ int _fillbuf(FILE *fp) { int bufsize; if ((flagsempty(fp-\u0026gt;flag) \u0026amp; (_READ | _EOF | _ERR)) != _READ) return EOF; bufsize = (flagsempty(fp-\u0026gt;flag) \u0026amp; _UNBUF) ? 1 : BUFSIZ; if (fp-\u0026gt;base == NULL) /* no buffer yet */ if ((fp-\u0026gt;base = (char *)malloc(bufsize)) == NULL) return EOF; /* can\u0026#39;t get buffer */ fp-\u0026gt;ptr = fp-\u0026gt;base; fp-\u0026gt;cnt = read(fp-\u0026gt;fd, fp-\u0026gt;ptr, bufsize); if (--fp-\u0026gt;cnt \u0026lt; 0) { if (fp-\u0026gt;cnt == -1) fp-\u0026gt;flag._EOF = 1; else fp-\u0026gt;flag._ERR = 1; fp-\u0026gt;cnt = 0; return EOF; } return (unsigned char)*fp-\u0026gt;ptr++; } exercise8-3 设计并编写函数_flushbuf、fflush 和 fclose。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 int _flushbuf(int c, FILE *fp) { int num_written, bufsize; unsigned char uc = c; if ((fp-\u0026gt;flag \u0026amp; (_WRITE | _EOF_ERR)) != _WRITE) return EOF; /* 如果尚未分配缓冲区并且不是无缓冲模式，尝试分配一个大小为 BUFSIZ 的缓冲区。 如果分配失败，设置为无缓冲模式；如果成功，初始化缓冲区指针和计数器。 */ if (fp-\u0026gt;base == NULL \u0026amp;\u0026amp; ((fp-\u0026gt;flag \u0026amp; _UNBUF) == 0)) { if ((fp-\u0026gt;base = malloc(BUFSIZ)) == NULL) fp-\u0026gt;flag |= _UNBUF; else { fp-\u0026gt;ptr = fp-\u0026gt;base; fp-\u0026gt;cnt = BUFSIZ - 1; } } /* 如果是无缓冲模式，直接将字符写入文件。 此时将指针和计数器设置为 NULL 和 0。若要写入的是 EOF，则直接返回。 */ if (fp-\u0026gt;flag \u0026amp; _UNBUF) { /* unbuffered write */ fp-\u0026gt;ptr = fp-\u0026gt;base = NULL; fp-\u0026gt;cnt = 0; if (c = EOF) return EOF; num_written = write(fp-\u0026gt;fd, \u0026amp;uc, 1); bufsize = 1; } /* 如果是缓冲模式且要写入的字符不是 EOF，将字符存入缓冲区，然后更新指针。 接着计算当前缓冲区的大小，并将缓冲区内容写入文件。写入后，将指针和计数器重置。 因为没有写入EOF，所以不会打印 */ else { /* buffered write */ if (c != EOF) { *fp-\u0026gt;ptr = uc; fp-\u0026gt;ptr++; } bufsize = (int)(fp-\u0026gt;ptr - fp-\u0026gt;base); num_written = write(fp-\u0026gt;fd, fp-\u0026gt;base, bufsize); fp-\u0026gt;ptr = fp-\u0026gt;base; fp-\u0026gt;cnt = bufsize - 1; } if (num_written = bufsize) return c; else { fp-\u0026gt;flag |= _ERR; return EOF; } } /* 刷新输出缓冲区 */ int fflush(FILE *f) { int retval; // 返回值 int i; retval = 0; if ((f-\u0026gt;flag \u0026amp; _WRITE) == 0) return -1; // 将EOF写入f中，代表文件结束 _flushbuf(EOF, f); if (f-\u0026gt;flag \u0026amp; _ERR) retval = -1; return retval; } /* 关闭文件 */ int fclose(FILE *f) { int fd; if (f == NULL) return -1; fd = f-\u0026gt;fd; // 将文件输出缓冲区刷新 fflush(f); // 将cnt、ptr、base、flag、fd重置，释放base指向的内存 f-\u0026gt;cnt = 0; f-\u0026gt;ptr = NULL; if (f-\u0026gt;base != NULL) free(f-\u0026gt;base); f-\u0026gt;base = NULL; f-\u0026gt;flag = 0; f-\u0026gt;fd = -1; // 关闭文件描述符 return close(fd); } int main(int argc, char *argv[]) { FILE *fp; fp = fopen(\u0026#34;test01.txt\u0026#34;, \u0026#34;r\u0026#34;); char c; while ((c = getc(fp)) != EOF) putc(c, stdout); fflush(stdout); fclose(fp); } 运行：\n1 2 3 ➜ ch08 git:(main) ✗ ./Exercise8-3 test01.txt This is test01.txt Good idea. exercise8-4 标准库函数int fseek(FILE *fp, long offset, int origin)类似于函数 lseek，所不同的是，该函数中的 fp 是一个文件指针而不是文件描述符，且返回值是一个 int 类型的状态而非位置值。编写函数 fseek，并确保该函数与库中其它函数使用的缓冲能够协同工作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* 将读写指针置于一定位置 */ int fseek(FILE *fp, long offset, int origin) { if ((fp-\u0026gt;flag \u0026amp; _UNBUF) == 0 \u0026amp;\u0026amp; fp-\u0026gt;base != NULL) { // 如果是写入模式，刷新缓冲区，将缓冲区内容输出，防止写入一个不为空的缓冲区 if (fp-\u0026gt;flag \u0026amp; _WRITE) fflush(fp); // 如果是读取模式，将缓冲区内容清空，防止读取一个不为空的缓冲区 else if (fp-\u0026gt;flag \u0026amp; _READ) { fp-\u0026gt;cnt = 0; fp-\u0026gt;ptr = fp-\u0026gt;base; } } return (lseek(fp-\u0026gt;fd, offset, origin) \u0026lt; 0); } int main(int argc, char *argv[]) { FILE *fp; if (argc == 1) return 1; fp = fopen(argv[1], \u0026#34;r\u0026#34;); off_t offset = 0; if (argc == 3) offset = atol(argv[2]); char c; fseek(fp, offset, SEEK_SET); while ((c = getc(fp)) != EOF) putc(c, stdout); fflush(stdout); fclose(fp); } 运行：\n1 2 3 ➜ ch08 git:(main) ✗ ./Exercise8-4 test01.txt 12 01.txt Good idea. exercise8-5 修改 fsize 程序，打印 i 结点项中包含的其它信息。\n书中提供的代码有一些问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* readdir: read directory entries in sequence */ Dirent *mreaddir(mDIR *dp) { struct direct dirbuf; /* local directory structure */ static Dirent d; /* return: portable structure */ int readsize; // 此版本的read无法读取一个目录文件，下面的语句执行之后 readsize 始终为-1 // 在其他测试程序中单独测试了使用 read() 来读取一个目录文件，也是得到相同的结论 // 所以就在本步骤，只好使用系统提供的 readdir() 来读取一个目录文件的信息 while ((readsize = read(dp-\u0026gt;fd, (char *)\u0026amp;dirbuf, sizeof(dirbuf))) == sizeof(dirbuf)) { if (dirbuf.d_ino == 0) /* slot not in use */ continue; d.ino = dirbuf.d_ino; strncpy(d.name, dirbuf.d_name, DIRSIZ); d.name[DIRSIZ] = \u0026#39;\\0\u0026#39;; /* ensure termination */ return \u0026amp;d; } return NULL; } 经过修改，下面的代码可以实现递归打印目录中的文件及子目录内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026#34;./dirent.h\u0026#34; #define MAX_PATH 1024 Dirent *mreaddir02(DIR *dp) { struct direct *dirbuf; static Dirent d; // 静态变量 if ((dirbuf = readdir(dp)) == NULL || dirbuf-\u0026gt;d_ino == 0) return NULL; d.ino = dirbuf-\u0026gt;d_ino; strncpy(d.name, dirbuf-\u0026gt;d_name, DIRSIZ); d.name[DIRSIZ] = \u0026#39;\\0\u0026#39;; return \u0026amp;d; } /* dirwalk: apply fcn to all files in dir */ void dirwalk(char *dir, void (*fcn)(char *)) { char name[MAX_PATH]; Dirent *dp = malloc(sizeof(Dirent)); memset(dp-\u0026gt;name, 0, sizeof(dp-\u0026gt;name)); DIR *dfd; // 直接使用系统的opendir() if ((dfd = opendir(dir)) == NULL) { fprintf(stderr, \u0026#34;dirwalk: can\u0026#39;t open %s\\n\u0026#34;, dir); return; } while ((dp = mreaddir02(dfd)) != NULL) { if (strcmp(dp-\u0026gt;name, \u0026#34;.\u0026#34;) == 0 || strcmp(dp-\u0026gt;name, \u0026#34;..\u0026#34;) == 0) continue; /* skip self and parent */ if (strlen(dir) + strlen(dp-\u0026gt;name) + 2 \u0026gt; sizeof(name)) fprintf(stderr, \u0026#34;dirwalk: name %s %s too long\\n\u0026#34;, dir, dp-\u0026gt;name); else { sprintf(name, \u0026#34;%s/%s\u0026#34;, dir, dp-\u0026gt;name); (*fcn)(name); } } // 直接使用系统提供的closedir() closedir(dfd); } void fsize(char *name) { struct stat stbuf; if (stat(name, \u0026amp;stbuf) == -1) { fprintf(stderr, \u0026#34;fsize: can\u0026#39;t access %s\\n\u0026#34;, name); return; } if (S_ISDIR(stbuf.st_mode)) /* directory */ dirwalk(name, fsize); char timebuf[32]; strftime(timebuf, sizeof(timebuf), \u0026#34;%b %d %R\u0026#34;, localtime(\u0026amp;stbuf.st_mtime)); // 展示文件大小，文件的inode号，文件的最后修改时间，文件名 printf(\u0026#34;%8ldB %8ld %s %s\\n\u0026#34;, stbuf.st_size, stbuf.st_ino, timebuf, name); } 运行，打印文件的大小、inode节点号、最后修改日期、文件名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ➜ ch08 git:(main) ✗ ./Exercise8-5 /home/jagger/Codes/ch08 1300B 149492 Oct 19 10:11 /home/jagger/Codes/ch08/Exercise8-1.c 6917B 149495 Oct 23 12:59 /home/jagger/Codes/ch08/Exercise8-4.c 28B 149503 Oct 19 10:13 /home/jagger/Codes/ch08/test02.txt 40B 149491 Oct 19 09:49 /home/jagger/Codes/ch08/.gitignore 1461B 149502 Oct 19 11:29 /home/jagger/Codes/ch08/Exercise8-8.c 13464B 149490 Oct 23 15:12 /home/jagger/Codes/ch08/README.md 3134B 149498 Oct 20 14:04 /home/jagger/Codes/ch08/Exercise8-6.c 662B 149504 Oct 20 13:12 /home/jagger/Codes/ch08/dirent.h 399B 149505 Oct 23 13:32 /home/jagger/Codes/ch08/test.c 3362B 149497 Oct 23 15:00 /home/jagger/Codes/ch08/Exercise8-5.c 30B 149496 Oct 23 11:34 /home/jagger/Codes/ch08/test01.txt 819B 149499 Oct 20 13:43 /home/jagger/Codes/ch08/Exercise8-7.c 6202B 149494 Oct 23 11:47 /home/jagger/Codes/ch08/Exercise8-3.c 75B 149501 Oct 19 09:50 /home/jagger/Codes/ch08/createfile.sh 23016B 149506 Oct 23 15:13 /home/jagger/Codes/ch08/Exercise8-5 209B 149500 Oct 19 09:51 /home/jagger/Codes/ch08/Makefile 3511B 149493 Oct 19 11:22 /home/jagger/Codes/ch08/Exercise8-2.c 4096B 149489 Oct 23 15:13 /home/jagger/Codes/ch08 exercise8-6 标准库函数 calloc(n, size)返回一个指针，它指向 n 个长度为 size的对象，且所有分配的存储空间都被初始化为0。通过调用或修改 malloc函数来实现 calloc函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void *mcalloc(size_t n, size_t size) { void *p; p = malloc(n * size); if (p != NULL) bzero(p, n * size); return p; } int main(void) { int size; int *p = NULL; printf(\u0026#34;Enter the size of memory to allocate: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); p = (int *)mcalloc(size, sizeof(*p)); if (p != NULL) { printf(\u0026#34;Memory allocated successfully\\n\u0026#34;); for (int i = 0; i \u0026lt; size; i++) { printf(\u0026#34;%08X \u0026#34;, p[i]); if (i % 8 == 7) printf(\u0026#34;\\n\u0026#34;); } } return 0; } 运行：\n1 2 3 4 Enter the size of memory to allocate: 12 Memory allocated successfully 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 exercise8-7 malloc 接收对存储空间的请求时，并不检查请求长度的合理性；而 free则认为被释放的块包含一个有效的长度字段。改进这些函数，使它们具有错误检查的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void *mmalloc(int size) { if (size \u0026lt;= 0 || size \u0026gt; MAXSIZE) { fprintf(stderr, \u0026#34;Invalid allocation size: %d Bytes\\n\u0026#34;, size); return NULL; } else { void *ptr = malloc(size); if (ptr == NULL) fprintf(stderr, \u0026#34;Memory allocation failed\\n\u0026#34;); printf(\u0026#34;Memory allocated successfully\\n\u0026#34;); return ptr; } } void mfree(void *ptr) { if (ptr == NULL) { fprintf(stderr, \u0026#34;Attempt to free a null pointer\\n\u0026#34;); return; } printf(\u0026#34;Memory freed successfully\\n\u0026#34;); free(ptr); } int main() { int size; printf(\u0026#34;Enter the size of memory to allocate: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); void *ptr = mmalloc(size); if (ptr != NULL) mfree(ptr); return 0; } 运行：\n1 2 Enter the size of memory to allocate: -1 Invalid allocation size: -1 Bytes ","permalink":"https://fireflyyh.top/posts/tcpl/ch08/","summary":"部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。\nexercise8-1 用 read、write、open 和 close 系统调用代替标准库中功能等价的函数，重写第 7 章的 cat 程序，并通过实验比较两个版本的相对执行速度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void filecopy(int ifp, int ofp) { char buf[BUFSIZE]; int n; while ((n = read(ifp, buf, BUFSIZE)) \u0026gt; 0) if (write(ofp, buf, n) !","title":"C语言程序设计第二版课后习题--第八章"},{"content":" 部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。\nexercise7-1 编写一个程序，根据它自身被调用时存放在argv[0]中的名字，实现将大写字母转换为小写字母或将小写字母转换为大写字母的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { int (*handler[2])(int) = {tolower, toupper}; int type = strcmp(argv[0], \u0026#34;./lower\u0026#34;) == 0 ? 0 : strcmp(argv[0], \u0026#34;./upper\u0026#34;) == 0 ? 1 : -1; if (type == -1) { fprintf(stderr, \u0026#34;Usage: %s [lower|upper]\\n\u0026#34;, argv[0]); } else { int c; while ((c = getchar()) != EOF) putchar(handler[type](c)); } } 运行：\n1 2 3 4 5 6 7 8 9 ➜ ch07 git:(main) ✗ gcc -o lower Exercise7-1.c ➜ ch07 git:(main) ✗ ./lower This this IYUSDbusaIs iyusdbusais ➜ ch07 git:(main) ✗ gcc -o other Exercise7-1.c ➜ ch07 git:(main) ✗ ./other Usage: ./other [lower|upper] exercise7-3 改写 minprintf 函数，使它能完成 printf 函数的更多功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 void minprintf(char *fmt, ...) { va_list ap; /* points to each unnamed arg in turn */ char *p, *sval; int ival; double dval; va_start(ap, fmt); /* make ap point to 1st unnamed arg */ for (p = fmt; *p; p++) { if (*p != \u0026#39;%\u0026#39;) { putchar(*p); continue; } switch (*++p) { case \u0026#39;d\u0026#39;: ival = va_arg(ap, int); printf(\u0026#34;%d\u0026#34;, ival); break; case \u0026#39;f\u0026#39;: dval = va_arg(ap, double); printf(\u0026#34;%f\u0026#34;, dval); break; case \u0026#39;s\u0026#39;: for (sval = va_arg(ap, char *); *sval; sval++) putchar(*sval); break; case \u0026#39;c\u0026#39;: // 字符 ival = va_arg(ap, int); printf(\u0026#34;%c\u0026#34;, ival); break; case \u0026#39;x\u0026#39;: // 十六进制 ival = va_arg(ap, int); printf(\u0026#34;%x\u0026#34;, ival); break; case \u0026#39;o\u0026#39;: // 八进制 ival = va_arg(ap, int); printf(\u0026#34;%o\u0026#34;, ival); break; case \u0026#39;%\u0026#39;: // 百分号 putchar(\u0026#39;%\u0026#39;); break; case \u0026#39;g\u0026#39;: // 浮点数 dval = va_arg(ap, double); printf(\u0026#34;%g\u0026#34;, dval); break; default: putchar(*p); break; } } va_end(ap); /* clean up when done */ } int main() { minprintf(\u0026#34;int: %d, float: %g, string: %s\\n\u0026#34;, 10, 3.14, \u0026#34;hello\u0026#34;); minprintf(\u0026#34;char: %c, hex: %x, oct: %o, double: %g, percent: %%\\n\u0026#34;, \u0026#39;a\u0026#39;, 255, 255, 3.1415926); return 0; } 运行：\n1 2 int: 10, float: 3.14, string: hello char: a, hex: ff, oct: 377, double: 3.14159, percent: % exercise7-4 类似于上一节中的函数 minprintf，编写 scanf 函数的一个简化版本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; void minscanf(char *fmt, ...) { va_list ap; char *p, *sval; int *ival; float *dval; unsigned *uval; int c; va_start(ap, fmt); for (p = fmt; *p; p++) { while (*p != \u0026#39;%\u0026#39;) p++; switch (*++p) { case \u0026#39;d\u0026#39;: ival = va_arg(ap, int *); scanf(\u0026#34;%d\u0026#34;, ival); break; case \u0026#39;f\u0026#39;: dval = va_arg(ap, float *); scanf(\u0026#34;%f\u0026#34;, dval); break; case \u0026#39;s\u0026#39;: sval = va_arg(ap, char *); scanf(\u0026#34;%s\u0026#34;, sval); break; case \u0026#39;c\u0026#39;: ival = va_arg(ap, int *); *ival = getchar(); break; default: break; } } va_end(ap); } int main() { int i; float f; char s[100]; char c; printf(\u0026#34;Enter an integer: \u0026#34;); minscanf(\u0026#34;%d\u0026#34;, \u0026amp;i); printf(\u0026#34;i = %d\\n\u0026#34;, i); printf(\u0026#34;Enter a float: \u0026#34;); minscanf(\u0026#34;%f\u0026#34;, \u0026amp;f); printf(\u0026#34;f = %f\\n\u0026#34;, f); printf(\u0026#34;Enter a string: \u0026#34;); minscanf(\u0026#34;%s\u0026#34;, s); printf(\u0026#34;s = %s\\n\u0026#34;, s); getchar(); // clear the input buffer printf(\u0026#34;Enter a character: \u0026#34;); minscanf(\u0026#34;%c\u0026#34;, \u0026amp;c); printf(\u0026#34;c = %c\\n\u0026#34;, c); } 运行：\n1 2 3 4 5 6 7 8 Enter an integer: 1 i = 1 Enter a float: 3.14 f = 3.140000 Enter a string: ioio s = ioio Enter a character: a c = a exercise7-5 改写第 4 章中的后缀计算器程序，用 scanf 函数和（或）sscanf 函数实现输入以及数的转换。\n其他不用改变，只需要改变主函数即可，将\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { int type; double op2; char s[MAXOP]; printf(\u0026#34;Please input expression:\\n\u0026#34;); while ((type = getop(s)) != EOF) { switch (type) { case NUMBER: push(atof(s)); break; ... } } } 修改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { int type; double op2; char s[MAXOP]; printf(\u0026#34;Please input expression:\\n\u0026#34;); while ((type = getop(s)) != EOF) { switch (type) { case NUMBER: int val; scanf(\u0026#34;%f\u0026#34;, \u0026amp;val); push(val); break; ... } } } exercise7-6 编写一个程序，比较两个文件并打印它们第一个不相同的行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void filecmp(FILE *fp1, FILE *fp2) { char *line1 = malloc(MAXLINE), *line2 = malloc(MAXLINE); int lineno = 1; while (fgets(line1, 100, fp1) != NULL \u0026amp;\u0026amp; fgets(line2, 100, fp2) != NULL) { if (strcmp(line1, line2) != 0) { printf(\u0026#34;difference in line %d\\n\u0026#34;, lineno); printf(\u0026#34;line1: %s\\n\u0026#34;, line1); printf(\u0026#34;line2: %s\\n\u0026#34;, line2); return; } lineno++; } if (feof(fp1) \u0026amp;\u0026amp; feof(fp2)) printf(\u0026#34;files are identical\\n\u0026#34;); else if (feof(fp1)) printf(\u0026#34;file2 has extra lines\\n\u0026#34;); else printf(\u0026#34;file1 has extra lines\\n\u0026#34;); } int main(int argc, char *argv[]) { FILE *fp1, *fp2; char *prog = argv[0]; /* program name for errors */ if (argc == 1 || argc == 2) /* no args; copy standard input */ fprintf(stderr, \u0026#34;Usage: %s file1 file2\\n\u0026#34;, prog); else { if ((fp1 = fopen(*++argv, \u0026#34;r\u0026#34;)) == NULL) { fprintf(stderr, \u0026#34;%s: can\u0026#39;t open %s\\n\u0026#34;, prog, *argv); exit(1); } if ((fp2 = fopen(*++argv, \u0026#34;r\u0026#34;)) == NULL) { fprintf(stderr, \u0026#34;%s: can\u0026#39;t open %s\\n\u0026#34;, prog, *argv); exit(1); } filecmp(fp1, fp2); } fclose(fp1); fclose(fp2); exit(0); } 1 2 3 4 5 ➜ ch07 git:(main) ✗ ./Exercise7-6 Exercise7-6.c Exercise7-5.c difference in line 5 line1: #define MAXLINE 1000 line2: void filecopy(FILE *ifp, FILE *ofp) exercise7-7 修改第 5 章的模式查找程序，使它从一个命名文件的集合中读取输入（有文件名参数时），如果没有文件名参数，则从标准输入中读取输入。当发现一个匹配行时，是否应该将相应的文件名打印出来？\nexercise7-8 编写一个程序，以打印一个文件集合，每个文件从新的一页开始打印，并且打印每个文件相应的标题和页数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXLINE 1024 #define LINES_PER_PAGE 3 void print_file(char *file_name) { FILE *f; int page_number = 1; int line_count; int c; int new_page = 1; assert(file_name != NULL); char *line = malloc(MAXLINE); if ((f = fopen(file_name, \u0026#34;r\u0026#34;)) != NULL) { while (fgets(line, MAXLINE, f) != NULL) { if (new_page) { printf(\u0026#34;[%s] page %d starts\\n\u0026#34;, file_name, page_number); new_page = 0; line_count = 1; } if (!feof(f) \u0026amp;\u0026amp; ++line_count \u0026gt; LINES_PER_PAGE) { /* print out the footer */ printf(\u0026#34;[%s] page %d ends\\n\u0026#34;, file_name, page_number); /* skip another line so we can see it on screen */ putchar(\u0026#39;\\n\u0026#39;); new_page = 1; page_number++; } else { fputs(line, stdout); } } /* skip another line so we can see it on screen */ putchar(\u0026#39;\\n\u0026#39;); fclose(f); } } int main(int argc, char *argv[]) { int i; if (argc \u0026lt; 2) { fputs(\u0026#34;no files specified\\n\u0026#34;, stderr); return EXIT_FAILURE; } for (i = 1; i \u0026lt; argc; i++) print_file(argv[i]); return EXIT_SUCCESS; } 运行\n1 2 3 4 5 6 7 8 9 ➜ ch07 git:(main) ✗ ./Exercise7-8 test.txt [test.txt] page 1 starts It’s quite a good summary, but it would have even better when taking into account the importance of the number of requested rows, expected by the Cassandra client. 1) “To perform the country index lookup, every node is queried, looks up the \u0026#39;UK\u0026#39; partition and then looks up each user_accounts partition found. ” [test.txt] page 1 ends [test.txt] page 2 starts 2) “This leads to the conclusion that the best use case for Cassandra\u0026#39;s secondary indexes is when p is approximately n i.e. the number of partitions is about equal to the number of nodes.” What a narrow best use case ! Hopefully, there are other use cases where seconday index are fine (that is, for low-cardinality sets), or even finer (according to the number of resulting rows requested vs the cardinality of indexed values). exercise7-9 类似于 isupper 这样的函数可以通过某种方式实现以达到节省空间或时间的目的。考虑节省空间或时间的实现方式。\n1 2 3 4 # define isupper(c) __isctype((c), _ISupper) # define __isctype(c, type) \\ ((*__ctype_b_loc ())[(int) (c)] \u0026amp; (unsigned short int) type) 使用了宏定义\n","permalink":"https://fireflyyh.top/posts/tcpl/ch07/","summary":"部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。\nexercise7-1 编写一个程序，根据它自身被调用时存放在argv[0]中的名字，实现将大写字母转换为小写字母或将小写字母转换为大写字母的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { int (*handler[2])(int) = {tolower, toupper}; int type = strcmp(argv[0], \u0026#34;./lower\u0026#34;) == 0 ? 0 : strcmp(argv[0], \u0026#34;./upper\u0026#34;) == 0 ? 1 : -1; if (type == -1) { fprintf(stderr, \u0026#34;Usage: %s [lower|upper]\\n\u0026#34;, argv[0]); } else { int c; while ((c = getchar()) !","title":"C语言程序设计第二版课后习题--第七章"},{"content":" 部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。\nexercise6-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #define NKEYS (sizeof keytab / sizeof(keytab[0])) int binsearch(char *word, struct key tab[], int n) { int cond; int low, high, mid; low = 0; high = n - 1; while (low \u0026lt;= high) { mid = (low + high) / 2; if ((cond = strcmp(word, tab[mid].word)) \u0026lt; 0) high = mid - 1; else if (cond \u0026gt; 0) low = mid + 1; else return mid; } return -1; } int getword(char *word, int lim) { int c; char *w = word; while (isspace(c = getch())) ; if (c != EOF) *w++ = c; if (!isalpha(c)) { *w = \u0026#39;\\0\u0026#39;; return c; } for (; --lim \u0026gt; 0; w++) if (!isalnum(*w = getch())) { ungetch(*w); break; } *w = \u0026#39;\\0\u0026#39;; return word[0]; } int main() { int n; char word[MAXWORD]; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0])) if ((n = binsearch(word, keytab, NKEYS)) \u0026gt;= 0) keytab[n].count++; for (n = 0; n \u0026lt; NKEYS; n++) if (keytab[n].count \u0026gt; 0) printf(\u0026#34;%4d %s\\n\u0026#34;, keytab[n].count, keytab[n].word); return 0; } 上述 getword 函数不能正确处理下划线、字符串常量、注释及预处理器控制指令。请编写一个更完善的 getword 函数。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 enum { NORMAL, COMMENT, PREPROCESSOR, STRING, UNDERSCORE }; int getword02(char *word, int lim) { int c, d, inComment = 0, inString = 0, isPreprocessor = 0, isUnderscore = 0; // 分别表示是否在注释、字符串、预处理指令、下划线中 char *w = word; while (isspace(c = getch())) ; if (c != EOF) *w++ = c; type = NORMAL; // 默认为普通字符 if (c == \u0026#39;\u0026#34;\u0026#39;) inString = 1; else if (c == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; (d = getch()) == \u0026#39;*\u0026#39;) // 注释 { *w++ = d; inComment = 1; } else if (c == \u0026#39;#\u0026#39;) // 预处理指令 { isPreprocessor = 1; } else if (c == \u0026#39;_\u0026#39;) // 下划线 { isUnderscore = 1; } else if (!isalpha(c) \u0026amp;\u0026amp; c != \u0026#39;_\u0026#39;) // 不合法字符 { *w = \u0026#39;\\0\u0026#39;; return c; } for (; --lim \u0026gt; 0; w++) { if (inString) // 如果在字符串中，直到遇到双引号才结束 { if ((*w = getch()) == \u0026#39;\u0026#34;\u0026#39;) { w++; type = STRING; break; } } else if (inComment) { if ((*w = getch()) == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; (d = getch()) == \u0026#39;/\u0026#39;) // 注释结束 { w++; *w++ = d; type = COMMENT; break; } } else if (isPreprocessor) // 如果在预处理指令中，直到遇到空格才结束 { if (isspace(*w = getch())) { type = PREPROCESSOR; break; } } else if (isUnderscore) // 如果在下划线中，直到遇到空格才结束 { if (isspace(*w = getch())) { type = UNDERSCORE; break; } } else { if (!isalnum(*w = getch()) \u0026amp;\u0026amp; *w != \u0026#39;_\u0026#39;) // 如果不是字母或下划线，结束 { ungetch(*w); break; } } } *w = \u0026#39;\\0\u0026#39;; return word[0]; } int main() { int n; char word[MAXWORD]; while (getword02(word, MAXWORD) != EOF) // 读取单词 { if (type == COMMENT) printf(\u0026#34;Comment: %s\\n\u0026#34;, word); else if (type == PREPROCESSOR) printf(\u0026#34;Preprocessor: %s\\n\u0026#34;, word); else if (type == STRING) printf(\u0026#34;String: %s\\n\u0026#34;, word); else if (type == UNDERSCORE) printf(\u0026#34;Underscore: %s\\n\u0026#34;, word); else if (isalpha(word[0]) \u0026amp;\u0026amp; ((n = binsearch(word, keytab, NKEYS)) \u0026gt;= 0)) { keytab[n].count++; printf(\u0026#34;Keyword: %s\\n\u0026#34;, word); } } printf(\u0026#34;\\nkeywords:\\n\u0026#34;); for (n = 0; n \u0026lt; NKEYS; n++) if (keytab[n].count \u0026gt; 0) printf(\u0026#34;%4d %s\\n\u0026#34;, keytab[n].count, keytab[n].word); return 0; } 运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /*comment*/ #define \u0026#34;string\u0026#34; while for while int _variable Comment: /*comment*/ Preprocessor: #define String: \u0026#34;string\u0026#34; Keyword: while Keyword: for Keyword: while Keyword: int Underscore: _variable keywords: 1 for 1 int 2 while exercise6-2 编写一个程序，用以读入一个 C 语言程序，并按字母表顺序分组打印变量名，要求每一组内各变量名的前 6 个字符相同，其余字符不同。字符串和注释中的单词不予考虑。请将 6 作为一个可在命令行中设定的参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 #define GRPLEN 6 #define NKEYS (sizeof keytab / sizeof(keytab[0])) enum { NORMAL, COMMENT, PREPROCESSOR, STRING, UNDERSCORE }; struct tnode { /* the tree node: */ char *word; /* points to the text */ int count; /* number of occurrences */ struct tnode *left; /* left child */ struct tnode *right; /* right child */ }; int group_length = GRPLEN; int type; struct tnode *talloc(void) { return (struct tnode *)malloc(sizeof(struct tnode)); } char *Strdup(char *s) /* make a duplicate of s */ { char *p; p = (char *)malloc(strlen(s) + 1); /* +1 for \u0026#39;\\0\u0026#39; */ if (p != NULL) strcpy(p, s); return p; } /* addtree: add a node with w, at or below p */ struct tnode *addtree(struct tnode *p, char *w) { int cond; if (p == NULL) { /* a new word has arrived */ p = talloc(); /* make a new node */ p-\u0026gt;word = Strdup(w); p-\u0026gt;count = 1; p-\u0026gt;left = p-\u0026gt;right = NULL; } else if ((cond = strcmp(w, p-\u0026gt;word)) == 0) p-\u0026gt;count++; /* repeated word */ else if (cond \u0026lt; 0) /* less than into left subtree */ p-\u0026gt;left = addtree(p-\u0026gt;left, w); else /* greater than into right subtree */ p-\u0026gt;right = addtree(p-\u0026gt;right, w); return p; } /* treeprint: in-order print of tree p */ void treeprint(struct tnode *p) { if (p != NULL) { treeprint(p-\u0026gt;left); printf(\u0026#34;%4d %s\\n\u0026#34;, p-\u0026gt;count, p-\u0026gt;word); treeprint(p-\u0026gt;right); } } int binsearch(char *word, struct key tab[], int n) { int cond; int low, high, mid; low = 0; high = n - 1; while (low \u0026lt;= high) { mid = (low + high) / 2; if ((cond = strcmp(word, tab[mid].word)) \u0026lt; 0) high = mid - 1; else if (cond \u0026gt; 0) low = mid + 1; else return mid; } return -1; } int getword(char *word, int lim) { int c, d, inComment = 0, inString = 0, isPreprocessor = 0, isUnderscore = 0; // 分别表示是否在注释、字符串、预处理指令、下划线中 char *w = word; while (isspace(c = getch())) ; if (c != EOF) *w++ = c; type = NORMAL; // 默认为普通字符 if (c == \u0026#39;\u0026#34;\u0026#39;) inString = 1; else if (c == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; (d = getch()) == \u0026#39;*\u0026#39;) // 注释 { *w++ = d; inComment = 1; } else if (c == \u0026#39;#\u0026#39;) // 预处理指令 { isPreprocessor = 1; } else if (c == \u0026#39;_\u0026#39;) // 下划线 { isUnderscore = 1; } else if (!isalpha(c) \u0026amp;\u0026amp; c != \u0026#39;_\u0026#39;) // 不合法字符 { *w = \u0026#39;\\0\u0026#39;; return c; } for (; --lim \u0026gt; 0; w++) { if (inString) // 如果在字符串中，直到遇到双引号才结束 { if ((*w = getch()) == \u0026#39;\u0026#34;\u0026#39;) { w++; type = STRING; break; } } else if (inComment) { if ((*w = getch()) == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; (d = getch()) == \u0026#39;/\u0026#39;) // 注释结束 { w++; *w++ = d; type = COMMENT; break; } } else if (isPreprocessor) // 如果在预处理指令中，直到遇到空格才结束 { if (isspace(*w = getch())) { type = PREPROCESSOR; break; } } else if (isUnderscore) // 如果在下划线中，直到遇到空格才结束 { if (isspace(*w = getch())) { type = UNDERSCORE; break; } } else { if (!isalnum(*w = getch()) \u0026amp;\u0026amp; *w != \u0026#39;_\u0026#39;) // 如果不是字母或下划线，结束 { ungetch(*w); break; } } } *w = \u0026#39;\\0\u0026#39;; return word[0]; } bool is_variable(char *word) { return binsearch(word, keytab, NKEYS) \u0026lt; 0; } void groupprint(struct tnode *p, char *prefix) { if (p != NULL) { groupprint(p-\u0026gt;left, prefix); if (strncmp(p-\u0026gt;word, prefix, group_length) == 0) { printf(\u0026#34;%4d %s\\n\u0026#34;, p-\u0026gt;count, p-\u0026gt;word); } groupprint(p-\u0026gt;right, prefix); } } void print_groups(struct tnode *root) { if (root == NULL) return; char current_prefix[MAXWORD] = \u0026#34;\u0026#34;; struct tnode *current = root; while (current != NULL) { strncpy(current_prefix, current-\u0026gt;word, group_length); current_prefix[group_length] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;Group: %s\\n\u0026#34;, current_prefix); groupprint(root, current_prefix); current = current-\u0026gt;right; } } int main(int argc, char *argv[]) { if (argc \u0026gt; 1) { group_length = atoi(argv[1]); } int n; struct tnode *root = NULL; char word[MAXWORD]; while (getword(word, MAXWORD) != EOF) if (type == NORMAL \u0026amp;\u0026amp; isalpha(word[0]) \u0026amp;\u0026amp; is_variable(word)) root = addtree(root, word); print_groups(root); return 0; } 运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ➜ ch06 git:(main) ./Exercise6-2 5 #include \u0026lt;stdio.h\u0026gt; int main() { int varOne = 1; int varTwo = 2; int varThree = 3; float varOneMore = 4.0; char varTwoMore = \u0026#39;a\u0026#39;; // This is a comment /* This is a block comment int varFour = 4; */ return 0; } Group: stdio 1 stdio Group: varOn 1 varOne 1 varOneMore Group: varTw 1 varTwo 1 varTwoMore Group: varTw 1 varTwo 1 varTwoMore exercise6-3 编写一个交叉引用程序，打印文档中所有单词的列表，并且每个单词还有一个列表，记录出现过该单词的行号。对 the、and 等非实义单词不予考虑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 struct tnode { char *word; int lines[MAXLINES]; int line_count; struct tnode *left; struct tnode *right; }; int line_number = 1; struct tnode *talloc(void) { return (struct tnode *)malloc(sizeof(struct tnode)); } char *strdup(const char *s) { char *p = (char *)malloc(strlen(s) + 1); if (p != NULL) strcpy(p, s); return p; } struct tnode *addtree(struct tnode *p, char *w, int lineno) { int cond; if (p == NULL) { p = talloc(); p-\u0026gt;word = strdup(w); p-\u0026gt;lines[0] = lineno; p-\u0026gt;line_count = 1; p-\u0026gt;left = p-\u0026gt;right = NULL; } else if ((cond = strcmp(w, p-\u0026gt;word)) == 0) { if (p-\u0026gt;lines[p-\u0026gt;line_count - 1] != lineno) p-\u0026gt;lines[p-\u0026gt;line_count++] = lineno; } else if (cond \u0026lt; 0) p-\u0026gt;left = addtree(p-\u0026gt;left, w, lineno); else p-\u0026gt;right = addtree(p-\u0026gt;right, w, lineno); return p; } void treeprint(struct tnode *p) { if (p != NULL) { treeprint(p-\u0026gt;left); printf(\u0026#34;%s: \u0026#34;, p-\u0026gt;word); for (int i = 0; i \u0026lt; p-\u0026gt;line_count; i++) printf(\u0026#34;%d \u0026#34;, p-\u0026gt;lines[i]); printf(\u0026#34;\\n\u0026#34;); treeprint(p-\u0026gt;right); } } int getword(char *word, int lim) { int c; char *w = word; while (isspace(c = getch())) if (c == \u0026#39;\\n\u0026#39;) line_number++; if (c != EOF) *w++ = c; if (!isalpha(c)) { *w = \u0026#39;\\0\u0026#39;; return c; } for (; --lim \u0026gt; 0; w++) if (!isalnum(*w = getch())) { ungetch(*w); break; } *w = \u0026#39;\\0\u0026#39;; return word[0]; } int is_noise_word(char *word) { static char *noise_words[] = { \u0026#34;the\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;an\u0026#34;, \u0026#34;in\u0026#34;, \u0026#34;on\u0026#34;, \u0026#34;of\u0026#34;, \u0026#34;to\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;are\u0026#34;, \u0026#34;was\u0026#34;, \u0026#34;were\u0026#34;, \u0026#34;it\u0026#34;, \u0026#34;that\u0026#34;, \u0026#34;this\u0026#34;, \u0026#34;with\u0026#34;, \u0026#34;as\u0026#34;, \u0026#34;for\u0026#34;, \u0026#34;by\u0026#34;, \u0026#34;at\u0026#34;, \u0026#34;from\u0026#34;, \u0026#34;but\u0026#34;, \u0026#34;or\u0026#34;, \u0026#34;not\u0026#34;, \u0026#34;be\u0026#34;, \u0026#34;have\u0026#34;, \u0026#34;has\u0026#34;, \u0026#34;had\u0026#34;, \u0026#34;do\u0026#34;, \u0026#34;does\u0026#34;, \u0026#34;did\u0026#34;, \u0026#34;will\u0026#34;, \u0026#34;would\u0026#34;, \u0026#34;can\u0026#34;, \u0026#34;could\u0026#34;, \u0026#34;should\u0026#34;, \u0026#34;shall\u0026#34;, \u0026#34;may\u0026#34;, \u0026#34;might\u0026#34;, \u0026#34;must\u0026#34;, \u0026#34;if\u0026#34;, \u0026#34;then\u0026#34;, \u0026#34;else\u0026#34;, \u0026#34;when\u0026#34;, \u0026#34;where\u0026#34;, \u0026#34;which\u0026#34;, \u0026#34;who\u0026#34;, \u0026#34;whom\u0026#34;, \u0026#34;whose\u0026#34;, \u0026#34;why\u0026#34;, \u0026#34;how\u0026#34;, NULL}; for (char **p = noise_words; *p != NULL; p++) if (strcmp(word, *p) == 0) return 1; return 0; } int main(void) { struct tnode *root = NULL; char word[MAXWORD]; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0]) \u0026amp;\u0026amp; !is_noise_word(word)) root = addtree(root, word, line_number); treeprint(root); return 0; } 运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 ➜ ch06 git:(main) ./Exercise6-3 \u0026lt; test.txt AFAIK: 3 Cassandra: 1 4 Hopefully: 5 It: 1 So: 3 This: 4 To: 2 UK: 2 Well: 3 What: 5 about: 4 according: 5 account: 1 accounts: 2 all: 3 always: 3 approximately: 4 been: 3 best: 4 5 better: 1 calls: 3 cardinality: 5 case: 4 5 cases: 5 client: 1 conclusion: 4 country: 2 e: 4 each: 2 enough: 3 equal: 4 even: 1 5 every: 2 3 expected: 1 fine: 5 finer: 5 found: 2 3 good: 1 i: 4 importance: 1 index: 2 5 indexed: 5 indexes: 4 into: 1 leads: 4 looks: 2 lookup: 2 low: 5 n: 4 narrow: 5 node: 2 3 nodes: 3 4 number: 1 4 5 other: 5 p: 4 partition: 2 partitions: 4 perform: 2 queried: 2 3 quite: 1 requested: 1 5 resulting: 5 rows: 1 3 5 s: 1 4 secondary: 4 seconday: 5 sets: 5 stop: 3 summary: 1 taking: 1 there: 5 up: 2 use: 4 5 user: 2 values: 5 vs: 5 exercise6-4 编写一个程序，根据单词的出现频率按降序打印输入的各个不同单词，并在每个单词的前面标上它的出现次数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 将树转换为列表 void treeToList(struct tnode *p, struct wordinfo list[]) { if (p != NULL) { treeToList(p-\u0026gt;left, list); list[counter].word = strdup(p-\u0026gt;word); list[counter].count = p-\u0026gt;count; counter++; treeToList(p-\u0026gt;right, list); } } // 打印列表 void listprint(struct wordinfo list[]) { for (int i = 0; i \u0026lt; wordCount; i++) { printf(\u0026#34;%4d %s\\n\u0026#34;, list[i].count, list[i].word); } } // 交换两个元素 void swap(struct wordinfo list[], int i, int j) { struct wordinfo temp; temp = list[i]; list[i] = list[j]; list[j] = temp; } // 根据单词出现的频率来进行快速排序 void mqsort(struct wordinfo list[], int left, int right) { int i, last; if (left \u0026gt;= right) return; swap(list, left, (left + right) / 2); last = left; for (i = left + 1; i \u0026lt;= right; i++) if (list[i].count \u0026gt; list[left].count) swap(list, ++last, i); swap(list, left, last); mqsort(list, left, last - 1); mqsort(list, last + 1, right); } int main(void) { struct tnode *root; char word[MAXWORD]; root = NULL; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0])) root = addtree(root, word); printf(\u0026#34;Count of words is %d\\n\u0026#34;, wordCount); struct wordinfo list[wordCount]; treeToList(root, list); mqsort(list, 0, wordCount - 1); listprint(list); return 0; } 运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 ➜ ch06 git:(main) ./Exercise6-4 \u0026lt; test.txt Count of words is 95 12 the 6 of 6 is 4 number 3 queried 3 rows 3 are 3 node 3 to 3 when 3 use 2 index 2 found 2 have 2 Cassandra 2 looks 2 cardinality 2 nodes 2 even 2 not 2 for 2 partition 2 best 2 requested 2 every 2 s 2 case 2 that 2 a 2 up 1 leads 1 So 1 This 1 e 1 or 1 enough 1 other 1 and 1 p 1 expected 1 calls 1 finer 1 partitions 1 been 1 perform 1 accounts 1 To 1 importance 1 quite 1 indexed 1 all 1 into 1 resulting 1 it 1 UK 1 better 1 always 1 low 1 secondary 1 narrow 1 seconday 1 but 1 sets 1 country 1 stop 1 equal 1 summary 1 fine 1 taking 1 good 1 cases 1 AFAIK 1 Well 1 Hopefully 1 then 1 lookup 1 there 1 It 1 What 1 each 1 client 1 account 1 conclusion 1 indexes 1 user 1 n 1 values 1 approximately 1 vs 1 according 1 about 1 i 1 where 1 by 1 would exercise6-5 编写函数 undef，它将从由 lookup 和 install 维护的表中删除一个变量及其定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* undef: remove a name and its definition from the hashtab */ void undef(char *name) { struct nlist *np, *prev = NULL; unsigned hashval = hash(name); for (np = hashtab[hashval]; np != NULL; prev = np, np = np-\u0026gt;next) // 遍历链表 { if (strcmp(name, np-\u0026gt;name) == 0) { if (prev == NULL) hashtab[hashval] = np-\u0026gt;next; else prev-\u0026gt;next = np-\u0026gt;next; free(np-\u0026gt;name); free(np-\u0026gt;defn); free(np); return; } } } int main(void) { struct nlist *np; printf(\u0026#34;test install \\\u0026#34;MAXLINE\\\u0026#34; \\\u0026#34;BUFSIZE\\\u0026#34;:\\n\u0026#34;); install(\u0026#34;MAXLINE\u0026#34;, \u0026#34;1000\u0026#34;); install(\u0026#34;BUFSIZE\u0026#34;, \u0026#34;100\u0026#34;); np = lookup(\u0026#34;MAXLINE\u0026#34;); if (np == NULL) printf(\u0026#34;install failed\\n\u0026#34;); else printf(\u0026#34;defination of \\\u0026#34;MAXLINE\\\u0026#34; is: %s\\n\u0026#34;, np-\u0026gt;defn); printf(\u0026#34;install success\\n\u0026#34;); printf(\u0026#34;\\ntest undef \\\u0026#34;BUFSIZE\\\u0026#34;:\\n\u0026#34;); undef(\u0026#34;BUFSIZE\u0026#34;); np = lookup(\u0026#34;BUFSIZE\u0026#34;); if (np == NULL) printf(\u0026#34;can not find defination of \\\u0026#34;BUFSIZE\\\u0026#34;\\nundef success\\n\u0026#34;); return 0; } 运行：\n1 2 3 4 5 6 7 8 ➜ ch06 git:(main) ✗ ./Exercise6-5 test install \u0026#34;MAXLINE\u0026#34; \u0026#34;BUFSIZE\u0026#34;: defination of \u0026#34;MAXLINE\u0026#34; is: 1000 install success test undef \u0026#34;BUFSIZE\u0026#34;: can not find defination of \u0026#34;BUFSIZE\u0026#34; undef success exercise6-6 以本节介绍的函数为基础，编写一个适合 C 语言程序使用的#define 处理器的简单版本（即无参数的情况）。你会发现 getch 和 ungetch 函数非常有用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 void skipblanks(void) { int c; while ((c = getch()) == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) ; ungetch(c); } void getdef(void) { int c, i; char def[BUFSIZE], name[BUFSIZE]; skipblanks(); if (!isalpha(c = getch())) { printf(\u0026#34;getdef: invalid macro name\\n\u0026#34;); return; } for (i = 0; isalnum(c) || c == \u0026#39;_\u0026#39;; c = getch()) name[i++] = c; name[i] = \u0026#39;\\0\u0026#39;; skipblanks(); if (c != \u0026#39; \u0026#39;) { printf(\u0026#34;getdef: missing space after macro name\\n\u0026#34;); return; } for (i = 0; (c = getch()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;;) def[i++] = c; def[i] = \u0026#39;\\0\u0026#39;; if (i \u0026gt; 0) install(name, def); } void procdef(void) { int c; while ((c = getch()) != EOF) { if (c == \u0026#39;#\u0026#39;) { char keyword[7]; int i; for (i = 0; i \u0026lt; 6 \u0026amp;\u0026amp; (c = getch()) != EOF; i++) { keyword[i] = c; } keyword[i] = \u0026#39;\\0\u0026#39;; if (strcmp(keyword, \u0026#34;define\u0026#34;) == 0) { getdef(); } } } } int main(void) { procdef(); printf(\u0026#34;name defination\\n\u0026#34;); for (int i = 0; i \u0026lt; HASHSIZE; i++) { struct nlist *np = hashtab[i]; while (np != NULL) { printf(\u0026#34;%-16s%s\\n\u0026#34;, np-\u0026gt;name, np-\u0026gt;defn); np = np-\u0026gt;next; } } return 0; } 对于test.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #define LISTENQ 1024 #define MAXLINE 4096 #define BUFFSIZE 8192 #define SERV_PORT 9877 #define AI_PASSIVE 1 #define AI_CANONNAME 2 #define NI_MAXHOST 1025 #define NI_MAXSERV 32 #define NI_NOFQDN 1 #define NI_NUMERICHOST 2 #define NI_NAMEREQD 4 #define NI_NUMERICSERV 8 #define NI_DGRAM 16 #define EAI_ADDRFAMILY 1 #define EAI_AGAIN 2 #define EAI_BADFLAGS 3 #define EAI_FAIL 4 #define EAI_FAMILY 5 #define EAI_MEMORY 6 #define EAI_NODATA 7 #define EAI_NONAME 8 #define EAI_SERVICE 9 #define EAI_SOCKTYPE 10 #define EAI_SYSTEM 11 运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ➜ ch06 git:(main) ✗ ./Exercise6-6 \u0026lt; test.c name defination AI_CANONNAME 2 NI_NUMERICHOST 2 EAI_NONAME 8 EAI_ADDRFAMILY 1 NI_NUMERICSERV 8 AI_PASSIVE 1 EAI_SERVICE 9 SERV_PORT 9877 EAI_SOCKTYPE 10 EAI_MEMORY 6 EAI_AGAIN 2 EAI_BADFLAGS 3 NI_MAXHOST 1025 EAI_FAIL 4 NI_NAMEREQD 4 EAI_NODATA 7 MAXLINE 4096 NI_MAXSERV 32 EAI_SYSTEM 11 BUFFSIZE 8192 NI_DGRAM 16 NI_NOFQDN 1 EAI_FAMILY 5 LISTENQ 1024 ","permalink":"https://fireflyyh.top/posts/tcpl/ch06/","summary":"部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。\nexercise6-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #define NKEYS (sizeof keytab / sizeof(keytab[0])) int binsearch(char *word, struct key tab[], int n) { int cond; int low, high, mid; low = 0; high = n - 1; while (low \u0026lt;= high) { mid = (low + high) / 2; if ((cond = strcmp(word, tab[mid].","title":"C语言程序设计第二版课后习题--第六章"},{"content":" 部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。\nexercise5-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int getint(int *pn) { int c, sign; while (isspace(c = getch())) /* skip white space */ ; if (!isdigit(c) \u0026amp;\u0026amp; c != EOF \u0026amp;\u0026amp; c != \u0026#39;+\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;) { ungetch(c); /* it is not a number */ return 0; } sign = (c == \u0026#39;-\u0026#39;) ? -1 : 1; if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) c = getch(); for (*pn = 0; isdigit(c); c = getch()) *pn = 10 * *pn + (c - \u0026#39;0\u0026#39;); *pn *= sign; if (c != EOF) ungetch(c); return c; } 在上面的例子中，如果符号+或-的后面紧跟的不是数字，getint 函数将把符号视为数字 0 的有效表达方式。修改该函数，将这种形式的+或-符号重新写回到输入流中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define SIZE 100 #define BUFSIZE 100 char buf[BUFSIZE]; /* buffer for ungetch */ int bufp = 0; /* next free position in buf */ int notdigit = 0; /* flag for not a digit */ /* getint: get next integer from input into *pn */ int getint(int *pn) { notdigit = 0; int c, sign, foundSign; while (isspace(c = getch())) /* skip white space */ ; if (!isdigit(c) \u0026amp;\u0026amp; c != EOF \u0026amp;\u0026amp; c != \u0026#39;+\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;) { notdigit = 1; // 若不是数字，将字符放回输入流，但是下次依然会读取到这个字符，所以需要注释掉ungtch(c) // ungetch(c); /* it is not a number */ return 0; } sign = (c == \u0026#39;-\u0026#39;) ? -1 : 1; if (foundSign = (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;)) c = getch(); if (c != EOF \u0026amp;\u0026amp; !isdigit(c)) { // ungetch(c); if (foundSign) ungetch((sign = -1) ? \u0026#39;-\u0026#39; : \u0026#39;+\u0026#39;); // 将符号放回 return 0; } for (*pn = 0; isdigit(c); c = getch()) *pn = 10 * *pn + (c - \u0026#39;0\u0026#39;); *pn *= sign; if (c != EOF) ungetch(c); return c; } int main() { int n, array[SIZE], getint(int *); for (n = 0; n \u0026lt; SIZE \u0026amp;\u0026amp; getint(\u0026amp;array[n]) != EOF; n++) { if (notdigit) { printf(\u0026#34;Not a number\\n\u0026#34;); continue; } printf(\u0026#34;%d\\n\u0026#34;, array[n]); } } 1 2 3 4 5 6 7 8 9 -1 2 -1 2 s2 Not a number 2 -s2 0 -2 exercise5-2 模仿函数 getint 的实现方法，编写一个读取浮点数的函数 getfloat。getfloat 函数的返回值应该是什么类型？\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int getfloat(float *pn) { notdigit = 0; int c, sign, foundSign; float power; while (isspace(c = getch())) /* skip white space */ ; if (!isdigit(c) \u0026amp;\u0026amp; c != EOF \u0026amp;\u0026amp; c != \u0026#39;+\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;.\u0026#39;) { notdigit = 1; return 0; } sign = (c == \u0026#39;-\u0026#39;) ? -1 : 1; if (foundSign = (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;)) c = getch(); if (c != EOF \u0026amp;\u0026amp; !isdigit(c) \u0026amp;\u0026amp; c != \u0026#39;.\u0026#39;) { if (foundSign) ungetch((sign == -1) ? \u0026#39;-\u0026#39; : \u0026#39;+\u0026#39;); // 将符号放回 return 0; } for (*pn = 0; isdigit(c); c = getch()) *pn = 10 * *pn + (c - \u0026#39;0\u0026#39;); if (c == \u0026#39;.\u0026#39;) c = getch(); for (power = 1.0; isdigit(c); c = getch()) { *pn = 10 * *pn + (c - \u0026#39;0\u0026#39;); power *= 10; } *pn = sign * (*pn / power); if (c != EOF) ungetch(c); return c; } 运行：\n1 2 1.23 1.230000 exercise5-3 用指针方式实现第 2 章中的函数 strcat。函数 strcat(s, t)将 t 指向的字符串复制到 s 指向的字符串的尾部。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #define MAXLINE 1024 /* strcat: 将 t 指向的字符串复制到 s 指向的字符串的尾部 */ void mstrcat(char *s, const char *t) { // 找到 s 的末尾 while (*s) { s++; } // 将 t 的内容复制到 s 的末尾 while (*t) { *s = *t; s++; t++; } // 添加字符串结束符 *s = \u0026#39;\\0\u0026#39;; } int main() { char s[MAXLINE]; char t[MAXLINE]; printf(\u0026#34;Please input S and T:\\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, s); scanf(\u0026#34;%s\u0026#34;, t); mstrcat(s, t); printf(\u0026#34;ans is: %s\\n\u0026#34;, s); return 0; } 运行：\n1 2 3 Please input S and T: abc def ans is: abcdef exercise5-4 编写函数 strend(s, t)。如果字符串 t 出现在字符串 s 的尾部，该函数返回 1；否则返回 0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int strend(const char *s, const char *t) { int i = strlen(s) - 1; int j = strlen(t) - 1; if (j \u0026gt; i) return 0; while (j \u0026gt;= 0) if (s[i--] != t[j--]) return 0; return 1; } int main() { char s[MAXLINE]; char t[MAXLINE]; printf(\u0026#34;Please input S and T:\\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, s); scanf(\u0026#34;%s\u0026#34;, t); if (strend(s, t)) printf(\u0026#34;T appears at the end of S.\\n\u0026#34;); else printf(\u0026#34;T does not appear at the end of S.\\n\u0026#34;); } 运行：\n1 2 3 4 Please input S and T: good o String T does not appear at the end of string S. exercise5-5 实现库函数 strncpy、strncat 和 strncmp，它们最多对参数字符串中的前 n 个字符进行操作。例如，函数 strncpy(s, t, n)将 t 中最多前 n 个字符复制到 s中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* mstrncpy: 将 t 中最多前 n 个字符复制到 s 中 */ char *mstrncpy(char *s, const char *t, int n) { char *ans = s; while (n-- \u0026amp;\u0026amp; (*s++ = *t++)) ; while ((n--) \u0026gt; 0) *s++ = \u0026#39;\\0\u0026#39;; return ans; } /* mstrncat: 将 t 中最多前 n 个字符连接到 s 的末尾 */ char *mstrncat(char *s, const char *t, int n) { char *ans = s; s += strlen(s); while (n-- \u0026amp;\u0026amp; (*s++ = *t++)) ; *s = \u0026#39;\\0\u0026#39;; return ans; } /* mstrncmp: 比较 s 和 t 中最多前 n 个字符 */ int mstrncmp(const char *s, const char *t, int n) { while (n-- \u0026amp;\u0026amp; *s \u0026amp;\u0026amp; (*s++ == *t++)) ; return n == -1 ? 0 : (*s - *t) != 0; } int main() { char s1[MAXLINE] = \u0026#34;gooooood\u0026#34;; char s2[MAXLINE] = \u0026#34;idea\u0026#34;; char s3[MAXLINE] = \u0026#34;good\u0026#34;; int n1 = 4; int result = mstrncmp(s1, s3, n1); printf(\u0026#34;mstrncmp(%s, %s, %d):\\n %d\\n\u0026#34;, s1, s3, n1, result); int n2 = 5; mstrncpy(s1, s3, 5); printf(\u0026#34;mstrncpy(%s, %s, %d):\\n %s\\n\u0026#34;, s1, s3, n2, s1); int n3 = 3; mstrncat(s2, s3, 3); printf(\u0026#34;mstrncat(%s, %s, %d):\\n %s\\n\u0026#34;, s2, s3, n3, s2); return 0; } 运行：\n1 2 3 4 5 6 mstrncmp(gooooood, good, 4): 1 mstrncpy(good, good, 5): good mstrncat(ideagoo, good, 3): ideagoo exercise5-7 重写函数 readlines，将输入的文本行存储到由 main 函数提供的一个数组中，而不是存储到调用 alloc 分配的存储空间中。该函数的运行速度比改写前快多少？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #define MAXLINES 5000 /* max #lines to be sorted */ #define MAXLEN 1000 /* max length of any input line */ char *lineptr[MAXLINES]; /* pointers to text lines */ int Getline(char line[]) { int c, i; for (i = 0; i \u0026lt; MAXLEN - 1 \u0026amp;\u0026amp; (c = getchar()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;; i++) line[i] = c; if (c == \u0026#39;\\n\u0026#39;) { line[i] = c; i++; } line[i] = \u0026#39;\\0\u0026#39;; return i; } /* swap: interchange v[i] and v[j] */ void swap(char *v[], int i, int j) { char *temp; temp = v[i]; v[i] = v[j]; v[j] = temp; } /* qsort: sort v[left]...v[right] into increasing order */ void qsort(char *v[], int left, int right) { int i, last; void swap(char *v[], int i, int j); if (left \u0026gt;= right) /* do nothing if array contains */ return; /* fewer than two elements */ swap(v, left, (left + right) / 2); last = left; for (i = left + 1; i \u0026lt;= right; i++) if (strcmp(v[i], v[left]) \u0026lt; 0) swap(v, ++last, i); swap(v, left, last); qsort(v, left, last - 1); qsort(v, last + 1, right); } /* readlines: read input lines */ int readlines(char *lineptr[], int maxlines) { int len, nlines; char *p, line[MAXLEN]; nlines = 0; while ((len = Getline(line)) \u0026gt; 0) if (nlines \u0026gt;= maxlines || (p = malloc(len)) == NULL) return -1; else { line[len - 1] = \u0026#39;\\0\u0026#39;; /* delete newline */ strcpy(p, line); lineptr[nlines++] = p; } return nlines; } /* writelines: write output lines */ void writelines(char *lineptr[], int nlines) { int i; for (i = 0; i \u0026lt; nlines; i++) printf(\u0026#34;%s\\n\u0026#34;, lineptr[i]); } /* sort input lines */ int main() { int nlines; /* number of input lines read */ printf(\u0026#34;Please input lines:\\n\u0026#34;); if ((nlines = readlines(lineptr, MAXLINES)) \u0026gt;= 0) { qsort(lineptr, 0, nlines - 1); printf(\u0026#34;Sorted lines(sorted by first word):\\n\u0026#34;); writelines(lineptr, nlines); return 0; } else { printf(\u0026#34;error: input too big to sort\\n\u0026#34;); return 1; } } 增加函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int readlines2(char linesarray[][MAXLEN], int maxlines) { int len, nlines; nlines = 0; while ((len = Getline(linesarray[nlines])) \u0026gt; 0) if (nlines \u0026gt;= maxlines) return -1; else linesarray[nlines++][len - 1] = \u0026#39;\\0\u0026#39;; return nlines; } int main(int argc, char *argv[]) { printf(\u0026#34;Please input lines:\u0026#34;); if (argc \u0026gt; 1 \u0026amp;\u0026amp; *argv[1] == \u0026#39;2\u0026#39;) { printf(\u0026#34;(by readlines2):\\n\u0026#34;); int nlines = readlines2(linesarray, MAXLINES); } else { printf(\u0026#34;(by readlines):\\n\u0026#34;); int nlines = readlines(lineptr, MAXLINES); } return 0; } exercise5-8 函数 day_of_year 和 month_day 中没有进行错误检查，请解决该问题。\n对输入的月份、天数进行检查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; static char daytab[2][13] = { {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, }; /* day_of_year: set day of year from month \u0026amp; day */ int day_of_year(int year, int month, int day) { int i, leap; if (month \u0026lt; 1 || month \u0026gt; 12 || day \u0026lt; 1) return -1; leap = year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0 || year % 400 == 0; if (day \u0026gt; daytab[leap][month]) return -1; for (i = 1; i \u0026lt; month; i++) day += daytab[leap][i]; return day; } /* month_day: set month, day from day of year */ int month_day(int year, int yearday, int *pmonth, int *pday) { int i, leap; if (yearday \u0026lt; 1) return -1; leap = year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0 || year % 400 == 0; if ((leap \u0026amp;\u0026amp; yearday \u0026gt; 366) || (!leap \u0026amp;\u0026amp; yearday \u0026gt; 365)) return -1; for (i = 1; yearday \u0026gt; daytab[leap][i]; i++) yearday -= daytab[leap][i]; *pmonth = i; *pday = yearday; return 0; } int main(void) { int year, month, day, yearday; printf(\u0026#34;Test day_of_year()\\nPlease input year, month and day: \u0026#34;); scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;year, \u0026amp;month, \u0026amp;day); yearday = day_of_year(year, month, day); if (yearday == -1) printf(\u0026#34;Wrong date!\\n\u0026#34;); else printf(\u0026#34;%d-%d-%d: the %d day in %d\\n\u0026#34;, year, month, day, yearday, year); printf(\u0026#34;\\nTest month_day()\\nPlease input year and yearday: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;year, \u0026amp;yearday); int ans = month_day(year, yearday, \u0026amp;month, \u0026amp;day); if (ans == -1) printf(\u0026#34;Wrong date!\\n\u0026#34;); else printf(\u0026#34;the %d day in %d: %d-%d-%d\\n\u0026#34;, yearday, year, year, month, day); return 0; } 运行：\n1 2 3 4 5 6 7 Test day_of_year() Please input year, month and day: 2002 10 14 2002-10-14: the 287 day in 2002 Test month_day() Please input year and yearday: 2002 287 the 287 day in 2002: 2002-10-14 exercise5-9 用指针方式代替数组下标方式改写函数 day_of_year 和 month_day。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int day_of_year_ptr(int year, int month, int day) { int i, leap; if (month \u0026lt; 1 || month \u0026gt; 12 || day \u0026lt; 1) return -1; leap = year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0 || year % 400 == 0; char *p = \u0026amp;daytab[leap][1]; if (day \u0026gt; *(p + month - 1)) return -1; for (i = 1; i \u0026lt; month; i++) { day += *p; ++p; } return day; } /* month_day: set month, day from day of year */ int month_day_ptr(int year, int yearday, int *pmonth, int *pday) { int i, leap; if (yearday \u0026lt; 1) return -1; leap = year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0 || year % 400 == 0; if ((leap \u0026amp;\u0026amp; yearday \u0026gt; 366) || (!leap \u0026amp;\u0026amp; yearday \u0026gt; 365)) return -1; char *p = \u0026amp;daytab[leap][1]; for (i = 1; yearday \u0026gt; *p; i++) { yearday -= *p; ++p; } *pmonth = i; *pday = yearday; return 0; } 运行：\n1 2 3 4 5 6 7 Test day_of_year_ptr() Please input year, month and day: 2002 10 14 2002-10-14: the 287 day in 2002 Test month_day_ptr() Please input year and yearday: 2002 287 the 287 day in 2002: 2002-10-14 exercise5-10 编写程序 expr，以计算从命令行输入的逆波兰表达式的值，其中每个运算符或操作数用一个单独的参数表示。例如，命令 expr 2 3 4 + * 将计算表达式 2 × (3 + 4)的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define NUMBER \u0026#39;0\u0026#39; #define MAXVAL 100 /* maximum depth of val stack */ int sp = 0; /* next free stack position */ double val[MAXVAL]; /* value stack */ int isnumber(char *s) { if (strlen(s) == 1 \u0026amp;\u0026amp; (s[0] == \u0026#39;/\u0026#39; || s[0] == \u0026#39;*\u0026#39; || s[0] == \u0026#39;+\u0026#39; || s[0] == \u0026#39;-\u0026#39;)) return s[0]; int i = 0; if (s[i] == \u0026#39;-\u0026#39; || s[i] == \u0026#39;+\u0026#39;) i++; for (; isdigit(s[i]); i++) ; if (s[i] == \u0026#39;.\u0026#39;) i++; for (; isdigit(s[i]); i++) ; return s[i] == \u0026#39;\\0\u0026#39; ? NUMBER : -1; } /* push: push f onto value stack */ void push(double f) { if (sp \u0026lt; MAXVAL) val[sp++] = f; else printf(\u0026#34;error: stack full, can\u0026#39;t push %g\\n\u0026#34;, f); } /* pop: pop and return top value from stack */ double pop(void) { if (sp \u0026gt; 0) return val[--sp]; else { printf(\u0026#34;error: stack empty\\n\u0026#34;); return 0.0; } } int main(int argc, char **argv) { int i; double value; for (i = 1; i \u0026lt; argc; ++i) { switch (isnumber(argv[i])) { case NUMBER: push(atof(argv[i])); break; case \u0026#39;+\u0026#39;: push(pop() + pop()); break; case \u0026#39;-\u0026#39;: value = pop(); push(pop() - value); break; case \u0026#39;*\u0026#39;: push(pop() * pop()); break; case \u0026#39;/\u0026#39;: value = pop(); push(pop() / value); break; default: printf(\u0026#34;wrong argument: %s\\n\u0026#34;, argv[i]); break; } } printf(\u0026#34;%g\\n\u0026#34;, pop()); return 0; } 运行（命令行中，\u0026rsquo;*\u0026lsquo;需要反斜杠来转义）：\n1 2 ➜ ch05 git:(main) ✗ ./Exercise5-10 2 3 4 + \\* 14 exercise5-13 编写程序 tail，将其输入中的最后 n 行打印出来。默认情况下，n 的值为10，但可通过一个可选参数改变 n 的值，因此，命令tail -n将打印其输入的最后 n 行。无论输入或 n 的值是否合理，该程序都应该能正常运行。编写的程序要充分地利用存储空间；输入行的存储方式应该同 5.6 节中排序程序的存储方式一样，而不采用固定长度的二维数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #define MAXLINES 5000 /* max #lines to be sorted */ #define MAXLEN 1000 /* max length of any input line */ char *lineptr[MAXLINES]; /* pointers to text lines */ char linesarray[MAXLINES][MAXLEN]; /*array that store lines*/ int Getline(char line[]) { int c, i; for (i = 0; i \u0026lt; MAXLEN - 1 \u0026amp;\u0026amp; (c = getchar()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;; i++) line[i] = c; if (c == \u0026#39;\\n\u0026#39;) { line[i] = c; i++; } line[i] = \u0026#39;\\0\u0026#39;; return i; } /* readlines: read input lines */ int readlines(char *lineptr[], int maxlines) { int len, nlines; char *p, line[MAXLEN]; nlines = 0; while ((len = Getline(line)) \u0026gt; 0) if (nlines \u0026gt;= maxlines || (p = malloc(len)) == NULL) return -1; else { line[len - 1] = \u0026#39;\\0\u0026#39;; /* delete newline */ strcpy(p, line); lineptr[nlines++] = p; } return nlines; } /* writelines: write output lines */ void writelines(char *lineptr[], int nlines, int n) { int i; for (i = nlines - n \u0026gt; 0 ? nlines - n : 0; i \u0026lt; nlines; i++) printf(\u0026#34;%s\\n\u0026#34;, lineptr[i]); } int main(int argc, char *argv[]) { printf(\u0026#34;Please input lines:\\n\u0026#34;); int nlines = readlines(lineptr, MAXLINES); if (argc \u0026gt; 1 \u0026amp;\u0026amp; argv[1][0] == \u0026#39;-\u0026#39;) { int n = atoi(argv[1] + 1); printf(\u0026#34;The last %d lines are:\\n\u0026#34;, n); writelines(lineptr, nlines, n); } else { printf(\u0026#34;The last 10 lines are:\\n\u0026#34;); writelines(lineptr, nlines, 10); } return 0; } 运行：\n1 2 3 4 5 6 7 8 ➜ ch05 git:(main) ✗ ./Exercise5-13 -2 Please input lines: sdui qi a The last 2 lines are: qi a exercise5-14 修改排序程序，使它能处理-r 标记。该标记表明，以逆序（递减）方式排序。要保证-r 和-n 能够组合在一起使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 int reverse; int mstrcmp(char *s1, char *s2) { char *news1 = reverse ? s2 : s1; char *news2 = reverse ? s1 : s2; return strcmp(news1, news2); } /* numcmp: compare s1 and s2 numerically */ int mnumcmp(char *s1, char *s2) { char *news1 = reverse ? s2 : s1; char *news2 = reverse ? s1 : s2; double v1, v2; v1 = atof(news1); v2 = atof(news2); if (v1 \u0026lt; v2) return -1; else if (v1 \u0026gt; v2) return 1; else return 0; } /* qsort: sort v[left]...v[right] into increasing order */ void mqsort(void *v[], int left, int right, int (*comp)(void *, void *)) { int i, last; if (left \u0026gt;= right) /* do nothing if array contains */ return; /* fewer than two elements */ swap(v, left, (left + right) / 2); last = left; for (i = left + 1; i \u0026lt;= right; i++) if ((*comp)(v[i], v[left]) \u0026lt; 0) swap(v, ++last, i); swap(v, left, last); mqsort(v, left, last - 1, comp); mqsort(v, last + 1, right, comp); } int main(int argc, char *argv[]) { int nlines; /* number of input lines read */ int numeric = 0; /* 1 if numeric sort */ reverse = 0; /* 1 if reverse sort */ if (argc \u0026gt; 1 \u0026amp;\u0026amp; strcmp(argv[1], \u0026#34;-n\u0026#34;) == 0) numeric = 1; if (argc \u0026gt; 2 \u0026amp;\u0026amp; strcmp(argv[2], \u0026#34;-r\u0026#34;) == 0) reverse = 1; printf(\u0026#34;Please input data:\\n\u0026#34;); if ((nlines = readlines(lineptr, MAXLINES)) \u0026gt;= 0) { mqsort((void **)lineptr, 0, nlines - 1, (int (*)(void *, void *))(numeric ? mnumcmp : mstrcmp)); printf(\u0026#34;After sorted:\\n\u0026#34;); writelines(lineptr, nlines); return 0; } else { printf(\u0026#34;input too big to sort\\n\u0026#34;); return 1; } } 运行：\n1 2 3 4 5 6 7 8 9 ➜ ch05 git:(main) ✗ ./Exercise5-14 -n -r Please input data: 76 44 98 After sorted: 98 76 44 exercise5-15 增加选项-f，使得排序过程不考虑字母大小写之间的区别。例如，比较 a 和 A 时认为它们相等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 int mstrcmp(char *s1, char *s2) { char *news1 = reverse ? s2 : s1; char *news2 = reverse ? s1 : s2; return fold == 1 ? strcasecmp(news1, news2) : strcmp(news1, news2); } int main(int argc, char *argv[]) { int nlines; /* number of input lines read */ int numeric = 0; /* 1 if numeric sort */ reverse = 0; /* 1 if reverse sort */ for (int i = 1; i \u0026lt; argc; i++) switch (argv[i][1]) { case \u0026#39;n\u0026#39;: numeric = 1; break; case \u0026#39;r\u0026#39;: reverse = 1; break; case \u0026#39;f\u0026#39;: fold = 1; break; } printf(\u0026#34;Please input data:\\n\u0026#34;); if ((nlines = readlines(lineptr, MAXLINES)) \u0026gt;= 0) { mqsort((void **)lineptr, 0, nlines - 1, (int (*)(void *, void *))(numeric ? mnumcmp : mstrcmp)); printf(\u0026#34;After sorted:\\n\u0026#34;); writelines(lineptr, nlines); return 0; } else { printf(\u0026#34;input too big to sort\\n\u0026#34;); return 1; } } 1 2 3 4 5 6 7 ➜ ch05 git:(main) ✗ ./Exercise5-14 -f Please input data: aB Ab After sorted: aB Ab exercise5-16 增加选项-d（代表目录顺序）。该选项表明，只对字母、数字和空格进行比较。要保证该选项可以和-f 组合在一起使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 int charcmp(char c1, char c2) { if (dir) { if (!isalnum(c1) \u0026amp;\u0026amp; c1 != \u0026#39; \u0026#39;) return 0; if (!isalnum(c2) \u0026amp;\u0026amp; c2 != \u0026#39; \u0026#39;) return 0; } if (fold) { c1 = tolower(c1); c2 = tolower(c2); } return c1 - c2; } int mstrcmp(char *s1, char *s2) { char *news1 = reverse ? s2 : s1; char *news2 = reverse ? s1 : s2; while (*news1 \u0026amp;\u0026amp; *news2) { int cmp = charcmp(*news1, *news2); if (cmp != 0) return cmp; news1++; news2++; } return *news1 ? 1 : (*news2 ? -1 : 0); } /* numcmp: compare s1 and s2 numerically */ int mnumcmp(char *s1, char *s2) { char *news1 = reverse ? s2 : s1; char *news2 = reverse ? s1 : s2; double v1, v2; v1 = atof(news1); v2 = atof(news2); if (v1 \u0026lt; v2) return -1; else if (v1 \u0026gt; v2) return 1; else return 0; } /* qsort: sort v[left]...v[right] into increasing order */ void mqsort(void *v[], int left, int right, int (*comp)(void *, void *)) { int i, last; if (left \u0026gt;= right) /* do nothing if array contains */ return; /* fewer than two elements */ swap(v, left, (left + right) / 2); last = left; for (i = left + 1; i \u0026lt;= right; i++) if ((*comp)(v[i], v[left]) \u0026lt; 0) swap(v, ++last, i); swap(v, left, last); mqsort(v, left, last - 1, comp); mqsort(v, last + 1, right, comp); } int main(int argc, char *argv[]) { int nlines; /* number of input lines read */ int numeric = 0; /* 1 if numeric sort */ reverse = 0; /* 1 if reverse sort */ for (int i = 1; i \u0026lt; argc; i++) switch (argv[i][1]) { case \u0026#39;n\u0026#39;: numeric = 1; break; case \u0026#39;r\u0026#39;: reverse = 1; break; case \u0026#39;f\u0026#39;: fold = 1; break; case \u0026#39;d\u0026#39;: dir = 1; break; } printf(\u0026#34;Please input data:\\n\u0026#34;); if ((nlines = readlines(lineptr, MAXLINES)) \u0026gt;= 0) { mqsort((void **)lineptr, 0, nlines - 1, (int (*)(void *, void *))(numeric ? mnumcmp : mstrcmp)); printf(\u0026#34;After sorted:\\n\u0026#34;); writelines(lineptr, nlines); return 0; } else { printf(\u0026#34;input too big to sort\\n\u0026#34;); return 1; } } 运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ➜ ch05 git:(main) ✗ ./Exercise5-16 -d -f Please input data: A+b a-B After sorted: A+b a-B Please input data: a-B A+b After sorted: a-B A+b exercise5-18 修改 dcl 程序，使它能够处理输入中的错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define MAXTOKEN 100 #define BUFSIZE 100 enum { NAME, PARENS, BRACKETS }; int tokentype; /* type of last token */ char token[MAXTOKEN]; /* last token string */ char name[MAXTOKEN]; /* identifier name */ char datatype[MAXTOKEN]; /* data type = char, int, etc. */ char out[1000]; void dcl(void); void dirdcl(void); /* clear remaining characters in input line to recover from errors */ void clear_input() { int c; while ((c = getch()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c != EOF) ; } /* handle and print error messages */ void errmsg(const char *msg) { printf(\u0026#34;Error: %s\\n\u0026#34;, msg); clear_input(); // Skip to the end of the current line after an error } /* gettoken: return next token */ int gettoken(void) { int c; char *p = token; while ((c = getch()) == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) // Skip whitespace ; if (c == \u0026#39;(\u0026#39;) { if ((c = getch()) == \u0026#39;)\u0026#39;) { strcpy(token, \u0026#34;()\u0026#34;); return tokentype = PARENS; } else { ungetch(c); return tokentype = \u0026#39;(\u0026#39;; } } else if (c == \u0026#39;[\u0026#39;) { for (*p++ = c; (*p++ = getch()) != \u0026#39;]\u0026#39;;) { if (p - token \u0026gt;= MAXTOKEN - 1) // Prevent buffer overflow { errmsg(\u0026#34;brackets too long or unclosed\u0026#34;); return tokentype = -1; } } *p = \u0026#39;\\0\u0026#39;; return tokentype = BRACKETS; } else if (isalpha(c)) { for (*p++ = c; isalnum(c = getch());) { if (p - token \u0026gt;= MAXTOKEN - 1) // Prevent buffer overflow { errmsg(\u0026#34;name too long\u0026#34;); return tokentype = -1; } *p++ = c; } *p = \u0026#39;\\0\u0026#39;; ungetch(c); return tokentype = NAME; } else { return tokentype = c; } } /* dcl: parse a declarator */ void dcl(void) { int ns; for (ns = 0; gettoken() == \u0026#39;*\u0026#39;;) /* count *\u0026#39;s */ ns++; dirdcl(); while (ns-- \u0026gt; 0) strcat(out, \u0026#34; pointer to\u0026#34;); } /* dirdcl: parse a direct declarator */ void dirdcl(void) { int type; if (tokentype == \u0026#39;(\u0026#39;) { dcl(); if (tokentype != \u0026#39;)\u0026#39;) { errmsg(\u0026#34;missing )\u0026#34;); return; } } else if (tokentype == NAME) { strcpy(name, token); } else { errmsg(\u0026#34;expected name or (dcl)\u0026#34;); return; } while ((type = gettoken()) == PARENS || type == BRACKETS) { if (type == PARENS) { strcat(out, \u0026#34; function returning\u0026#34;); } else { strcat(out, \u0026#34; array\u0026#34;); strcat(out, token); strcat(out, \u0026#34; of\u0026#34;); } } } int main() /* convert declaration to words */ { while (gettoken() != EOF) { /* 1st token on line */ strcpy(datatype, token); /* is the datatype */ out[0] = \u0026#39;\\0\u0026#39;; dcl(); /* parse rest of line */ if (tokentype != \u0026#39;\\n\u0026#39;) printf(\u0026#34;syntax error\\n\u0026#34;); printf(\u0026#34;%s: %s %s\\n\u0026#34;, name, out, datatype); } } 运行：\n1 2 3 4 char *func() func: function returning pointer to char char (*func())() func: function returning pointer to function returning char exercise5-19 修改 undcl 程序，使它在把文字描述转换为声明的过程中不会生成多余的圆括号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* undcl: convert word description to declaration */ int undcl(void) { int type; char temp[MAXTOKEN]; int parentheses_needed = 0; // track when parentheses are necessary while (gettoken() != EOF) { strcpy(out, token); // Initialize out with the first token while ((type = gettoken()) != \u0026#39;\\n\u0026#39;) { if (type == PARENS || type == BRACKETS) { strcat(out, token); // Append function or array notation } else if (type == \u0026#39;*\u0026#39;) { // Only add parentheses if needed for precedence (i.e., if out is a function or array) if (parentheses_needed) { sprintf(temp, \u0026#34;(*%s)\u0026#34;, out); parentheses_needed = 0; // reset parentheses flag } else { sprintf(temp, \u0026#34;*%s\u0026#34;, out); // regular pointer, no parentheses needed } strcpy(out, temp); } else if (type == NAME) { sprintf(temp, \u0026#34;%s %s\u0026#34;, token, out); // Add name to out strcpy(out, temp); } else { printf(\u0026#34;invalid input at %s\\n\u0026#34;, token); } } printf(\u0026#34;%s\\n\u0026#34;, out); } return 0; } 运行：\n1 2 x () * [] * () char char (*(*x())[])() exercise5-20 扩展 dcl 程序的功能，使它能够处理包含其它成分的声明，例如带有函数参数类型的声明、带有类似于 const 限定符的声明等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define MAXTOKEN 100 #define BUFSIZE 100 enum { NAME, PARENS, BRACKETS, QUALIFIER, TYPE }; int tokentype; /* type of last token */ char token[MAXTOKEN]; /* last token string */ char name[MAXTOKEN]; /* identifier name */ char datatype[MAXTOKEN]; /* data type = char, int, etc. */ char out[1000]; char buf[BUFSIZE]; /* buffer for ungetch */ int bufp = 0; /* next free position in buf */ void dcl(void); void dirdcl(void); /* get a (possibly pushed-back) character */ int getch(void) { return (bufp \u0026gt; 0) ? buf[--bufp] : getchar(); } /* push character back on input */ void ungetch(int c) { if (bufp \u0026gt;= BUFSIZE) printf(\u0026#34;ungetch: too many characters\\n\u0026#34;); else buf[bufp++] = c; } /* clear remaining characters in input line to recover from errors */ void clear_input() { int c; while ((c = getch()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c != EOF) ; } /* handle and print error messages */ void errmsg(const char *msg) { printf(\u0026#34;Error: %s\\n\u0026#34;, msg); clear_input(); // Skip to the end of the current line after an error } /* gettoken: return next token */ int gettoken(void) { int c; char *p = token; while ((c = getch()) == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) // Skip whitespace ; if (c == \u0026#39;(\u0026#39;) { if ((c = getch()) == \u0026#39;)\u0026#39;) { strcpy(token, \u0026#34;()\u0026#34;); return tokentype = PARENS; } else { ungetch(c); return tokentype = \u0026#39;(\u0026#39;; } } else if (c == \u0026#39;[\u0026#39;) { for (*p++ = c; (*p++ = getch()) != \u0026#39;]\u0026#39;;) { if (p - token \u0026gt;= MAXTOKEN - 1) // Prevent buffer overflow { errmsg(\u0026#34;brackets too long or unclosed\u0026#34;); return tokentype = -1; } } *p = \u0026#39;\\0\u0026#39;; return tokentype = BRACKETS; } else if (isalpha(c)) { for (*p++ = c; isalnum(c = getch());) { if (p - token \u0026gt;= MAXTOKEN - 1) // Prevent buffer overflow { errmsg(\u0026#34;name too long\u0026#34;); return tokentype = -1; } *p++ = c; } *p = \u0026#39;\\0\u0026#39;; ungetch(c); // Handle qualifiers and types like const, volatile if (strcmp(token, \u0026#34;const\u0026#34;) == 0 || strcmp(token, \u0026#34;volatile\u0026#34;) == 0) { return tokentype = QUALIFIER; } return tokentype = NAME; } else { return tokentype = c; } } /* dcl: parse a declarator */ void dcl(void) { int ns; for (ns = 0; gettoken() == \u0026#39;*\u0026#39;;) /* count *\u0026#39;s */ ns++; dirdcl(); while (ns-- \u0026gt; 0) strcat(out, \u0026#34; pointer to\u0026#34;); } /* dirdcl: parse a direct declarator */ void dirdcl(void) { int type; if (tokentype == \u0026#39;(\u0026#39;) { dcl(); if (tokentype != \u0026#39;)\u0026#39;) { errmsg(\u0026#34;missing )\u0026#34;); return; } } else if (tokentype == NAME) { strcpy(name, token); } else { errmsg(\u0026#34;expected name or (dcl)\u0026#34;); return; } while ((type = gettoken()) == PARENS || type == BRACKETS || type == QUALIFIER) { if (type == PARENS) { strcat(out, \u0026#34; function returning\u0026#34;); } else if (type == BRACKETS) { strcat(out, \u0026#34; array\u0026#34;); strcat(out, token); strcat(out, \u0026#34; of\u0026#34;); } else if (type == QUALIFIER) { strcat(out, \u0026#34; \u0026#34;); strcat(out, token); } } } /* parse a function parameter list */ void parse_param_list(void) { while (gettoken() != \u0026#39;)\u0026#39;) { if (tokentype == NAME) { strcat(out, \u0026#34; parameter \u0026#34;); strcat(out, token); } else if (tokentype == \u0026#39;,\u0026#39;) { strcat(out, \u0026#34;, \u0026#34;); } else if (tokentype == QUALIFIER || tokentype == TYPE) { strcat(out, \u0026#34; \u0026#34;); strcat(out, token); } else if (tokentype == \u0026#39;(\u0026#39;) { parse_param_list(); // Recursively handle nested parentheses } else { errmsg(\u0026#34;unexpected token in parameter list\u0026#34;); break; } } } int main() /* convert declaration to words */ { while (gettoken() != EOF) { /* 1st token on line */ strcpy(datatype, token); /* is the datatype */ out[0] = \u0026#39;\\0\u0026#39;; dcl(); /* parse rest of line */ if (tokentype != \u0026#39;\\n\u0026#39;) printf(\u0026#34;syntax error\\n\u0026#34;); printf(\u0026#34;%s: %s %s\\n\u0026#34;, name, out, datatype); } } ","permalink":"https://fireflyyh.top/posts/tcpl/ch05/","summary":"部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。\nexercise5-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int getint(int *pn) { int c, sign; while (isspace(c = getch())) /* skip white space */ ; if (!isdigit(c) \u0026amp;\u0026amp; c != EOF \u0026amp;\u0026amp; c != \u0026#39;+\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;) { ungetch(c); /* it is not a number */ return 0; } sign = (c == \u0026#39;-\u0026#39;) ?","title":"C语言程序设计第二版课后习题--第五章"},{"content":" 部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。代码在gitee上面。\nexercise4-1 编写函数 strindex(s, t)，它返回字符串 t 在 s 中最右边出现的位置。如果 s 中不包含 t，则返回-1。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void getLine(char s[]) { int c, i = 0; while ((c = getchar()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;) s[i++] = c; } int strindex(char s[], char t[]) { int i, j, k; int lens = strlen(s), lent = strlen(t); for (i = lens - 1; i \u0026gt;= 0; i--) { for (j = lent - 1, k = i; j \u0026gt;= 0 \u0026amp;\u0026amp; k \u0026gt;= 0 \u0026amp;\u0026amp; s[k] == t[j]; j--, k--); if (j \u0026lt; 0) return k + 1; } return -1; } int main() { char s[MAXLEN] = {0}; char t[MAXLEN] = {0}; printf(\u0026#34;Please input the string s: \\n\u0026#34;); getLine(s); printf(\u0026#34;Please input the string t: \\n\u0026#34;); getLine(t); printf(\u0026#34;The rightmost position of \u0026#39;%s\u0026#39; in \u0026#39;%s\u0026#39; is: %d\\n\u0026#34;, t, s, strindex(s, t)); return 0; } 运行：\n1 2 3 4 5 Please input the string s: this is an idea, a good idea Please input the string t: idea The rightmost position of \u0026#39;idea\u0026#39; in \u0026#39;this is an idea, a good idea\u0026#39; is: 24 exercise4-2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define MAXLEN 1024 double atof(const char s[]) { double val, power; int i, sign, expSign, exp; for (i = 0; isspace(s[i]); i++) // skip white space ; sign = (s[i] == \u0026#39;-\u0026#39;) ? -1 : 1; if (s[i] == \u0026#39;+\u0026#39; || s[i] == \u0026#39;-\u0026#39;) i++; for (val = 0.0; isdigit(s[i]); i++) val = 10.0 * val + (s[i] - \u0026#39;0\u0026#39;); if (s[i] == \u0026#39;.\u0026#39;) i++; for (power = 1.0; isdigit(s[i]); i++) { val = 10.0 * val + (s[i] - \u0026#39;0\u0026#39;); power *= 10.0; } val = sign * val / power; if (s[i] == \u0026#39;e\u0026#39; || s[i] == \u0026#39;E\u0026#39;) { i++; if (s[i] == \u0026#39;+\u0026#39; || s[i] == \u0026#39;-\u0026#39;) { expSign = (s[i] == \u0026#39;-\u0026#39;) ? -1 : 1; i++; } // 指数 for (exp = 0; isdigit(s[i]); i++) exp = 10 * exp + (s[i] - \u0026#39;0\u0026#39;); if (expSign == 1) while (exp-- \u0026gt; 0) val *= 10; else while (exp-- \u0026gt; 0) val /= 10; } return val; } int main() { char s[MAXLEN] = {0}; printf(\u0026#34;Please input the string s: \\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, s); printf(\u0026#34;%g\\n\u0026#34;, atof(s)); return 0; } 运行：\n1 2 3 Please input the string s: 123e-10 1.23e-08 exercise4-3 在有了基本框架后，对计算器程序进行扩充就比较简单了。在该程序中加入取模（%）运算符，并注意考虑负数的情况。\n若要能够处理负数的情况，则需要在getop()的处理负号时进行进一步判断：需要判断下一个字符是空格还是数字，修改后的getop()如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* getop: get next character or numeric operand */ int getop(char s[]) { int i, c, next; while ((s[0] = c = getch()) == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) ; s[1] = \u0026#39;\\0\u0026#39;; if (!isdigit(c) \u0026amp;\u0026amp; c != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;) return c; /* not a number */ i = 0; if (c == \u0026#39;-\u0026#39;) { next = getch(); if (!isdigit(next) \u0026amp;\u0026amp; next != \u0026#39;.\u0026#39;) { ungetch(next); return c; /* not a number, return \u0026#39;-\u0026#39; */ } c = next; s[++i] = c; } if (isdigit(c)) /* collect integer part */ while (isdigit(s[++i] = c = getch())) ; if (c == \u0026#39;.\u0026#39;) /* collect fraction part */ while (isdigit(s[++i] = c = getch())) ; s[i] = \u0026#39;\\0\u0026#39;; if (c != EOF) ungetch(c); return NUMBER; } 加入取模运算符，则比较简单，与处理 - 与 / 类似：\n1 2 3 4 5 /* +和*无需注意操作数的顺序，即a+b=b+a，但是-/%需要注意 */ case \u0026#39;%\u0026#39;: op2 = pop(); push((int)pop() % (int)op2); break; 运行：\n1 2 3 4 5 Please input expression: 3 2 % 1 3 0 % 3 exercise4-4 在栈操作中添加几个命令，分别用于在不弹出元素的情况下打印栈顶元素；复制栈顶元素；交换栈顶两个元素的值。另外增加一个命令用于清空栈。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* print and return top value from stack without popping */ double top(void) { if (sp \u0026gt; 0) { printf(\u0026#34;Top of stack: %g\\n\u0026#34;, val[sp-1]); return val[sp-1]; } else { printf(\u0026#34;error: stack empty\\n\u0026#34;); return 0.0; } } /* duplicate top value to stack */ void duptop(void) { if (sp \u0026gt; 0) push(val[sp-1]); else printf(\u0026#34;error: stack empty\\n\u0026#34;); } /* swap top two values */ void swaptop(void) { if (sp \u0026gt; 1) { double temp = val[sp-1]; val[sp-1] = val[sp-2]; val[sp-2] = temp; } else printf(\u0026#34;error: not enough elements to swap\\n\u0026#34;); } exercise4-5 给计算器程序增加访问 sin、exp 与 pow 等库函数的操作。有关这些库函数的详细信息，参见附录 B.4 节中的头文件\u0026lt;math.h\u0026gt;。\n引入\u0026lt;math.h\u0026gt;头文件，然后为了编译通过，参考了Undefined reference to pow( ) in C, despite including math.h [duplicate]的解决办法。在main函数中添加了对这三种运算的支持：\n代码：\n1 2 3 4 5 6 7 8 9 10 case \u0026#39;s\u0026#39;: // sin push(sin(pop())); break; case \u0026#39;e\u0026#39;: // exp push(exp(pop())); break; case \u0026#39;p\u0026#39;: // pow op2 = pop(); push(pow(pop(), op2)); break; 运行：\n1 2 3 4 5 6 7 Please input expression: 3 e ans is: 20.085537 2 5 p ans is: 32 3.1415926 s ans is: 5.3589793e-08 exercise4-6 给计算器程序增加处理变量的命令（提供 26 个具有单个英文字母变量名的变量很容易）。增加一个变量存放最近打印的值。\n为了增加处理变量，需要在代码中设置一个变量var来存储上一次计算出来的结果，并使用一个flag来验证该变量是否有效，因为第一次计算时，var是不存在的。增加main函数中的处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #define VAR \u0026#39;v\u0026#39; int getop(char s[]) { ... if (c == \u0026#39;v\u0026#39;) { return VAR; } ... } /* reverse Polish calculator */ int main() { ... switch (type) { // 变量 case VAR: if (flag == 1) push(var); else printf(\u0026#34;error: no variable\\n\u0026#34;); break; // 数值 case NUMBER: push(atof(s)); break; // 操作符 ... // 结束输入 case \u0026#39;\\n\u0026#39;: printf(\u0026#34;ans is:\\t%.8g\\n\u0026#34;, (var = pop())); flag = 1; break; ... } } 运行：\n1 2 3 4 5 6 7 Please input expression: 1 2 + ans is: 3 3 v * ans is: 9 v 3 p ans is: 729 exercise4-7 编写一个函数 ungets(s)，将整个字符串 s 压回到输入中。ungets 函数需要使用 buf 和 bufp 吗？它能否仅使用 ungetch 函数？\n不需要直接使用buf和bufp，可以直接调用ungetch函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* push entire string s back on input */ void ungets(char s[]) { int len = strlen(s); while (len \u0026gt; 0) ungetch(s[--len]); } int main() { char s[] = \u0026#34;goood!\u0026#34;; int c; ungets(s); while ((c = getch()) != EOF) putchar(c); return 0; } 运行：\n1 goood! exercise4-8 假定最多只压回一个字符。请相应地修改 getch 与 ungetch 这两个函数。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int getch(void) { int temp = buf; buf = EOF; if (temp == EOF) temp = getchar(); return temp; } /* push character back on input */ void ungetch(int c) { if (buf != EOF) printf(\u0026#34;ungetch: too many characters\\n\u0026#34;); else buf = c; } exercise4-9 以上介绍的 getch 与 ungetch 函数不能正确地处理压回的 EOF。考虑压回EOF 时应该如何处理？请实现你的设计方案。\nexercise4-8的程序可以正确处理压回的EOF\nexercise4-10 另一种方法是通过 getline 函数读入整个输入行，这种情况下可以不使用 getch 与 ungetch 函数。请运用这一方法修改计算器程序。\n代码（因完整代码过长，故只显示相对于exercise4-6的代码的增加及更改部分）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 char line[MAXLINE]; /* input line */ /* getop: get next character or numeric operand */ int getop(char s[]) { int i, c; while ((s[0] = c = line[idx++]) == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) ; } int Getline() { int c, i; for (i = 0; i \u0026lt; MAXLINE - 1 \u0026amp;\u0026amp; (c = getchar()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;; i++) { line[i] = c; } if (c == \u0026#39;\\n\u0026#39;) line[i++] = c; line[i] = \u0026#39;\\0\u0026#39;; return i; } /* reverse Polish calculator */ int main() { int type; double op2; char s[MAXOP]; while (1) { printf(\u0026#34;Please input expression:\\n\u0026#34;); if (Getline() == 0) break; idx = 0; while ((type = getop(s)) != \u0026#39;\\0\u0026#39;) { ... } } return 0; } 运行：\n1 2 3 4 5 6 7 Please input expression: 1 2 + ans is: 3 Please input expression: 1 v / ans is: 0.33333333 Please input expression: exercise4-11 修改 getop 函数，使其不必使用 ungetch 函数。提示：可以使用一个 static 类型的内部变量解决该问题。\n修改 getop.c，使用一个 static 类型的内部变量来存储多读的字符。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026#34;calc.h\u0026#34; /* getop: get next character or numeric operand */ int getop(char s[]) { /* record the character read last time */ static int lastc = \u0026#39; \u0026#39;; int i, c; while ((s[0] = c = lastc) == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) lastc = getchar(); s[1] = \u0026#39;\\0\u0026#39;; if (!isdigit(c) \u0026amp;\u0026amp; c != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;) return c; /* not a number */ i = 0; if (c == \u0026#39;-\u0026#39;) { if (!isdigit(lastc = getchar()) \u0026amp;\u0026amp; lastc != \u0026#39;.\u0026#39;) return c; /* not a number, return \u0026#39;-\u0026#39; */ s[++i] = c = lastc; } if (isdigit(c)) /* collect integer part */ while (isdigit(s[++i] = c = getchar())) ; if (c == \u0026#39;.\u0026#39;) /* collect fraction part */ while (isdigit(s[++i] = c = getchar())) ; s[i] = \u0026#39;\\0\u0026#39;; lastc = c; return NUMBER; } exercise4-12 运用 printd 函数的设计思想编写一个递归版本的 itoa 函数，即通过递归调用把整数转换为字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void itoa(int n, char s[]) { static int i = 0; // 静态变量，用于记录字符串的当前位置 if (n \u0026lt; 0) { s[i++] = \u0026#39;-\u0026#39;; n = -n; } if (n / 10) itoa(n / 10, s); s[i++] = n % 10 + \u0026#39;0\u0026#39;; s[i] = \u0026#39;\\0\u0026#39;; // 字符串结束符 } int main() { int n; char str[MAXLEN]; printf(\u0026#34;Please input n: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); itoa(n, str); printf(\u0026#34;ans is: %s\\n\u0026#34;, str); } exercise4-13 编写一个递归版本的 reverse(s)函数，以将字符串 s 倒置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void reverse(char s[], int l, int r) { if (l \u0026gt;= r) return; char temp = s[l]; s[l] = s[r]; s[r] = temp; reverse(s, l + 1, r - 1); } int main() { char str[MAXLINE]; printf(\u0026#34;Please input str:\\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, str); reverse(str, 0, strlen(str) - 1); printf(\u0026#34;Reversed string: %s\\n\u0026#34;, str); return 0; } exercise4-14 定义宏 swap(t, x, y）以交换 t 类型的两个参数。（使用程序块结构会对你有所帮助。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; // 一个字节一个字节进行交换 #define swap(t, x, y) \\ do \\ { \\ unsigned char *a = (unsigned char *)(\u0026amp;(x)); \\ unsigned char *b = (unsigned char *)(\u0026amp;(y)); \\ size_t ByteCount = sizeof(t); \\ char temp; \\ while (ByteCount--) \\ { \\ temp = *a; \\ *a = *b; \\ *b = temp; \\ a++; \\ b++; \\ } \\ } while (0) int main() { int ix, iy; double dx, dy; char *cpx, *cpy; ix = 2; iy = 4; printf(\u0026#34;integers before swap: %d and %d\\n\u0026#34;, ix, iy); swap(int, ix, iy); printf(\u0026#34;integers after swap: %d and %d\\n\u0026#34;, ix, iy); dx = 225.1; dy = 417.2; printf(\u0026#34;doubles before swap: %g and %g\\n\u0026#34;, dx, dy); swap(double, dx, dy); printf(\u0026#34;doubles after swap: %g and %g\\n\u0026#34;, dx, dy); cpx = \u0026#34;gooood\u0026#34;; cpy = \u0026#34;idea\u0026#34;; printf(\u0026#34;char pointers before swap: %s and %s\\n\u0026#34;, cpx, cpy); swap(char *, cpx, cpy); printf(\u0026#34;char pointers after swap: %s and %s\\n\u0026#34;, cpx, cpy); return 0; } 1 2 3 4 5 6 integers before swap: 2 and 4 integers after swap: 4 and 2 doubles before swap: 225.1 and 417.2 doubles after swap: 417.2 and 225.1 char pointers before swap: gooood and idea char pointers after swap: idea and gooood ","permalink":"https://fireflyyh.top/posts/tcpl/ch04/","summary":"部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。代码在gitee上面。\nexercise4-1 编写函数 strindex(s, t)，它返回字符串 t 在 s 中最右边出现的位置。如果 s 中不包含 t，则返回-1。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void getLine(char s[]) { int c, i = 0; while ((c = getchar()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;) s[i++] = c; } int strindex(char s[], char t[]) { int i, j, k; int lens = strlen(s), lent = strlen(t); for (i = lens - 1; i \u0026gt;= 0; i--) { for (j = lent - 1, k = i; j \u0026gt;= 0 \u0026amp;\u0026amp; k \u0026gt;= 0 \u0026amp;\u0026amp; s[k] == t[j]; j--, k--); if (j \u0026lt; 0) return k + 1; } return -1; } int main() { char s[MAXLEN] = {0}; char t[MAXLEN] = {0}; printf(\u0026#34;Please input the string s: \\n\u0026#34;); getLine(s); printf(\u0026#34;Please input the string t: \\n\u0026#34;); getLine(t); printf(\u0026#34;The rightmost position of \u0026#39;%s\u0026#39; in \u0026#39;%s\u0026#39; is: %d\\n\u0026#34;, t, s, strindex(s, t)); return 0; } 运行：","title":"C语言程序设计第二版课后习题--第四章"},{"content":" 部分答案参考了网络上的答案和官方题解。代码在gitee上面。\nexercise3-1 在上面有关折半查找的例子中，while 循环语句内共执行了两次测试，其实只要一次就足够（代价是将更多的测试在循环外执行）。重写该函数，使得在循环内部只执行一次测试。比较两种版本函数的运行时间。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; int binsearch(int x, int v[], int n) { int low, mid, high; low = 0; high = n - 1; while (low \u0026lt;= high) { mid = (low + high) / 2; if (x \u0026lt; v[mid]) high = mid - 1; else if (x \u0026gt; v[mid]) low = mid + 1; else return mid; } return -1; } int binsearch2(int x, int v[], int n) { int low, high, mid; low = 0; high = n - 1; mid = (low + high) / 2; while (low \u0026lt;= high \u0026amp;\u0026amp; v[mid] != x) { if (v[mid] \u0026gt; x) high = mid - 1; else low = mid + 1; mid = (low + high) / 2; } if (v[mid] == x) return mid; return -1; /* no match */ } int main() { int n = 200, testtime = 1000000; int data[n]; for (int i = 0; i \u0026lt; n; i++) data[i] = i; int x = n / 2; clock_t start, end; start = clock(); for (int i = 0; i \u0026lt; testtime; i++) binsearch(x, data, n); end = clock(); printf(\u0026#34;binsearch time: %lf seconds\\n\u0026#34;, (double)(end - start) / CLOCKS_PER_SEC); start = clock(); for (int i = 0; i \u0026lt; testtime; i++) binsearch2(x, data, n); end = clock(); printf(\u0026#34;binsearch2 time: %lf seconds\\n\u0026#34;, (double)(end - start) / CLOCKS_PER_SEC); } 运行：\n经过六次测试，在数组元素个数为200，运行次数为100万的条件下，两种方法其实并无多大差异，在六次测试中，优化后的方法消耗时间更少的次数为4次。\nbinsearch binsearch2 0.024170 0.024276 0.024337 0.019407 0.025760 0.020651 0.023006 0.017759 0.022969 0.016554 0.020334 0.025866 exercise3-2 编写一个函数 escape(s, t)，将字符串 t 复制到字符串 s 中，并在复制过程中将换行符、制表符等不可见字符分别转换为\\n、\\t 等相应的可见的转义字符序列。要求使用 swich 语句。再编写一个具有相反功能的函数，在复制过程中将转义字符序列转换为实际字符。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXLENGTH 1024 void getString(char t[]) { int i = 0, c; while ((c = getchar()) != EOF) t[i++] = c; } // 将换行符、制表符等不可见字符分别转换为\\n、\\t 等相应的可见的转义字符序列 void escape(char s[], char t[]) { int len = strlen(t); int i = 0, j = 0; while (i \u0026lt; len) { switch (t[i]) { case \u0026#39;\\n\u0026#39;: s[j++] = \u0026#39;\\\\\u0026#39;; s[j++] = \u0026#39;n\u0026#39;; i++; break; case \u0026#39;\\t\u0026#39;: s[j++] = \u0026#39;\\\\\u0026#39;; s[j++] = \u0026#39;t\u0026#39;; i++; break; case \u0026#39;\\v\u0026#39;: s[j++] = \u0026#39;\\\\\u0026#39;; s[j++] = \u0026#39;v\u0026#39;; i++; break; default: s[j++] = t[i++]; } } } // 将转义字符序列转换为实际字符 void enter(char s[], char t[]) { int len = strlen(t); int i = 0, j = 0; while (i \u0026lt; len) { if (t[i] == \u0026#39;\\\\\u0026#39;) { switch (t[i + 1]) { case \u0026#39;n\u0026#39;: s[j++] = \u0026#39;\\n\u0026#39;; i += 2; break; case \u0026#39;t\u0026#39;: s[j++] = \u0026#39;\\t\u0026#39;; i += 2; break; case \u0026#39;v\u0026#39;: s[j++] = \u0026#39;\\v\u0026#39;; i += 2; break; default: s[j++] = t[i++]; break; } } else { s[j++] = t[i++]; } } } int main() { char s[MAXLENGTH] = {0}, t[MAXLENGTH] = {0}, newt[MAXLENGTH] = {0}; printf(\u0026#34;Please input T(end with EOF):\\n\u0026#34;); getString(t); escape(s, t); printf(\u0026#34;S is:\\n%s\\n\u0026#34;, s); enter(newt, s); printf(\u0026#34;NewT is:\\n%s\\n\u0026#34;, newt); } 运行：\n1 2 3 4 5 6 7 8 Please input t(end with EOF): this is a go od idea S is: this\\tis a \\tgo\\nod idea\\n NewT is: this is a go od idea exercise3-3 编写函数 expand(s1, s2)，将字符串 s1 中类似于 a-z 一类的速记符号在字符串 s2 中扩展为等价的完整列表 abc…xyz。该函数可以处理大小写字母和数字，并可以处理 a-b-c、a-z0-9 与-a-z 等类似的情况。作为前导和尾随的-字符原样排印。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int check(char str[], int idx) { int len = strlen(str); if (idx == 0 || idx == len - 1) return 0; char prev = str[idx - 1]; char next = str[idx + 1]; if ((prev \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; prev \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; next \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; next \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; prev \u0026lt; next) || (prev \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; prev \u0026lt;= \u0026#39;z\u0026#39; \u0026amp;\u0026amp; next \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; next \u0026lt;= \u0026#39;z\u0026#39; \u0026amp;\u0026amp; prev \u0026lt; next) || (prev \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; prev \u0026lt;= \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; next \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; next \u0026lt;= \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; prev \u0026lt; next)) return 1; return 0; } void expand(char s1[], char s2[]) { int len = strlen(s1); int i = 0, j = 0; while (i \u0026lt; len) { if (s1[i] == \u0026#39;-\u0026#39; \u0026amp;\u0026amp; check(s1, i)) { int sublen = s1[i + 1] - s1[i - 1]; for (int k = 1; k \u0026lt; sublen; k++) s2[j++] = s1[i - 1] + k; i++; } else { s2[j++] = s1[i++]; } } printf(\u0026#34;%s\\n\u0026#34;, s2); } int main() { char s1[] = \u0026#34;a-c-e9\u0026#34;; char s2[MAXLINE] = {0}; expand(s1, s2); } 运行：\n1 2 3 Please input s1: a-d-f991-8 s2 is:abcdef991234567 exercise3-4 在数的对二的补码表示中，我们编写的 itoa 函数不能处理最大的负数，即 n 等于 $-2 ^{字长-1}$ 的情况。请解释其原因。修改该函数，使它在任何机器上运行时都能打印出正确的值。\n因为在原来的程序中，对于n为负数的处理：\n1 2 if ((sign = n) \u0026lt; 0) /* record sign */ n = -n; /* make n positive */ 如果 n 为 $-2 ^{字长-1}$ ，那么取n = -n的操作就无法顺利完成，因为 n 最大的正数为 $2 ^{字长-1} - 1$。因此可以修改程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void itoa(int n, char s[]) { int i, sign; long temp = ((sign = n) \u0026lt; 0 ? -n : n); // 使用一个 long 型变量来存储 i = 0; do { /* generate digits in reverse order */ s[i++] = n % 10 + \u0026#39;0\u0026#39;; /* get next digit */ } while ((n /= 10) \u0026gt; 0); /* delete it */ if (sign \u0026lt; 0) s[i++] = \u0026#39;-\u0026#39;; s[i] = \u0026#39;\\0\u0026#39;; reverse(s); } 或不对 n 取反，直接在do while循环内部进行 abs()操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* itoa: convert n to characters in s */ void itoa(int n, char s[]) { int i, sign = n; i = 0; do { s[i++] = abs(n % 10) + \u0026#39;0\u0026#39;; } while (n /= 10); if (sign \u0026lt; 0) s[i++] = \u0026#39;-\u0026#39;; s[i] = \u0026#39;\\0\u0026#39;; reverse(s); } exercise3-5 编写函数 itob(n, s, b)，将整数 n 转换为以 b 为底的数，并将转换结果以字符的形式保存到字符串 s 中。例如，itob(n, s, 16)把整数 n 格式化成十六进制整数保存在 s 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #define MAXLEN 65 char bases[] = \u0026#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; void reverse(char s[]) { int len = strlen(s); int i = 0, j = len - 1; while (i \u0026lt; j) { char temp = s[i]; s[i] = s[j], s[j] = temp; i++, j--; } } void itob(int n, char s[], int b) { int i, sign; if ((sign = n) \u0026lt; 0) n = -n; i = 0; do { s[i++] = bases[n % b]; } while (n /= b); if (sign \u0026lt; 0) s[i++] = \u0026#39;-\u0026#39;; reverse(s); } int main() { int n, b; printf(\u0026#34;Please input n and b: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;b); char s[MAXLEN] = {0}; if (b \u0026lt; 2 || b \u0026gt; 36) { printf(\u0026#34;wrong base!\\n\u0026#34;); return 0; } itob(n, s, b); printf(\u0026#34;%s\\n\u0026#34;, s); } 运行：\n1 2 Please input n and b: 123 11 102 exercise3-6 修改 itoa 函数，使得该函数可以接收三个参数。其中，第三个参数为最小字段宽度。为了保证转换后所得的结果至少具有第三个参数指定的最小宽度，在必要时应在所得结果的左边填充一定的空格。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void reverse(char s[]) { int len = strlen(s); int i = 0, j = len - 1; while (i \u0026lt; j) { char temp = s[i]; s[i] = s[j], s[j] = temp; i++, j--; } } void itob(int n, char s[], int minlen) { int i, sign; if ((sign = n) \u0026lt; 0) n = -n; i = 0; do s[i++] = n % 10 + \u0026#39;0\u0026#39;; while (n /= 10); if (sign \u0026lt; 0) s[i++] = \u0026#39;-\u0026#39;; while (i \u0026lt; minlen) s[i++] = \u0026#39; \u0026#39;; reverse(s); } int main() { int n, minlen; printf(\u0026#34;Please input n and minlen: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;minlen); char s[MAXLEN] = {0}; if (minlen \u0026lt;= 0) { printf(\u0026#34;wrong base!\\n\u0026#34;); return 0; } itob(n, s, minlen); printf(\u0026#34;%s\\n\u0026#34;, s); } 运行：\n1 2 Please input n and minlen: -123 10 -123 ","permalink":"https://fireflyyh.top/posts/tcpl/ch03/","summary":"部分答案参考了网络上的答案和官方题解。代码在gitee上面。\nexercise3-1 在上面有关折半查找的例子中，while 循环语句内共执行了两次测试，其实只要一次就足够（代价是将更多的测试在循环外执行）。重写该函数，使得在循环内部只执行一次测试。比较两种版本函数的运行时间。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.","title":"C语言程序设计第二版课后习题--第三章"},{"content":" 部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。代码在gitee上面。\nexercise2-1 编写一个程序以确定分别由 signed 及 unsigned 限定的 char、short、int 与 long 类型变量的取值范围。采用打印标准头文件中的相应值以及直接计算两种方式实现。后一种方法的实现较困难一些，因为要确定各种浮点类型的取值范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; int main() { printf(\u0026#34;Size of char %d\\n\u0026#34;, CHAR_BIT); printf(\u0026#34;Size of char max %d\\n\u0026#34;, CHAR_MAX); printf(\u0026#34;Size of char min %d\\n\u0026#34;, CHAR_MIN); printf(\u0026#34;Size of short min %d\\n\u0026#34;, SHRT_MIN); printf(\u0026#34;Size of short max %d\\n\u0026#34;, SHRT_MAX); printf(\u0026#34;Size of int min %d\\n\u0026#34;, INT_MIN); printf(\u0026#34;Size of int max %d\\n\u0026#34;, INT_MAX); printf(\u0026#34;Size of long min %ld\\n\u0026#34;, LONG_MIN); printf(\u0026#34;Size of long max %ld\\n\u0026#34;, LONG_MAX); printf(\u0026#34;Size of unsigned char %u\\n\u0026#34;, UCHAR_MAX); printf(\u0026#34;Size of unsigned short %u\\n\u0026#34;, USHRT_MAX); printf(\u0026#34;Size of unsigned int %u\\n\u0026#34;, UINT_MAX); printf(\u0026#34;Size of unsigned long %lu\\n\u0026#34;, ULONG_MAX); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 Size of char 8 Size of char max 127 Size of char min -128 Size of short min -32768 Size of short max 32767 Size of int min -2147483648 Size of int max 2147483647 Size of long min -9223372036854775808 Size of long max 9223372036854775807 Size of unsigned char 255 Size of unsigned short 65535 Size of unsigned int 4294967295 Size of unsigned long 18446744073709551615 exercise2-2 在不使用运算符\u0026amp;\u0026amp;或||的条件下编写一个与上面的 for 循环语句等价的循环语句。\n1 2 for (i = 0; ((i \u0026lt; lim - 1) + ((c = getchar()) != \u0026#39;\\n\u0026#39;) + (c != EOF)) == 3; i++) s[i] = c; 或\n1 2 for (i = 0; i \u0026lt; lim - 1 ? ((c = getchar()) != EOF ? c != \u0026#39;\\n\u0026#39; : 0) : 0; i++) s[i] = c; exercise2-3 编写函数 htoi(s)，把由十六进制数字组成的字符串（包含可选的前缀 0x或 0X）转换为与之等价的整型值。字符串中允许包含的数字包括：0～9、a～f 以及 A～F。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define MAXLINE 1024 int mpow(int a, int b) { int ans = 1; while (b--) ans *= a; return ans; } int calculate(char line[]) { int len = strlen(line), ans = 0; for (int i = 0; i \u0026lt; len; i++) { ans += line[len - 1 - i] * mpow(16, i); } return ans; } int parse(char c) { if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) return c - \u0026#39;0\u0026#39;; if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;f\u0026#39;) return 10 + c - \u0026#39;a\u0026#39;; if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;F\u0026#39;) return 10 + c - \u0026#39;A\u0026#39;; return -1; } int Getline(char line[]) { int len = 0, c, digit; while ((c = getchar()) != \u0026#39;\\n\u0026#39;) { if (len == 1 \u0026amp;\u0026amp; (c == \u0026#39;x\u0026#39; || c == \u0026#39;X\u0026#39;) \u0026amp;\u0026amp; line[0] == 0) { len = 0; continue; } if ((digit = parse(c)) == -1) { printf(\u0026#34;Wrong input!\\n\u0026#34;); return -1; } else { line[len++] = digit; } } line[len] = 0; return len; } int main() { char line[MAXLINE]; while (Getline(line) != -1) { printf(\u0026#34;value is = %d\\n\u0026#34;, calculate(line)); } } 1 2 3 4 5 6 0x43997a7b value is = 1134131835 12345 value is = 74565 98765 value is = 624485 exercise2-4 squeeze(s1, s2)，将字符串 s1 中任何与字符串 s2 中字符匹配的字符都删除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void squeeze(char s1[], char s2[]) { char count[256] = {0}; // 用来记录每个字符是否出现在s2中 int len1 = strlen(s1), len2 = strlen(s2); char ans[len1 + 1]; int i, j; while (len2--) count[s2[len2]] = 1; for (i = 0, j = 0; i \u0026lt; len1; i++) if (count[s1[i]] == 0) s1[j++] = s1[i]; s1[j] = \u0026#39;\\0\u0026#39;; } int main() { char s1[] = \u0026#34;12345 6789\u0026#34;; char s2[] = \u0026#34;24 68\u0026#34;; printf(\u0026#34;s1 = %s\\ns2 = %s\\n\u0026#34;, s1, s2); squeeze(s1, s2); printf(\u0026#34;ans = %s\\n\u0026#34;, s1); } 结果\n1 2 3 s1 = 12345 6789 s2 = 24 68 ans = 13579 exercise2-5 编写函数 any(s1, s2)，将字符串 s2 中的任一字符在字符串 s1 中第一次出现的位置作为结果返回。如果 s1 中不包含 s2 中的字符，则返回-1。（标准库函数 strpbrk 具有同样的功能，但它返回的是指向该位置的指针。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void any(char s1[], char s2[], int pos[]) { // count存储字符在s2中第一次出现的位置， int len1 = strlen(s1), len2 = strlen(s2), count[256]; for (int i = 0; i \u0026lt; 256; i++) count[i] = -1; for (int i = 0; i \u0026lt; len2; i++) if (count[s2[i]] == -1) count[s2[i]] = i; // pos存储s1中每一个字符在s2中第一次出现的位置 // pos大小为s1的元素个数 for (int i = 0; i \u0026lt; len1; i++) pos[i] = count[s1[i]]; } int main() { char s1[] = \u0026#34;abcdefga\u0026#34;; char s2[] = \u0026#34;aceg\u0026#34;; printf(\u0026#34;s1 = %s\\ns2 = %s\\n\u0026#34;, s1, s2); int len = strlen(s1); int pos[len]; for (int i = 0; i \u0026lt; len; i++) pos[i] = -1; any(s1, s2, pos); printf(\u0026#34;s1中每一个字符在s2中第一次出现的位置（按照s1中的下标）：\\n\u0026#34;); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, pos[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } 1 2 3 4 s1 = abcdefga s2 = aceg s1中每一个字符在s2中第一次出现的位置（按照s1中的下标）： 0 -1 1 -1 2 -1 3 0 exercise2-6 编写一个函数 setbits(x, p, n, y)，该函数返回对 x 执行下列操作后的结果值：将 x 中从第 p 位开始的 n 个（二进制）位设置为 y 中最右边 n 位的值，x 的其余 各位保持不变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; unsigned setbits(unsigned x, int p, int n, unsigned y) { // 构建掩码，用于将x中的第p位开始的n位置为0 unsigned mask = ~(~0 \u0026lt;\u0026lt; n) \u0026lt;\u0026lt; (p + 1 - n); // x中从第p位开始的n位置为0 x = x \u0026amp; ~mask; // 取出y中最右边的n位，并将其移到合适的位置 unsigned yn = (y \u0026amp; ~(~0 \u0026lt;\u0026lt; n)) \u0026lt;\u0026lt; (p + 1 - n); return x | yn; } int main() { unsigned x = 0b10101011; unsigned y = 0b00111010; int p = 5; int n = 3; unsigned ans = setbits(x, p, n, y); printf(\u0026#34;setbits(%u(%08b), %d, %d, %u(%08b)) = %d(%08b)\\n\u0026#34;, x, x, p, n, y, y, ans, ans); } 1 setbits(171(10101011), 5, 3, 58(00111010)) = 147(10010011) exercise2-7 编写一个函数 invert(x, p, n)，该函数返回对 x 执行下列操作后的结果值：将 x 中从第 p 位开始的 n 个（二进制）位求反（即，1 变成 0，0 变成 1），x 的其余各位保持不变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; unsigned invert(unsigned x, int p, int n) { // 构建掩码，用于选定从第p位开始的n位 unsigned mask = (~(~0 \u0026lt;\u0026lt; n)) \u0026lt;\u0026lt; (p + 1 - n); // 对选定的位进行求反，并保持其余位不变 return x ^ mask; } int main() { unsigned x = 0b11011001; int p = 4; int n = 3; unsigned ans = invert(x, p, n); printf(\u0026#34;invert(%u(%08b), %d, %d) = %u(%08b)\\n\u0026#34;, x, x, p, n, ans, ans); } 1 invert(217(11011001), 4, 3) = 197(11000101) exercise2-8 编写一个函数 rightrot(x, n)，该函数返回将 x 循环右移（即从最右端移出的位将从最左端移入）n（二进制）位后所得到的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; unsigned rightrot(unsigned x, int n) { // 制作掩码 unsigned mask = (~(~0 \u0026lt;\u0026lt; n) \u0026amp; x) \u0026lt;\u0026lt; (8 - n); // 将x右移n位之后与掩码或操作 return mask | (x \u0026gt;\u0026gt; n); } int main() { unsigned x = 0b00000111; int n = 3; unsigned ans = rightrot(x, n); printf(\u0026#34;rightrot(%u(%08b), %d) = %u(%08b)\\n\u0026#34;, x, x, n, ans, ans); } 1 rightrot(7(00000111), 3) = 224(11100000) exercise2-9 在求对二的补码时，表达式 x \u0026amp;= (x – 1)可以删除 x 中最右边值为 1 的一个二进制位。请解释这样做的道理。用这一方法重写 bitcount 函数，以加快其执行速度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; int bitcount(unsigned x) { int ans = 0; // 不断除去最右边的1，直至变为0 while (x != 0) { x \u0026amp;= (x - 1); ans++; } return ans; } int main() { int x = 0b00100101; int count = bitcount(x); printf(\u0026#34;bitcount(%u(%08b)) = %d\\n\u0026#34;, x, x, count); } 1 bitcount(37(00100101)) = 3 若有变量 x，在其最右边一个 1 之后比特位都为 0，若对其进行减一的操作，则在比特位上的表现为：将最后一个 1 及其右边的比特位全部反转，例如将 $00101000$变成 $00100111$，进行b \u0026amp; (b - 1)操作之后，会将反转的位都变成 0，从而实现了去除最右边一个 1 的操作。\nexercise2-10 重新编写将大写字母转换为小写字母的函数 lower，并用条件表达式替代其中的 if-else 结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXLINE 1024 void lower(char str[]) { int len = strlen(str); for (int i = 0; i \u0026lt; len; i++) { str[i] += (str[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; str[i] \u0026lt;= \u0026#39;Z\u0026#39;) ? \u0026#39;a\u0026#39; - \u0026#39;A\u0026#39; : 0; } } int main() { char str[MAXLINE]; scanf(\u0026#34;%[^\\n]\u0026#34;, str); // 捕获直到换行符 lower(str); printf(\u0026#34;%s\\n\u0026#34;, str); } 1 2 This Is A GOOD idea this is a good idea ","permalink":"https://fireflyyh.top/posts/tcpl/ch02/","summary":"部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。代码在gitee上面。\nexercise2-1 编写一个程序以确定分别由 signed 及 unsigned 限定的 char、short、int 与 long 类型变量的取值范围。采用打印标准头文件中的相应值以及直接计算两种方式实现。后一种方法的实现较困难一些，因为要确定各种浮点类型的取值范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; int main() { printf(\u0026#34;Size of char %d\\n\u0026#34;, CHAR_BIT); printf(\u0026#34;Size of char max %d\\n\u0026#34;, CHAR_MAX); printf(\u0026#34;Size of char min %d\\n\u0026#34;, CHAR_MIN); printf(\u0026#34;Size of short min %d\\n\u0026#34;, SHRT_MIN); printf(\u0026#34;Size of short max %d\\n\u0026#34;, SHRT_MAX); printf(\u0026#34;Size of int min %d\\n\u0026#34;, INT_MIN); printf(\u0026#34;Size of int max %d\\n\u0026#34;, INT_MAX); printf(\u0026#34;Size of long min %ld\\n\u0026#34;, LONG_MIN); printf(\u0026#34;Size of long max %ld\\n\u0026#34;, LONG_MAX); printf(\u0026#34;Size of unsigned char %u\\n\u0026#34;, UCHAR_MAX); printf(\u0026#34;Size of unsigned short %u\\n\u0026#34;, USHRT_MAX); printf(\u0026#34;Size of unsigned int %u\\n\u0026#34;, UINT_MAX); printf(\u0026#34;Size of unsigned long %lu\\n\u0026#34;, ULONG_MAX); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 Size of char 8 Size of char max 127 Size of char min -128 Size of short min -32768 Size of short max 32767 Size of int min -2147483648 Size of int max 2147483647 Size of long min -9223372036854775808 Size of long max 9223372036854775807 Size of unsigned char 255 Size of unsigned short 65535 Size of unsigned int 4294967295 Size of unsigned long 18446744073709551615 exercise2-2 在不使用运算符\u0026amp;\u0026amp;或||的条件下编写一个与上面的 for 循环语句等价的循环语句。","title":"C语言程序设计第二版课后习题--第二章"},{"content":" 部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。代码在gitee上面。\nexercise1-1 在你自己的系统中运行“hello, world”程序。再有意去掉程序中的部分内容，看看会得到什么出错信息。\n1 2 3 main() { printf(\u0026#34;hello world!\u0026#34;); } 除去头文件 不报错且能运行，但是会有警告warning: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration]。\n除去返回类型 不报错且能运行，但是会有警告warning: return type defaults to ‘int’ [-Wimplicit-int]。\nexercise1-2 做个实验，当 printf 函数的参数字符串中包含\\c（其中 c 是上面的转义字符序列中未曾列出的某一个字符）时，观察一下会出现什么情况。\n1 2 3 4 5 6 7 8 9 10 int main(void) { printf(\u0026#34;Experiment\\f to find out what\\f happens when \\fprintf \u0026#39;s argument string contains \\\\c\\n\u0026#34;); printf(\u0026#34;---------\\n\u0026#34;); printf(\u0026#34;Experiment\\v to find out what \\vhappens when printf \u0026#39;s \\vargument string contains \\\\c\\n\u0026#34;); printf(\u0026#34;---------\\n\u0026#34;); printf(\u0026#34;Experiment\\r to find out what \\rhappens when printf \u0026#39;s \\rargument string contains \\\\c\\n\u0026#34;); printf(\u0026#34;---------\\n\u0026#34;); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 Experiment to find out what happens when printf \u0026#39;s argument string contains \\c --------- Experiment to find out what happens when printf \u0026#39;s argument string contains \\c --------- argument string contains \\c --------- exercise1-3 修改温度转换程序，使之能在转换表的顶部打印一个标题\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { float celsius; int fahr = 0, upper = 300, step = 30; printf(\u0026#34;fahr to celsius\\n\u0026#34;); while (fahr \u0026lt;= upper) { celsius = (5.0 / 9) * (fahr - 32); printf(\u0026#34;%5d %6.2f\\n\u0026#34;, fahr, celsius); fahr += step; } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 fahr to celsius 0 -17.78 30 -1.11 60 15.56 90 32.22 120 48.89 150 65.56 180 82.22 210 98.89 240 115.56 270 132.22 300 148.89 exercise1-4 编写一个程序打印摄氏温度转换为相应华氏温度的转换表。\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { float fahr; int celsius = -200, upper = 300, step = 30; printf(\u0026#34;celsius to fahr\\n\u0026#34;); while (celsius \u0026lt;= upper) { fahr = (celsius + 32) * (9.0 / 5); printf(\u0026#34;%5d %6.1f\\n\u0026#34;, celsius, fahr); celsius += step; } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 celsius to fahr -200 -302.4 -170 -248.4 -140 -194.4 -110 -140.4 -80 -86.4 -50 -32.4 -20 21.6 10 75.6 40 129.6 70 183.6 100 237.6 130 291.6 160 345.6 190 399.6 220 453.6 250 507.6 280 561.6 exercise1-5 修改温度转换程序，要求以逆序（即按照从 300 度到 0 度的顺序）打印温度转换表。\n1 2 3 4 5 6 int main() { int fahr; for (fahr = 300; fahr \u0026gt;= 0; fahr = fahr - 20) printf(\u0026#34;%3d %6.1f\\n\u0026#34;, fahr, (5.0 / 9) * (fahr - 32)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 300 148.9 280 137.8 260 126.7 240 115.6 220 104.4 200 93.3 180 82.2 160 71.1 140 60.0 120 48.9 100 37.8 80 26.7 60 15.6 40 4.4 20 -6.7 0 -17.8 exercise1-6 \u0026amp; exercise1-7 编写一个打印 EOF 值的程序\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { int c; // ctrl + D for (;;) { c = getchar(); if (c == EOF) { printf(\u0026#34;Value of EOF is %d.\\n\u0026#34;, c); return 0; } } return 0; } 1 Value of EOF is -1. exercise1-8 编写一个统计空格、制表符与换行符个数的程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; int main() { int c, cb = 0, ct = 0, cn = 0; while ((c = getchar()) != EOF) { switch (c) { case \u0026#39; \u0026#39;: cb++; break; case \u0026#39;\\t\u0026#39;: ct++; break; case \u0026#39;\\n\u0026#39;: cn++; break; default: break; } } printf(\u0026#34;count of blankspace is %d, count of \\\\t is %d, count of \\\\n is %d\\n\u0026#34;, cb, ct, cn ); } 1 2 3 4 yyy yy hh count of blankspace is 3, count of \\t is 2, count of \\n is 3 exercise1-9 编写一个将输入复制到输出的程序，并将其中连续的多个空格用一个空格代替。\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int c, flag = 0; while ((c = getchar()) != EOF) { if (c != \u0026#39; \u0026#39;) { putchar(c); flag = 0; } else if (flag == 0) { putchar(c); // 遇到连续空格中的第一个，就将 flag 置为1 flag = 1; } } } exercise1-10 编写一个将输入复制到输出的程序，并将其中的制表符替换为\\t，把回退符替换为\\b，把反斜杠替按为\\。这样可以将制表符和回退符以可见的方式显示出来。\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { int c, flag = 0; while ((c = getchar()) != EOF) if (c == \u0026#39;\\t\u0026#39;) printf(\u0026#34;\\\\t\u0026#34;); else if (c == \u0026#39;\\b\u0026#39;) printf(\u0026#34;\\\\b\u0026#34;); else if (c == \u0026#39;\\\\\u0026#39;) printf(\u0026#34;\\\\\\\\\u0026#34;); else putchar(c); } 1 2 DCS\\d \\tDCS\\\\d\\t exercise1-11 你准备如何测试单词计数程序？如果程序中存在某种错误，那么什么样的输入最可能发现这类错误呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define IN 1 #define OUT 0 int main() { int c, flag = OUT; int wc = 0; while ((c = getchar()) != EOF) { if (c != \u0026#39; \u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\t\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;) { if (flag == OUT) { wc++; flag = IN; } } else { if (flag == IN) { flag = OUT; } } } printf(\u0026#34;count of word is = %d\\n\u0026#34;, wc); } 1 2 my name is blank! count of word is = 4 只需要将上面exercise1-10的程序进行修改，使用IN和OUT来记录当前遍历的字母的状态：是处于单词内部还是单词外部。如果遇到第一个非空格、换行、制表符字符，则将状态修改为IN，表示进入到了一个单词的内部，如果遇到了第一个上述字符，则将状态修改为OUT。\nexercise1-12 编写一个程序，以每行一个单词的形式打印其输入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define IN 1 #define OUT 0 int main() { int c, flag = OUT; int wc = 0; while ((c = getchar()) != EOF) { if (c != \u0026#39; \u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\t\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;) { if (flag == OUT) { wc++; flag = IN; } putchar(c); } else { if (flag == IN) { flag = OUT; putchar(\u0026#39;\\n\u0026#39;); } } } printf(\u0026#34;wc = %d\\n\u0026#34;, wc); } 1 2 3 4 5 6 my name is blank! my name is blank! wc = 4 只需要将 1-11 的代码稍加修改。\nexercise1-13 编写一个程序，打印输入中单词长度的直方图。水平方向的直方图比较容易绘制，垂直方向的直方图则要困难些。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #define IN 1 #define OUT 0 #define MAXLENGTH 4096 int main() { int c, flag = OUT, counts[MAXLENGTH] = {0}; int l = 0, r = 0; // 分别代表当前单词的左边界和遍历的下标，当遍历到单词的右边界时，把两者相减，得到单词长度。 while ((c = getchar()) != EOF) { if (c != \u0026#39; \u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\t\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;) { if (flag == OUT) { flag = IN; l = r; } } else { if (flag == IN) { flag = OUT; counts[r - l - 1]++; // 将对应的数组元素加一 } } r++; } printf(\u0026#34;length\\tcounts\\n\u0026#34;); for (int i = 0; i \u0026lt; MAXLENGTH; i++) { if (counts[i] != 0) { printf(\u0026#34;%6d\\t\u0026#34;, i + 1); while (counts[i]--) putchar(\u0026#39;#\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } } } 1 2 3 4 5 6 7 8 This is a sad story because I don\u0026#39;t kown why. length counts 1 ## 2 # 3 # 4 ### 5 ## 7 # exercise1-14 编写一个程序，打印输入中各个字符出现频度的直方图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define MAXVALUE 256 int main() { int c, counts[MAXVALUE] = {0}; while ((c = getchar()) != EOF) if (c != \u0026#39; \u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\t\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;) counts[c]++; printf(\u0026#34;character\\tcounts\\n\u0026#34;); for (int i = 0; i \u0026lt; MAXVALUE; i++) { if (counts[i] != 0) { printf(\u0026#34;%9c\\t\u0026#34;, i); while (counts[i]--) putchar(\u0026#39;#\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 This is a sad story because I don\u0026#39;t kown why. character counts \u0026#39; # . # I # T # a ### b # c # d ## e ## h ## i ## k # n ## o ### r # s ##### t ## u # w ## y ## exercise1-15 重新编写 1.2 节中的温度转换程序，使用函数实现温度转换计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 float ctof(float celsius) { return (celsius + 32) * (9.0 / 5); } float ftoc(float fahr) { return (5.0 / 9) * (fahr - 32); } int main() { int fahr = 0, celsius = -200, upper = 300, step = 30; printf(\u0026#34;celsius\\t fahr\\n\u0026#34;); while (celsius \u0026lt;= upper) { printf(\u0026#34;%7d\\t %4.1f\\n\u0026#34;, celsius, ctof(celsius)); celsius += step; } printf(\u0026#34;\\nfahr\\tcelsius\\n\u0026#34;); while (fahr \u0026lt;= upper) { celsius = (5.0 / 9) * (fahr - 32); printf(\u0026#34;%4d\\t%7.2f\\n\u0026#34;, fahr, ftoc(fahr)); fahr += step; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 celsius fahr -200 -302.4 -170 -248.4 -140 -194.4 -110 -140.4 -80 -86.4 -50 -32.4 -20 21.6 10 75.6 40 129.6 70 183.6 100 237.6 130 291.6 160 345.6 190 399.6 220 453.6 250 507.6 280 561.6 fahr celsius 0 -17.78 30 -1.11 60 15.56 90 32.22 120 48.89 150 65.56 180 82.22 210 98.89 240 115.56 270 132.22 300 148.89 exercise1-16 修改打印最长文本行的程序的主程序 main，使之可以打印任意长度的输入行的长度，并尽可能多地打印文本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;stdio.h\u0026gt; #define MAXLINE 4 int Getline(char line[], int maxline); void copy(char to[], char from[]); int main() { int len; int max; char line[MAXLINE]; char longest[MAXLINE]; max = 0; while ((len = Getline(line, MAXLINE)) \u0026gt; 0) if (len \u0026gt; max) { max = len; copy(longest, line); } if (max \u0026gt; 0) printf(\u0026#34;Maxlength is %d\\n and the content that can be printed is: %s\\n\u0026#34;, max, longest); return 0; } int Getline(char s[], int lim) { // i存放输入的长度，j存放接受的长度 int c, i, j; for (i = 0, j = 0; (c = getchar()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;; ++i) { if (j \u0026lt; lim - 1) s[j++] = c; } if (c == \u0026#39;\\n\u0026#39;) { if (j \u0026lt; lim - 1) { s[j] = \u0026#39;\\n\u0026#39;; j++; } i++; } s[j] = \u0026#39;\\0\u0026#39;; return i; } void copy(char to[], char from[]) { int i; i = 0; while ((to[i] = from[i]) != \u0026#39;\\0\u0026#39;) ++i; } 1 2 3 this is a happy game Maxlength is 21 and the content that can be printed is thi exercise1-17 编写一个程序，打印长度大于 80 个字符的所有输入行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; #define MINLINE 80 // 符合打印要求的最小字符数（包含\\n） #define MAXLINE 1024 // 每一行的最大字符数（包含\\n） int Getline(char line[]) { int c, i; for (i = 0; i \u0026lt; MAXLINE - 1 \u0026amp;\u0026amp; (c = getchar()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;; i++) line[i] = c; // 退出循环：字符限制 || 文件末尾 || 行末尾 // 如果c==\u0026#39;\\n\u0026#39;，说明以上的遍历没有达到字符限制 // 否则，则需要立刻结束遍历，将结尾置为\u0026#39;\\0\u0026#39; if (c == \u0026#39;\\n\u0026#39;) { line[i] = c; i++; } line[i] = \u0026#39;\\0\u0026#39;; return i; } int main() { int len; char line[MAXLINE]; while ((len = Getline(line)) != 0) if (len \u0026gt; MINLINE) printf(\u0026#34;%s\u0026#34;, line); } 为了便于展示，将打印长度大于 4 个字符（包含\\n）的所有输入行：\n1 2 3 4 5 6 7 8 this this is a goood goood game game exercise1-18 编写一个程序，删除每个输入行末尾的空格及制表符，并删除完全是空格的行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int handler(char line[], int len) { int flag = line[len - 2] == \u0026#39;\\n\u0026#39; ? 1 : 0; // 用来判断本行是否含有\\n int i = len - 2 - flag; for (; i \u0026gt;= 0 \u0026amp;\u0026amp; (line[i] == \u0026#39;\\t\u0026#39; || line[i] == \u0026#39; \u0026#39;); i--); if (flag) { line[++i] = \u0026#39;\\n\u0026#39;; } line[++i] = \u0026#39;\\0\u0026#39;; return i; // 返回实际长度 } int main() { char line[MAXLINE], len, newlen; while ((len = Getline(line)) \u0026gt; 0) { newlen = handler(line, len); printf(\u0026#34;len = %d, str = \\\u0026#34;%s\\\u0026#34;, newlen = %d\\n\u0026#34;, len, line, newlen); } } 1 2 3 4 5 6 goo ood len = 8, str = \u0026#34;goo ood\u0026#34;, newlen = 7 len = 2, str = \u0026#34;\u0026#34;, newlen = 0 wyu len = 6, str = \u0026#34; wyu\u0026#34;, newlen = 5 NOTE 为了简化报告，省去了头文件，且下文所使用的所有Getline(line)函数均为\n1 2 3 4 5 6 7 8 9 10 int Getline(char line[]) { int c, i; for (i = 0; i \u0026lt; MAXLINE - 1 \u0026amp;\u0026amp; (c = getchar()) != EOF \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;; i++) { line[i] = c; } if (c == \u0026#39;\\n\u0026#39;) line[i++] = c; line[i] = \u0026#39;\\0\u0026#39;; return i; } exercise1-19 编写函数 reverse(s)，将字符串 s 中的字符顺序颠倒过来。使用该函数编写一个程序，每次颠倒一个输入行中的字符顺序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void reverse(char line[], int len) { int flag = line[len - 2] == \u0026#39;\\n\u0026#39; ? 1 : 0; // 用来判断本行是否含有\\n int r = len - 2 - flag, l = 0; while (l \u0026lt; r) { char temp = line[r]; line[r] = line[l]; line[l] = temp; l++; r--; } } int main() { char line[MAXLINE], len; while ((len = Getline(line)) \u0026gt; 0) { reverse(line, len); printf(\u0026#34;%s\u0026#34;, line); } } 1 2 hello, everyone! !enoyreve ,olleh exercise1-20 编写程序 detab，将输入中的制表符替换成适当数目的空格，使空格充满到下一个制表符终止位的地方。假设制表符终止位的位置是固定的，比如每隔 n 列就会出现一个制表符终止位。n 应该作为变量还是符号常量呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define TABLEN 8 void detab(char dest[], char src[], int len) { // 分别记录在src、dest中的下标 int i = 0, j = 0; while (i \u0026lt; len \u0026amp;\u0026amp; src[i] != \u0026#39;\\n\u0026#39;) { if (src[i] != \u0026#39;\\t\u0026#39;) { dest[j] = src[i]; j++; } else { // 计算还有多少字符到达下一个制表位 int count = TABLEN - (j % TABLEN); // 替换为空格 while (count--) // 为了显示清楚，用^代替空格 dest[j++] = \u0026#39;^\u0026#39;; } i++; } dest[j] = \u0026#39;\\0\u0026#39;; } int main() { int len; char src[MAXLINE], dest[MAXLINE]; while ((len = Getline(src)) \u0026gt; 0) { detab(dest, src, len); printf(\u0026#34;%s\\n\u0026#34;, dest); } } 为了为了显示清楚，用^代替空格\n1 2 hi every one! hi^^^^^^every^^^one! n 应该作为符号变量\nexercise1-21 编写程序 entab，将空格串替换为最少数量的制表符和空格，但要保持单词之间的间隔不变。假设制表符终止位的位置与练习 1-20 的 detab 程序的情况相同。当使用一个制表符或者一个空格都可以到达下一个制表符终止位时，选用哪一种替换字符比较好？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #define TABLEN 8 int entab(char dest[], char src[], int len) { int count = 0; for (int i = 0; i \u0026lt; len; i++) { if (src[i] == \u0026#39; \u0026#39;) count++; else count = 0; if (count == TABLEN) { i -= (TABLEN - 1); len -= (TABLEN - 1); // 为了显示效果，用^替代\\t src[i] = \u0026#39;^\u0026#39;; for (int t = i + 1; t \u0026lt; len; t++) src[t] = src[t + (TABLEN - 1)]; count = 0; src[len] = \u0026#39;\\0\u0026#39;; } } printf(\u0026#34;%s\u0026#34;, src); return 0; } int main() { char src[MAXLINE], dest[MAXLINE]; int len; while ((len = Getline(src)) \u0026gt; 0) { entab(dest, src, len); } } 当使用一个制表符或者一个空格都可以到达下一个制表符终止位时，选用一个制表符比较好，能保持对齐一致性。\nexercise1-22 编写一个程序，把较长的输入行“折”成短一些的两行或多行，折行的位置在输入行的第 n 列之前的最后一个非空格之后。要保证程序能够智能地处理输入行很长以及在指定的列前没有空格或制表符时的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #define FOLDLEN 8 int handler(char src[], int len) { if (len \u0026lt; FOLDLEN) { } else { // foldloc 用来记录折断的位置 int foldloc = FOLDLEN - 1; // 循环退出条件为遍历到最后一个字符 while (foldloc \u0026lt; len) { int i = 0; // 从后往前寻找第一个非空格，或者该段全为空格 for (; i \u0026lt; FOLDLEN; i++) if (src[foldloc - i] != \u0026#39; \u0026#39;) break; if (i != FOLDLEN) foldloc = foldloc - i + 1; src[foldloc] = \u0026#39;\\n\u0026#39;; foldloc += FOLDLEN; } } printf(\u0026#34;%s\\n\u0026#34;, src); return 0; } int main() { char src[MAXLINE]; int len; while ((len = Getline(src)) \u0026gt; 0) handler(src, len); } 1 2 3 4 5 this is also a goooood subject. this is also a g ooood su ject. exercise1-23 编写一个删除 C 语言程序中所有的注释语句。要正确处理带引号的字符串与字符常量。在 C 语言中，注释不允许嵌套。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;stdio.h\u0026gt; #define MAXLINE 1024 #define CONTENT 0 // 内容 #define QUOTE 1 // 引号内 #define BLOCKCOMMENT 2 // 块注释 #define LINECOMMENT 3 // 行注释 int state; /* 能够正确运行的前提是要处理的C程序本身无语法错误 且没有注释嵌套 块注释的优先级大于行注释 */ enum { CONTENT, // 内容 QUOTE, // 引号内 BLOCKCOMMENT, // 块注释 LINECOMMENT // 行注释 }; int state; /* 能够正确运行的前提是要处理的C程序本身无语法错误 且没有注释嵌套 块注释的优先级大于行注释 */ void handler(char src[], int len) { int t = 0; while (t \u0026lt; len) { // 进入与离开引号 if (src[t] == \u0026#39;\u0026#34;\u0026#39;) { if (state == QUOTE) state = CONTENT; else state = QUOTE; } if (state != QUOTE) { // 进入块注释 if (src[t] == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; src[t + 1] == \u0026#39;*\u0026#39;) { t += 2; state = BLOCKCOMMENT; } // 离开块注释 if (src[t] == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; src[t + 1] == \u0026#39;/\u0026#39;) { t += 2; state = CONTENT; } // 进入行注释 if (src[t] == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; src[t + 1] == \u0026#39;/\u0026#39;) { t += 2; state = LINECOMMENT; } // 到达行末尾，检测是否该行为行注释 if (src[t] == \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; state == LINECOMMENT) { state = CONTENT; } // 如果为注释内，则跳过该字符 if (state == BLOCKCOMMENT || state == LINECOMMENT) { t++; } else { printf(\u0026#34;%c\u0026#34;, src[t]); t++; } } else { printf(\u0026#34;%c\u0026#34;, src[t]); t++; } } } int main() { char src[MAXLINE]; int len; state = CONTENT; while ((len = Getline(src)) \u0026gt; 0) handler(src, len); } 设有一个测试文件test.c，内容为下：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; /* TEST */ // uwey int main() { printf(\u0026#34;aosi/*123*/\u0026#34;); //sdui } 执行命令：./Exercise1-23 \u0026lt;test.c，将test.c的文件内容作为输入，得到下面的结果：\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;aosi/*123*/\u0026#34;); } exercise1-24 编写一个程序，查找 C 语言程序中的基本语法错误，如圆括号、方括号、花括号不配对等。要正确处理引号（包括单引号和双引号）、转义字符序列与注释。（如果读者想把该程序编写成完全通用的程序，难度会比较大。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 typedef struct { char stack[MAXLINE]; int top; } Stack; Stack stack; int inSingleQuote = 0, inDoubleQuote = 0, inComment = 0; void initStack(Stack *s) { s-\u0026gt;top = -1; } int isFull(Stack *s) { return s-\u0026gt;top == MAXLINE - 1; } int isEmpty(Stack *s) { return s-\u0026gt;top == -1; } void push(Stack *s, char c) { if (!isFull(s)) { s-\u0026gt;stack[++s-\u0026gt;top] = c; } } char pop(Stack *s) { if (!isEmpty(s)) { return s-\u0026gt;stack[s-\u0026gt;top--]; } return \u0026#39;\\0\u0026#39;; } int matchingBrackets(char opening, char closing) { return (opening == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; closing == \u0026#39;)\u0026#39;) || (opening == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; closing == \u0026#39;]\u0026#39;) || (opening == \u0026#39;{\u0026#39; \u0026amp;\u0026amp; closing == \u0026#39;}\u0026#39;); } int handler(char line[], int len) { int i = 0; while (i \u0026lt; len) { char c = line[i]; if (inComment) { if (c == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; line[i + 1] == \u0026#39;/\u0026#39;) { inComment = 0; i++; } } else if (inSingleQuote) { if (c == \u0026#39;\\\u0026#39;\u0026#39; \u0026amp;\u0026amp; (i == 0 || line[i - 1] != \u0026#39;\\\\\u0026#39;)) { inSingleQuote = 0; } } else if (inDoubleQuote) { if (c == \u0026#39;\u0026#34;\u0026#39; \u0026amp;\u0026amp; (i == 0 || line[i - 1] != \u0026#39;\\\\\u0026#39;)) { inDoubleQuote = 0; } } else { if (c == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; line[i + 1] == \u0026#39;*\u0026#39;) { inComment = 1; i++; } else if (c == \u0026#39;\\\u0026#39;\u0026#39;) { inSingleQuote = 1; } else if (c == \u0026#39;\u0026#34;\u0026#39;) { inDoubleQuote = 1; } else if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { push(\u0026amp;stack, c); } else if (c == \u0026#39;)\u0026#39; || c == \u0026#39;]\u0026#39; || c == \u0026#39;}\u0026#39;) { if (isEmpty(\u0026amp;stack) || !matchingBrackets(pop(\u0026amp;stack), c)) { printf(\u0026#34;Syntax error: unmatched %c at position %d\\n\u0026#34;, c, i); return 1; } } } i++; } } int main() { initStack(\u0026amp;stack); char line[MAXLINE]; int len; while ((len = Getline(line)) \u0026gt; 0) handler(line, len); if (!isEmpty(\u0026amp;stack)) { printf(\u0026#34;Syntax error: unmatched %c\\n\u0026#34;, stack.stack[stack.top]); return 0; } printf(\u0026#34;No syntax errors found.\\n\u0026#34;); return 0; } 设有一个 test.c 文件，内容为\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; /* TEST */ // uwey int main() { printf(\u0026#34;aosi/*123*/\u0026#34;); //sdui 通过运行./Exercise1-24 \u0026lt;test.c，结果如下：\n1 Syntax error: unmatched { 检测到了缺少花括号\n","permalink":"https://fireflyyh.top/posts/tcpl/ch01/","summary":"部分答案参考了官方题解和网上的答案，仅供参考，可能也有部分bug未发现或解决。代码在gitee上面。\nexercise1-1 在你自己的系统中运行“hello, world”程序。再有意去掉程序中的部分内容，看看会得到什么出错信息。\n1 2 3 main() { printf(\u0026#34;hello world!\u0026#34;); } 除去头文件 不报错且能运行，但是会有警告warning: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration]。\n除去返回类型 不报错且能运行，但是会有警告warning: return type defaults to ‘int’ [-Wimplicit-int]。\nexercise1-2 做个实验，当 printf 函数的参数字符串中包含\\c（其中 c 是上面的转义字符序列中未曾列出的某一个字符）时，观察一下会出现什么情况。\n1 2 3 4 5 6 7 8 9 10 int main(void) { printf(\u0026#34;Experiment\\f to find out what\\f happens when \\fprintf \u0026#39;s argument string contains \\\\c\\n\u0026#34;); printf(\u0026#34;---------\\n\u0026#34;); printf(\u0026#34;Experiment\\v to find out what \\vhappens when printf \u0026#39;s \\vargument string contains \\\\c\\n\u0026#34;); printf(\u0026#34;---------\\n\u0026#34;); printf(\u0026#34;Experiment\\r to find out what \\rhappens when printf \u0026#39;s \\rargument string contains \\\\c\\n\u0026#34;); printf(\u0026#34;---------\\n\u0026#34;); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 Experiment to find out what happens when printf \u0026#39;s argument string contains \\c --------- Experiment to find out what happens when printf \u0026#39;s argument string contains \\c --------- argument string contains \\c --------- exercise1-3 修改温度转换程序，使之能在转换表的顶部打印一个标题","title":"C语言程序设计第二版课后习题--第一章"},{"content":"阿里云 尝试使用windows客户端登录阿里云服务器，参考了10分钟手把手教你通过SSH，使用密钥/账号远程登录Linux服务器（Windows/macOS）\n客户端生成密钥 进入到C:\\Users\\用户名\\.ssh目录下，若没有公钥和私钥文件，则进行生成。\n执行ssh-keygen命令，之后一路回车，然后在该目录下会出现ida_rsa和ida_rsa.pub两个文件，分别存放私钥和公钥。\n部署公钥 使用密码登录服务器，在用户目录下进入到.ssh文件夹，创建或编辑authorized_keys文件，将上一步获得的公钥内容复制并追加到该文件中。\n中科大vlab Vlab实验中心，参考帮助文档\n下载私钥 进入到管理界面，下载私钥vlab-vm9164.pem。\n本地配置 将该私钥文件放置到本地C:\\Users\\用户名\\.ssh文件夹之下，并重命名为vlab.pem。\n然后即可以在 cmd 中使用ssh -i ~/.ssh/vlab.pem ubuntu@vlab.ustc.edu.cn来登录到远程主机。\n配置文件 如果需要使用vscode来进行操作，则可以使用SSH配置文件。进入到C:\\Users\\用户名\\.ssh文件夹之下，创建或编辑config文件。然后最好使用 vscode 打开该文件并编辑，追加以下内容：\n1 2 3 4 Host vlab HostName vlab.ustc.edu.cn User ubuntu IdentityFile ~/.ssh/vlab.pem 之后在vscode中就可以方便地进行连接了。\n","permalink":"https://fireflyyh.top/posts/linux/ssh/","summary":"阿里云 尝试使用windows客户端登录阿里云服务器，参考了10分钟手把手教你通过SSH，使用密钥/账号远程登录Linux服务器（Windows/macOS）\n客户端生成密钥 进入到C:\\Users\\用户名\\.ssh目录下，若没有公钥和私钥文件，则进行生成。\n执行ssh-keygen命令，之后一路回车，然后在该目录下会出现ida_rsa和ida_rsa.pub两个文件，分别存放私钥和公钥。\n部署公钥 使用密码登录服务器，在用户目录下进入到.ssh文件夹，创建或编辑authorized_keys文件，将上一步获得的公钥内容复制并追加到该文件中。\n中科大vlab Vlab实验中心，参考帮助文档\n下载私钥 进入到管理界面，下载私钥vlab-vm9164.pem。\n本地配置 将该私钥文件放置到本地C:\\Users\\用户名\\.ssh文件夹之下，并重命名为vlab.pem。\n然后即可以在 cmd 中使用ssh -i ~/.ssh/vlab.pem ubuntu@vlab.ustc.edu.cn来登录到远程主机。\n配置文件 如果需要使用vscode来进行操作，则可以使用SSH配置文件。进入到C:\\Users\\用户名\\.ssh文件夹之下，创建或编辑config文件。然后最好使用 vscode 打开该文件并编辑，追加以下内容：\n1 2 3 4 Host vlab HostName vlab.ustc.edu.cn User ubuntu IdentityFile ~/.ssh/vlab.pem 之后在vscode中就可以方便地进行连接了。","title":"SSH密钥登陆"},{"content":"TLPI 22.4：处理由硬件产生的信号 代码（为网站上获取） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #define _GNU_SOURCE /* Get strsignal() declaration from \u0026lt;string.h\u0026gt; */ #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026#34;tlpi_hdr.h\u0026#34; /* SIGFPE信号处理器函数 */ static void sigfpeCatcher(int sig) { printf(\u0026#34;Caught signal %d (%s)\\n\u0026#34;, sig, strsignal(sig)); sleep(1); /* Slow down execution of handler */ } int main(int argc, char *argv[]) { /* 参数有三种选择， 第一种，无参数，为捕获信号并进入处理器函数 第二种，-i，为忽略信号 第三种，-b，为阻塞信号 */ if (argc \u0026gt; 1 \u0026amp;\u0026amp; strchr(argv[1], \u0026#39;i\u0026#39;) != NULL) { // strchr用于查找第一次出现\u0026#39;i\u0026#39;的位置，并返回以其为首的字符串 printf(\u0026#34;Ignoring SIGFPE\\n\u0026#34;); if (signal(SIGFPE, SIG_IGN) == SIG_ERR) // i-忽略SIGFPE errExit(\u0026#34;signal\u0026#34;); } else { printf(\u0026#34;Catching SIGFPE\\n\u0026#34;); struct sigaction sa; sigemptyset(\u0026amp;sa.sa_mask); // 不阻塞任何信号 sa.sa_flags = SA_RESTART; // 自动重启 sa.sa_handler = sigfpeCatcher; if (sigaction(SIGFPE, \u0026amp;sa, NULL) == -1) errExit(\u0026#34;sigaction\u0026#34;); } bool blocking = argc \u0026gt; 1 \u0026amp;\u0026amp; strchr(argv[1], \u0026#39;b\u0026#39;) != NULL; // b-阻塞信号 sigset_t prevMask; if (blocking) { printf(\u0026#34;Blocking SIGFPE\\n\u0026#34;); sigset_t blockSet; sigemptyset(\u0026amp;blockSet); sigaddset(\u0026amp;blockSet, SIGFPE); if (sigprocmask(SIG_BLOCK, \u0026amp;blockSet, \u0026amp;prevMask) == -1) errExit(\u0026#34;sigprocmask\u0026#34;); } printf(\u0026#34;About to generate SIGFPE\\n\u0026#34;); // 准备生成SIGFPE int x, y; y = 0; x = 1 / y; // 除零操作，生成SIGFPE y = x; /* Avoid complaints from \u0026#34;gcc -Wunused-but-set-variable\u0026#34; */ if (blocking) { printf(\u0026#34;Sleeping before unblocking\\n\u0026#34;); sleep(2); printf(\u0026#34;Unblocking SIGFPE\\n\u0026#34;); if (sigprocmask(SIG_SETMASK, \u0026amp;prevMask, NULL) == -1) errExit(\u0026#34;sigprocmask\u0026#34;); } printf(\u0026#34;Shouldn\u0026#39;t get here!\\n\u0026#34;); exit(EXIT_FAILURE); } 解释 根据参数，进行后续步骤：\n若无参数，则直接为其建立信号处理器函数，内容为打印出相关信息； 若为-i，则为忽略 SIGFPE 信号，使用signal(SIGFPE, SIG_IGN)这行代码来忽略浮点数异常； 若为-b，则为阻塞信号，先将 SIGFPE 放入信号掩码，然后在错误的浮点数运算之后取消阻塞 运行结果 默认情况 默认情况下：\n1 2 3 4 5 6 7 8 9 10 Catching SIGFPE About to generate SIGFPE Caught signal 8 (Floating point exception) Caught signal 8 (Floating point exception) Caught signal 8 (Floating point exception) Caught signal 8 (Floating point exception) Caught signal 8 (Floating point exception) Caught signal 8 (Floating point exception) Caught signal 8 (Floating point exception) ^\\[1] 116013 quit ./DEMO_SIGFPE 在除零操作之后，产生异常，产生了 SIGFPE 信号，将其捕获，打印信息，并睡眠1s。 运行结果不断出现信息的原因是，在退出信号处理器函数之后，程序又回到终端出重新运行，在本程序中，将会不断地重新进行除零操作，从而不断产生异常。\n忽略信号 在这种情况下：\n1 2 3 Ignoring SIGFPE About to generate SIGFPE [1] 113466 floating point exception ./DEMO_SIGFPE -i 结果表明，并没有成功忽略该信号，这也验证了 TLPI 中的描述：\n当由于硬件异常而产生上述信号之一时，Linux 会强制传递 信号，即使程序已经请求忽略此类信号。\n阻塞信号 在这种情况下：\n1 2 3 Blocking SIGFPE About to generate SIGFPE [1] 116212 floating point exception ./DEMO_SIGFPE -b 同样地，也并没有阻塞该信号。\n始于 Linux 2.6，如果信号遭到阻塞，那么该信号总是会立刻杀死进程，即使进程已经为此信号安装了处理器函数。\n","permalink":"https://fireflyyh.top/posts/tlpi/demo_sigfpe/","summary":"TLPI 22.4：处理由硬件产生的信号 代码（为网站上获取） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #define _GNU_SOURCE /* Get strsignal() declaration from \u0026lt;string.","title":"硬件产生的信号"},{"content":"TLPI 21.1.2: 可重入函数和异步信号安全函数 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #define _XOPEN_SOURCE 600 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;crypt.h\u0026gt; #include \u0026#34;tlpi_hdr.h\u0026#34; static char *str2; static int handled = 0; // 设置处理器函数，一旦遇上SIGINT，便对str2进行加密 static void handler(int sig) { crypt(str2, \u0026#34;xx\u0026#34;); handled++; } int main(int argc, char *argv[]) { char *cr1; int callNum, mismatch; struct sigaction sa; if (argc != 3) usageErr(\u0026#34;%s str1 str2\\n\u0026#34;, argv[0]); str2 = argv[2]; // 对str1进行加密，并将结果保存到独立缓冲区中 cr1 = strdup(crypt(argv[1], \u0026#34;xx\u0026#34;)); if (cr1 == NULL) errExit(\u0026#34;strdup\u0026#34;); sigemptyset(\u0026amp;sa.sa_mask); // 初始化在执行处理器函数时将阻塞的信号 sa.sa_flags = 0; // 即sa.sa_flags = SIG_BLOCK sa.sa_handler = handler; // 设置信号处理器函数的地址 if (sigaction(SIGINT, \u0026amp;sa, NULL) == -1) errExit(\u0026#34;sigaction\u0026#34;); for (callNum = 1, mismatch = 0; ; callNum++) { if (strcmp(crypt(argv[1], \u0026#34;xx\u0026#34;), cr1) != 0) { mismatch++; printf(\u0026#34;Mismatch on call %d (mismatch=%d handled=%d)\\n\u0026#34;, callNum, mismatch, handled); } } } 解释 crypt() 需要加入#include \u0026lt;crypt.h\u0026gt;，如果不加上该头文件，会出现implicit declaration of function ‘crypt’的错误。\n针对于undefined reference to `crypt\u0026rsquo;的错误，stackoverflow有以下方案：\ncrypt.c:(.text+0xf1): undefined reference to \u0026lsquo;crypt\u0026rsquo; is a linker error. Try linking with -lcrypt : gcc crypt.c -lcrypt.\n即，在CMakeLists.txt文件中加入link_libraries(crypt)。\nfor循环内部 在这个无限循环中，不断对str1进行加密，并与正确结果进行比较。如果str1在加密的过程中不被打断，则会得到正确结果，但是如果被打断并在处理器函数中对str2进行加密，则会对str1加密的结果产生污染，导致该加密的结果不正确，以此来判断信号处理器函数是否对不可重入函数产生了影响。\n","permalink":"https://fireflyyh.top/posts/tlpi/nonreentrant/","summary":"TLPI 21.1.2: 可重入函数和异步信号安全函数 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #define _XOPEN_SOURCE 600 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;crypt.h\u0026gt; #include \u0026#34;tlpi_hdr.h\u0026#34; static char *str2; static int handled = 0; // 设置处理器函数，一旦遇上SIGINT，便对str2进行加密 static void handler(int sig) { crypt(str2, \u0026#34;xx\u0026#34;); handled++; } int main(int argc, char *argv[]) { char *cr1; int callNum, mismatch; struct sigaction sa; if (argc !","title":"信号处理函数中调用不可重入的函数"},{"content":"TLPI 21.3：在备选栈中处理信号：sigaltstack() 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 static void sigsegvHandler(int sig) { int x; // 捕捉信号，并通过局部变量的位置来大致判断为当前函数所分配的空间处于什么位置 printf(\u0026#34;Caught signal %d (%s)\\n\u0026#34;, sig, strsignal(sig)); printf(\u0026#34;Top of handler stack near %10p\\n\u0026#34;, (void *)\u0026amp;x); // fflush(NULL)的作用是在程序异常终止前确保所有标准输出缓冲区的数据都被写入到相应的输出设备。 fflush(NULL); _exit(EXIT_FAILURE); } static void overflowStack(int callNum) { char a[100000]; // 此类分配数组方式为栈上分配 printf(\u0026#34;Call %4d - top of stack near %10p\\n\u0026#34;, callNum, \u0026amp;a[0]); overflowStack(callNum + 1); // 无限递归调用，不断在栈上分配空间，每次分配100000字节以上 } int main(int argc, char *argv[]) { stack_t sigstack; struct sigaction sa; int j; printf(\u0026#34;Top of standard stack is near %10p\\n\u0026#34;, (void *)\u0026amp;j); // 分配备用栈并通知内核 // 在堆当中分配备用栈 sigstack.ss_sp = malloc(SIGSTKSZ); if (sigstack.ss_sp == NULL) errExit(\u0026#34;malloc\u0026#34;); sigstack.ss_size = SIGSTKSZ; // 默认栈大小 sigstack.ss_flags = 0; // sig alt stack if (sigaltstack(\u0026amp;sigstack, NULL) == -1) errExit(\u0026#34;sigaltstack\u0026#34;); // sbrk(0)返回当前进程的堆顶地址 printf(\u0026#34;Alternate stack is at %10p-%p\\n\u0026#34;, sigstack.ss_sp, (char *)sbrk(0) - 1); // 设置信号处理器函数，并且不阻塞任何信号 sa.sa_handler = sigsegvHandler; sigemptyset(\u0026amp;sa.sa_mask); sa.sa_flags = SA_ONSTACK; if (sigaction(SIGSEGV, \u0026amp;sa, NULL) == -1) errExit(\u0026#34;sigaction\u0026#34;); // 递归调用overflowStack() overflowStack(1); } 解释 ulimit 使用ulimit -s unlimited会负责移除当前 shell 会话时设置的任何 RLIMIT_STACK 资源限制，对其他 shell 会话无影响。但是在使用了这句话之后调用程序，系统会一直打印信息至Call 78522 - top of stack near 0x7ffa472aac80，即递归调用了78522次，然后[1] 16044 killed ./T_SIGALTSTACK直接将进程杀死。并没有出现预期的Caught signal 11 (Segmentation fault)。\n于是我将限制资源回复成了默认大小，再进行调用，出现了预期的结果：\n1 2 3 4 5 6 7 8 Top of standard stack is near 0x7ffd97398ebc Alternate stack is at 0x55fb092fd6b0-0x55fb0931dfff Call 1 - top of stack near 0x7ffd973807e0 Call 2 - top of stack near 0x7ffd97368110 ... Call 83 - top of stack near 0x7ffd96bad940 Caught signal 11 (Segmentation fault) Top of handler stack near 0x55fb092ff164 经过查阅资料，当使用ulimit -s unlimited来移除栈大小限制时，程序可以无限制地使用栈空间。在本代码中，overflowStack()函数通过递归调用，不断分配大量内存（每次调用分配100000字节），很快会耗尽系统的可用内存。 当系统检测到内存耗尽时，会启动 OOM Killer 来终止占用大量内存的进程。当程序在递归调用了78522次后，占用了大量内存，触发了 OOM Killer，直接将进程终止，所以进程被直接杀死而不是触发 SIGSEGV 信号处理程序。\nfflush(NULL) 关于fflush(NULL)，是为了在程序异常终止前确保所有标准输出缓冲区的数据都被写入到相应的输出设备。尽管程序有固定的执行顺序，但标准输出（stdout）通常是缓冲的。这意味着输出的数据并不会立即被写入到屏幕或文件，而是先存储在缓冲区中，直到缓冲区满或者遇到刷新操作（如换行、fflush 调用等）才会被真正写出。\n在正常情况下，printf输出的数据会在适当的时机刷新到屏幕上。但是，如果程序异常终止，缓冲区中的数据可能没有机会被刷新，从而导致部分或全部输出丢失。exit 函数会执行标准库的清理操作，包括刷新缓冲区。但 _exit 函数是直接退出，不进行任何清理操作，包括缓冲区的刷新。这也就是为什么示例程序在_exit() 之前要进行fflush() 操作。\n","permalink":"https://fireflyyh.top/posts/tlpi/t_sigaltstack/","summary":"TLPI 21.3：在备选栈中处理信号：sigaltstack() 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 static void sigsegvHandler(int sig) { int x; // 捕捉信号，并通过局部变量的位置来大致判断为当前函数所分配的空间处于什么位置 printf(\u0026#34;Caught signal %d (%s)\\n\u0026#34;, sig, strsignal(sig)); printf(\u0026#34;Top of handler stack near %10p\\n\u0026#34;, (void *)\u0026amp;x); // fflush(NULL)的作用是在程序异常终止前确保所有标准输出缓冲区的数据都被写入到相应的输出设备。 fflush(NULL); _exit(EXIT_FAILURE); } static void overflowStack(int callNum) { char a[100000]; // 此类分配数组方式为栈上分配 printf(\u0026#34;Call %4d - top of stack near %10p\\n\u0026#34;, callNum, \u0026amp;a[0]); overflowStack(callNum + 1); // 无限递归调用，不断在栈上分配空间，每次分配100000字节以上 } int main(int argc, char *argv[]) { stack_t sigstack; struct sigaction sa; int j; printf(\u0026#34;Top of standard stack is near %10p\\n\u0026#34;, (void *)\u0026amp;j); // 分配备用栈并通知内核 // 在堆当中分配备用栈 sigstack.","title":"在备选栈中处理信号"},{"content":"处理SIGCHLD信号 1 2 3 4 5 6 7 8 9 10 11 12 void sig_chld(int signo) { pid_t pid; int stat; // wait()是为了清理僵死进程 // pid = wait(\u0026amp;stat); // printf(\u0026#34;child %d terminated\\n\u0026#34;, pid); while ((pid = waitpid(-1, \u0026amp;stat, WNOHANG)) \u0026gt; 0) printf(\u0026#34;child %d terminated\\n\u0026#34;, pid); return; } wait版本行不通的原因 若服务器和客户端在同一主机上，则该信号处理函数只执行过一次（根据UNP的描述是这样的，但是本人实测，信号处理器函数执行了两次）。 但是如果我们在不同的主机上运行客户和服务器，那么信号处理器函数一般执行两次：一次是由第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因为该处理函数仅仅再被调用一次，从而留下3个僵死进程。 不过有的时候，根据FIN到达主机的时机，信号处理函数可能会执行3次甚至4次\n根据本人猜想，如果在相同主机测试，由于没有网络数据传播时延的影响，本机的客户端所有五个FIN都几乎在同一时间传递给服务器， 从而使得服务器的5个子进程基本在同一时刻终止，从而5个SIGCHLD在同一时刻发送给父进程，都在第一个信号处理函数执行之前发生， 而Unix信号一般是不排队的（这里详见TLPI对应的小节），因此信号处理函数只执行一次。\n但是如果在不同主机测试，由于网络数据传播，各个FIN到达服务器的时间差较大一些，导致FIN以不可忽略的时差到达服务器。 例如在处理第一个SIGCHLD信号时，其他FIN才到达，从而引起信号处理函数执行多次。\n1 2 3 4 5 6 7 ➜ bin git:(main) ✗ ./TCPSERV03 \u0026amp; [1] 65001 ➜ bin git:(main) ✗ ./TCPCLI04 127.0.0.1 hell hell child 65324 terminated child 65325 terminated waitpid()版本行得通 清理僵尸进程 1 2 while ((pid = waitpid(-1, \u0026amp;stat, WNOHANG)) \u0026gt; 0) printf(\u0026#34;child %d terminated\\n\u0026#34;, pid); waitpid(-1, \u0026amp;stat, WNOHANG)：这部分代码是关键。waitpid 函数用于等待子进程的状态改变。\npid = -1：表示等待任何子进程。 \u0026amp;stat：是一个指向 int 的指针，用于存储子进程的终止状态。 WNOHANG：这个选项告诉 waitpid 非阻塞运行。如果没有子进程终止，waitpid 将立即返回，而不是阻塞等待。 while 循环：这个循环会一直执行，直到没有子进程终止为止。waitpid 返回值会是：\n大于 0 的值：表示终止的子进程的 PID，表明有一个子进程结束。 0：表示没有子进程终止。 -1：表示没有更多的子进程或者调用失败。 代码总结 这段代码实现了一个信号处理函数 sig_chld，用于处理 SIGCHLD 信号。当一个子进程终止时，父进程会收到 SIGCHLD 信号，触发这个处理函数。该函数使用 waitpid 结合 WNOHANG 选项来处理所有终止的子进程，并避免产生僵尸进程。僵尸进程会占用系统资源，因此在接收到 SIGCHLD 信号时及时清理子进程的退出状态是很重要的。\n这种处理方式确保了父进程可以继续处理多个子进程的终止，而不会因为某个子进程的终止而导致阻塞，从而避免产生僵尸进程。\n运行结果：\n1 2 3 4 5 6 7 8 9 10 ➜ bin git:(main) ✗ ./TCPSERV04 \u0026amp; [1] 56786 ➜ bin git:(main) ✗ ./TCPCLI04 127.0.0.1 htl htl child 56992 terminated child 56993 terminated child 56994 terminated child 56995 terminated child 56996 terminated 不在循环内部使用wait()的原因 在信号处理函数中使用 waitpid() 而不是 wait() 的原因主要涉及到以下几个方面：\n1. 避免遗漏子进程的终止 waitpid() 在循环中与 WNOHANG 选项一起使用，可以确保所有已终止的子进程都被处理。因为 waitpid() 在每次调用时返回一个已终止的子进程的 PID，当没有更多子进程终止时返回 0。通过循环调用 waitpid()，你可以确保每个已终止的子进程都被正确处理，从而避免遗漏。\n相比之下，wait() 只能一次等待一个子进程终止。如果有多个子进程在短时间内终止，而 wait() 只被调用一次，可能会遗漏处理其中的一些子进程。这些未处理的子进程就会成为僵尸进程，浪费系统资源。\n2. 非阻塞的等待 waitpid() 与 WNOHANG 选项结合使用是非阻塞的，它允许信号处理程序检查所有子进程是否终止，而不会因没有终止的子进程而阻塞。这样，信号处理函数可以迅速返回，继续处理其他任务。\n在没有循环时，调用wait()不会导致出现阻塞等待，因为当进入该处理函数时，说明必然有函数终止了，只不过是1个还是多个的问题 无论是一个还是多个，wait()都只能处理掉一个，然后返回，退出处理器函数\n如果在循环中调用 wait()，一旦没有子进程终止，wait() 就会阻塞，这会导致整个信号处理程序挂起，不能立即返回。 例如，第一个进程终止后，父进程进入了处理器函数，处理了第一个进程之后，便会继续循环等待下一个终止进程， 若是下一个进程迟迟不进入终止状态，则父进程则需要一直阻塞等待。 阻塞在信号处理程序中通常是不被推荐的，因为这可能导致系统其他部分的延迟或不良的响应时间。\n3. 处理多个子进程的终止 在某些情况下，多个子进程可能在非常短的时间内几乎同时终止。如果仅调用 wait()，信号处理程序可能只能处理一个子进程的终止。使用 waitpid() 的循环可以确保处理所有已终止的子进程。 4. 控制和灵活性 waitpid() 提供了更多的控制和灵活性。例如，使用 waitpid() 可以指定等待特定的子进程，或根据不同的选项处理子进程。相比之下，wait() 的功能比较有限，只能简单地等待任意一个子进程的终止。 ","permalink":"https://fireflyyh.top/posts/unp/sigchldwaitpid/","summary":"处理SIGCHLD信号 1 2 3 4 5 6 7 8 9 10 11 12 void sig_chld(int signo) { pid_t pid; int stat; // wait()是为了清理僵死进程 // pid = wait(\u0026amp;stat); // printf(\u0026#34;child %d terminated\\n\u0026#34;, pid); while ((pid = waitpid(-1, \u0026amp;stat, WNOHANG)) \u0026gt; 0) printf(\u0026#34;child %d terminated\\n\u0026#34;, pid); return; } wait版本行不通的原因 若服务器和客户端在同一主机上，则该信号处理函数只执行过一次（根据UNP的描述是这样的，但是本人实测，信号处理器函数执行了两次）。 但是如果我们在不同的主机上运行客户和服务器，那么信号处理器函数一般执行两次：一次是由第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因为该处理函数仅仅再被调用一次，从而留下3个僵死进程。 不过有的时候，根据FIN到达主机的时机，信号处理函数可能会执行3次甚至4次\n根据本人猜想，如果在相同主机测试，由于没有网络数据传播时延的影响，本机的客户端所有五个FIN都几乎在同一时间传递给服务器， 从而使得服务器的5个子进程基本在同一时刻终止，从而5个SIGCHLD在同一时刻发送给父进程，都在第一个信号处理函数执行之前发生， 而Unix信号一般是不排队的（这里详见TLPI对应的小节），因此信号处理函数只执行一次。\n但是如果在不同主机测试，由于网络数据传播，各个FIN到达服务器的时间差较大一些，导致FIN以不可忽略的时差到达服务器。 例如在处理第一个SIGCHLD信号时，其他FIN才到达，从而引起信号处理函数执行多次。\n1 2 3 4 5 6 7 ➜ bin git:(main) ✗ ./TCPSERV03 \u0026amp; [1] 65001 ➜ bin git:(main) ✗ .","title":"处理SIGCHLD信号"},{"content":"之前搭建hexo博客，是将其部署到 github 中，通过 github.io 来访问，但是速度感人，所以本次尝试将 hugo 博客部署到阿里云服务器，通过域名进行访问，本文参考了hugo博客部署到腾讯云轻量级服务器。 由于是我第一次使用 nginx，所以如果遇到什么问题，请多海涵并且可以参考其他博客或网络资料。\n在部署之前，我已经有了阿里云服务器（配置为2核2GB）、阿里云购买的域名（fireflyyh.top）。\n1. 服务器端下载并安装nginx 1.1 安装nginx 在 ubuntu 环境下： 安装 nginx\n1 sudo apt install nginx 将 nginx 设置为开机启动：\n1 sudo systemctl enable nginx 启动 nginx：\n1 sudo systemctl start nginx 1.2 测试nginx 查看 nginx 状态\n1 sudo systemctl status nginx 如果没问题，则会出现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ● nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) Active: active (running) since Fri 2024-07-26 21:46:50 CST; 1 day 13h ago Docs: man:nginx(8) Process: 164834 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0/SUCCESS) Process: 164836 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS) Main PID: 164837 (nginx) Tasks: 3 (limit: 1947) Memory: 4.1M CPU: 26ms CGroup: /system.slice/nginx.service ├─164837 \u0026#34;nginx: master process /usr/sbin/nginx -g daemon on; master_process on;\u0026#34; ├─164838 \u0026#34;nginx: worker process\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; └─164839 \u0026#34;nginx: worker process\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; Jul 26 21:46:50 Firefly-Aliyun systemd[1]: Starting A high performance web server and a reverse proxy server... Jul 26 21:46:50 Firefly-Aliyun systemd[1]: Started A high performance web server and a reverse proxy server. 通过阿里云服务器管理面板中的安全组标签，将服务器的80端口开放。接下来访问http://\u0026lt;服务器IP地址\u0026gt;，如果出现了 nginx 页面，则代表着配置成功。\n2. 配置nginx 进入/etc/nginx/，目录树如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 . ├── conf.d ├── fastcgi.conf ├── fastcgi_params ├── koi-utf ├── koi-win ├── mime.types ├── modules-available ├── modules-enabled │ ├── 50-mod-http-geoip2.conf -\u0026gt; /usr/share/nginx/modules-available/mod-http-geoip2.conf │ ├── 50-mod-http-image-filter.conf -\u0026gt; /usr/share/nginx/modules-available/mod-http-image-filter.conf │ ├── 50-mod-http-xslt-filter.conf -\u0026gt; /usr/share/nginx/modules-available/mod-http-xslt-filter.conf │ ├── 50-mod-mail.conf -\u0026gt; /usr/share/nginx/modules-available/mod-mail.conf │ ├── 50-mod-stream.conf -\u0026gt; /usr/share/nginx/modules-available/mod-stream.conf │ └── 70-mod-stream-geoip2.conf -\u0026gt; /usr/share/nginx/modules-available/mod-stream-geoip2.conf ├── nginx.conf ├── proxy_params ├── scgi_params ├── sites-available │ └── default ├── sites-enabled │ └── default -\u0026gt; /etc/nginx/sites-available/default ├── snippets │ ├── fastcgi-php.conf │ └── snakeoil.conf ├── uwsgi_params └── win-utf 根据参考博客，要在nginx.conf文件中编辑Server字段，但是在我的这个文件中，并没有出现该字段。经过查阅资料，可以在./sites-available/default当中编辑。\n当没有SSL证书时：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 server { listen 80 default_server; listen [::]:80 default_server; # 修改页面所在目录 root /home/firefly/Codes/blog/public; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; # 修改域名 server_name www.staryh.top; # 修改 location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. root /home/firefly/Codes/blog/public; index index.html index.htm; # try_files $uri $uri/ =404; } error_page 404 /404.html; location = /404.html { root /home/firefly/Codes/blog/public; } } 经过上述修改之后，输入服务器 IP 地址，就可以访问了\n3. 将域名绑定到服务器 需要域名备案，否则访问不了 在阿里云购买的域名，然后通过更改 DNS 解析来将该域名定向至该服务器的IP地址\n4. 实现本机和服务器的public文件夹同步 在这一部分，我的想法比较复杂。\n将本地的博客文件夹放到 github 中，方便更多人能够访问我的博客所有的文件。 考虑到github的访问速度，打算在 gitee 中建立一个镜像的仓库，以实现 github 和 gitee 的博客文件夹的同步。 这样服务器只需要 pull gitee 仓库中的 public 子文件夹，便可以得到本地主机 push 到 github 仓库中的 public 文件夹。 4.1 本地-\u0026gt;github 将本地博客文件夹 push 到github仓库中\n4.2 github-\u0026gt;gitee 在 gitee 上绑定 github 账号； 在 gitee 中创建同名仓库，在仓库的管理标签页，选择仓库镜像管理，添加镜像，选择镜像方向为pull gitee \u0026lt;- github，选择正确的镜像仓库，并添加私人令牌，私人令牌在github界面-\u0026gt;用户头像-\u0026gt;settings-\u0026gt;developer settings-\u0026gt;personal access tokens中获取，勾选自动同步。 这样每次本地编辑完并上传 github 之后，稍等片刻就能在 gitee 看到修改了😊 截止到写本篇博客时，gitee 的仓库镜像管理功能一直存在，且可以自动同步。如果该自动同步功能不见了，可以尝试一篇教你代码同步 Github 和 Gitee中的做法。\n4.3 gitee-\u0026gt;服务器 进入到修改页面所在目录的父目录/home/firefly/Codes/blog，删除原来通过xtfp传输来的public文件夹； 在本地仓库根目录下，通过 git config core.sparseCheckout true 来启用sparseCheckout； 打开./.git/info，然后编辑其中的sparseCheckout文件（如果没有可以新建），将需要指定 pull 的文件夹位置输入进去：/public； 回到blog目录，添加远程仓库，并 pull（在pull的时候遇到了公私钥导致无法访问的问题，具体解决参考了解决 “fatal: Could not read from remote repository.“）。 1 git remote add origin git@gitee.com:yourname/yourrepo.git 5. SSL证书 5.1 获得SSL证书 由于阿里云策略改变，目前免费的只有个人测试证书（原免费证书）。\n根据Nginx或Tengine服务器配置SSL证书来进行配置。 其中，将下载的证书相关文件解压缩到/etc/nginx/中，\n5.3 修改nginx配置 同样地，在default文件中，结合了本文提到的两个博客，增加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 server { listen 443 ssl; server_name www.fireflyyh.top; root /home/firefly/Codes/blog/public; ssl_certificate /etc/nginx/fireflyyh.top.pem; ssl_certificate_key /etc/nginx/fireflyyh.top.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #自定义设置使用的TLS协议的类型以及加密套件（以下为配置示例，请您自行评估是否需要配置） #TLS协议版本越高，HTTPS通信的安全性越高，但是相较于低版本TLS协议，高版本TLS协议对浏览器的兼容性较差。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示优先使用服务端加密套件。默认开启 ssl_prefer_server_ciphers on; error_page 404 /404.html; location = /404.html { root /home/firefly/Codes/blog/public; } } 然后重启nginx服务：sudo systemctl restart nginx。\n6. 站点分析 6.1 Google Analytics 本博客建立时所采用的 hugo 版本为 v0.129.0，采用的主题 PaperMod 的版本为 v7.0。\n获取追踪ID 登录Google Analytics：\n进入数据流 根据网站创建新的数据流 在设置 Google 代码的区域：\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- Google tag (gtag.js) --\u0026gt; \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(\u0026#39;js\u0026#39;, new Date()); gtag(\u0026#39;config\u0026#39;, \u0026#39;G-XXXXXXXXXX\u0026#39;); \u0026lt;/script\u0026gt; 其中的G-XXXXXXXXXX就是所需的追踪 ID。\n修改 hugo 配置 在网站根目录中的hugo.toml中，将[params.analytics.google]字段删去，将文件开头的googleAnalytics字段修改为ID，并在末尾添加以下信息： 1 2 3 [services] [services.googleAnalytics] ID = \u0026#39;G-XXXXXXXXXX\u0026#39; 在主题的layouts文件夹下新建文件夹_internal，并在其中新建文件google_analytics.html，将之前在 Google 代码区域获得的代码放入其中。\n修改layouts/partials/文件夹中的head.html，在末尾增加：\n1 2 3 {{- with site.Config.Services.GoogleAnalytics.ID -}} {{- template \u0026#34;_internal/google_analytics.html\u0026#34; . -}} {{- end -}} 重新部署，过一段时间就能在 Google Analytics 页面看到访问的数据了。但是奇怪的是在代码 6.2 百度统计 新增站点 登录百度统计的使用设置界面，按照要求新增网站，然后点击“获取代码”按钮，将“新版统计代码获取”区域的代码复制下来。\n修改 html 进入到 PaperMod 主题的layouts/partials文件夹，修改extend_head.html文件，在其中加入刚刚复制下来的代码。\n检测生效 重新部署。然后用手动检查或者百度统计助手来检测是否添加功能成功。\n","permalink":"https://fireflyyh.top/posts/blog_configuration/deploy/","summary":"之前搭建hexo博客，是将其部署到 github 中，通过 github.io 来访问，但是速度感人，所以本次尝试将 hugo 博客部署到阿里云服务器，通过域名进行访问，本文参考了hugo博客部署到腾讯云轻量级服务器。 由于是我第一次使用 nginx，所以如果遇到什么问题，请多海涵并且可以参考其他博客或网络资料。\n在部署之前，我已经有了阿里云服务器（配置为2核2GB）、阿里云购买的域名（fireflyyh.top）。\n1. 服务器端下载并安装nginx 1.1 安装nginx 在 ubuntu 环境下： 安装 nginx\n1 sudo apt install nginx 将 nginx 设置为开机启动：\n1 sudo systemctl enable nginx 启动 nginx：\n1 sudo systemctl start nginx 1.2 测试nginx 查看 nginx 状态\n1 sudo systemctl status nginx 如果没问题，则会出现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ● nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.","title":"将博客部署到阿里云服务器"},{"content":"TLPI 21.2.1：在信号处理器函数中执行非本地跳转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #define _GNU_SOURCE // 添加该定义以正常使用strsignal()、sigaction() #include \u0026lt;string.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026#34;signal_functions.h\u0026#34; #include \u0026#34;tlpi_hdr.h\u0026#34; static volatile sig_atomic_t canJump = 0; #ifdef USE_SIGSETJMP static sigjmp_buf senv; #else static jmp_buf env; #endif static void handler(int sig) { printf(\u0026#34;Received signal %d (%s), signal mask is:\\n\u0026#34;, sig, strsignal(sig)); printSigMask(stdout, NULL); if (!canJump) { // 若canJump为0 printf(\u0026#34;\u0026#39;env\u0026#39; buffer not yet set, doing a simple return\\n\u0026#34;); return; } #ifdef USE_SIGSETJMP siglongjmp(senv, 1); #else longjmp(env, 1); #endif } int main(int argc, char *argv[]) { struct sigaction sa; printSigMask(stdout, \u0026#34;Signal mask at startup:\\n\u0026#34;); // 打印最开始的信号掩码 sigemptyset(\u0026amp;sa.sa_mask); sa.sa_flags = 0; sa.sa_handler = handler; if (sigaction (SIGINT, \u0026amp;sa, NULL) == -1) errExit(\u0026#34;sigaction\u0026#34;); #ifdef USE_SIGSETJMP printf(\u0026#34;Calling sigsetjmp()\\n\u0026#34;); /* */ if (sigsetjmp(senv, 1) == 0) #else printf(\u0026#34;Calling setjmp()\\n\u0026#34;); // 设置跳转目标，并初始化env if (setjmp(env) == 0) #endif // 当从处理器函数直接返回之后才会执行该语句 canJump = 1; else // 当从处理器函数执行非本地跳转之后才会执行该语句 printSigMask(stdout, \u0026#34;After jump from handler, signal mask is:\\n\u0026#34;); printf(\u0026#34;Will be paused\\n\u0026#34;); for (;;) /* 等待信号， 若接收到SIGINT，则跳转到处理器函数中，再由longjmp()/siglongjmp()跳转到setjmp()/sigsetjmp() 具体是哪个跳转函数，则取决于是否宏定义了USE_SIGSETJMP */ pause(); } 解释 canjump的用法 接收到信号的时机有两种：\n在setjmp(env)之前，在这种情况下，跳转目标尚未建立，这将导致处理器函数使用尚未初始化的 env 缓冲区来执行非本地跳转； 在setjmp(env)之后，在这种情况下，跳转目标被建立，env已被初始化在执行longjmp()/siglongjmp()之后，可以正确地将一些信息保存。 为了避免出现第一种情况，设置了 canJump 变量，当第一次执行了setjmp(env)之后canjump被设置为1，代表着可以正确执行非本地跳转。然后在此Handler()的if (canJump)处，若 canjump 为0，说明接收到信号的时机是在 set 之前，则不能够进行跳转，而是直接从处理器函数返回。\n两种跳转方法的区别 sigsetjmp()比setjmp()多出一个参数 savesigs。如果指定 savesigs 为非 0，那么会将调用 sigsetjmp()时进程的当前信号掩码保存于 env 中，之后通过指定相同 env 参数的siglongjmp()调用进行恢复。如果 savesigs 为0，则不会保存和恢复进程的信号掩码。\n","permalink":"https://fireflyyh.top/posts/tlpi/sigmask_longjmp/","summary":"TLPI 21.2.1：在信号处理器函数中执行非本地跳转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #define _GNU_SOURCE // 添加该定义以正常使用strsignal()、sigaction() #include \u0026lt;string.","title":"在信号处理器函数中执行非本地跳转"},{"content":"16年 单周期数据通路 单周期数据通路是一种简单的数据通路设计，每个时钟周期执行一条完整的指令，即每条指令的CPI为1，要考虑比较慢的指令，所以处理器的时钟频率较低。 这意味着每条指令执行过程中任何数据通路单元都只能被用一次，如果需要使用多次则必须将该数据通路单元复制多份。\n控制信号是CU根据指令操作码发出的信号，对于单周期处理器来说，每条指令的执行只有一个时钟周期，而在一个时钟周期内控制信号并不会变化。\n单周期数据通路必须有独立的指令存储器和数据存储器，因为处理器在一个周期内只能操作每个部件一次，而在一个周期内不可能对一个单端口存储器进行两次存取。且无法使用单总线数据通路，因为单总线数据通路将所有寄存器的输入出端都连接在一条公共通路上，一个时钟内只允许一次操作，无法完成指令的所有操作。\nTSL指令实现互斥 1 2 3 4 5 6 do { while (TSL(\u0026amp;lock)); critical section; lock = FALSE; ...... } while (TRUE); 退出临界区的进程负责唤醒就绪态进程？\n因为在TSL方法下，一个进程只有两种状态：\n运行态：用户处于了do{ }中，那么不管是是在其中的while (TSL(\u0026amp;lock))不断地循环，还是在访问临界资源，都是占用着CPU的，也就是处于运行态； 就绪态：若是在执行过程中由于并发所需要（如时间片到了），被其他进程占用了CPU，就变成了就绪态； 但是不会处于阻塞态，因为若是在等待临界资源，则会一直处于while (TSL(\u0026amp;lock));中，而且不会主动放弃CPU变成阻塞态（阻塞是一个主动的过程）。故不存在阻塞态的进城来给退出临界区的进程唤醒。\n等待进入临界区的进程不会主动放弃CPU，故上述代码不满足“让权等待”的同步准则。因为会一直停留在执行while(TSL(\u0026amp;lock))的循环中，该语句应在开中断下进行，否则一直处于该循环且不被其他进程中断可能会导致系统终止。\n操作系统的发展 手工发展阶段（无操作系统）：\n所有工作都要人干预，用户独占全机。\n特点：用户独占全机、CPU等待手工操作；\n缺点：人机矛盾及 CPU 和 I/O 设备之间速度不匹配的矛盾，因此发展出了批处理系统。\n批处理阶段（开始出现操作系统）：\n单道批处理：系统对作业的处理是成批进行的，但内存中始终保持一道作业。\n特点：单道性、自动性、顺序性。\n缺点：每次主机内存中仅存放一道作业，每当它在运行时发出I/O请求后，高速的 CPU 便处于等待低速的 I/O 完成的状态。\n为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。 多道批处理：多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU 中交替地运行。\n特点：多道、宏观上并行、微观上串行。\n优点：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用；系统吞吐量大， CPU 和其他资源保持“忙碌”状态。 缺点：用户响应的时间较长；不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。 因此发展出了分时操作系统。 分时操作系统：\n分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时（同时性）与主机进行交互（交互性）操作而互不干扰（独立性）。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意（及时性）。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统。\n特点：同时性、交互性、独立性、及时性。\n优点：较好地解决了人机交互问题。\n缺点：在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统），因此，实时操作系统应运而生。\n描述 特点 优点 缺点 手工操作阶段 所有工作都要人干预 用户独占全机、CPU等待手工操作； 不会出现因资源己被其他用户占用而等待的情况 资源利用率低，人机矛盾及 CPU 和 I/O 设备之间速度不匹配的矛盾，因此发展出了批处理系统。 单道批处理 系统对作业的处理是成批进行的，但内存中始终保持一道作业。 单道性、自动性、顺序性。 （开始出现操作系统） 每次主机内存中仅存放一道作业，每当它在运行时发出I/O请求后，高速的 CPU 便处于等待低速的 I/O 完成的状态。 为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。 多道批处理 多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU 中交替地运行。 多道性、宏观上并行、微观上串行。 资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用；系统吞吐量大， CPU 和其他资源保持“忙碌”状态。 用户响应的时间较长；不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。 因此发展出了分时操作系统。 分时操作系统 用户可以同时（同时性）与主机进行交互（交互性）操作而互不干扰（独立性）。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意（及时性）。 同时性、交互性、独立性、及时性。 较好地解决了人机交互问题。 在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统），因此，实时操作系统应运而生。 实时操作系统 为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。资源利用率不是其主要追求目标。 及时性、可靠性 管程 管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。管程不仅能实现进程间的互斥，而且能实现进程间的同步。\n管程由 4 部分组成：\n管程的名称； 局部于管程内部的共享数据结构说明； 对该数据结构进行操作的一组过程（或函数）； 对局部于管程内部的共享数据设置初始值的语句。 管程具有特性：\n局部于管程的数据只能被局部于管程内的过程所访问； 一个进程只有通过调用管程内的过程才能进入管程访问共享数据； 每次仅允许一个进程在管程内执行某个内部过程（实现互斥）； 互斥访问数据是由编译器实现的，程序员不用关心。 例如，若x是管程内的条件变量，则当进程执行x.wait()时所做的工作是阻塞该进程，并将之插入x的阻塞队列中。\n“条件变量”是管程内部说明和使用的一种特殊变量，其作用类似于信号量机制中的“信号量”，都是用于实现进程同步的。需要注意的是，在同一时刻，管程中只能有一个进程在执行。如果进程 A 执行了x.wait()操作，那么该进程会阻塞，并挂到条件变量 x 对应的阻塞队列上。这样，管程的使用权被释放，就可以有另一个进程进入管程。如果进程 B 执行了x.signal()操作，那么会唤醒 x 对应的阻塞队列队头进程。在 Pascal 语言的管程中，规定只有一个进程要离开管程时才能调用signal()操作。\n四次挥手各自的阶段 17年 顺序存储、链式存储对不同排序方式的影响 由顺序存储变成链式存储后，效率不会降低的有：插入排序、（简单）选择排序、冒泡排序，因为顺序存储下，时间复杂度就是$O(n^2)$，链式存储不会改变其复杂度；\n效率会降低的有：希尔排序、堆排序、快速排序，因为是利用了顺序存储的随机访问特性。\n指令级并行 超流水线：通过增加流水线级数来使更多的指令同时在流水线中重叠执行。超流水线并没有改变CPI的值，CPI还是1，但是，因为理想情况下流水线的加速比与流水段的数目成正比，流水段越多，时钟周期越短，主频越高，指令吞吐率越高，所以超流水线的性能比普通流水线好。然而，流水线级数越多，用于流水段寄存器的开销就越大，因而流水线级数是有限制的，不可能无限增加。 在《计算机组成与设计：软件/硬件接口》书中，有一个形象的解释：\n任何一个经常光顾洗衣店的人都会不自觉地使用流水线技术。非流水线方式的洗衣过程包括如下几个步骤：\n把一批脏衣服放入洗衣机里清洗 洗衣机洗完后，把衣服取出并放入烘干机中。 烘干衣服后，将衣服从烘干机中取出，然后放在桌子上叠起来。 叠好衣服后，请你的室友帮忙把桌子上的衣服收好。 当你的室友把这批干净衣服从桌子上拿走后，再开始洗下一批脏衣服。采用流水线的方法将节省大量的时间，如图 4-25 所示。当把第一批脏衣服从洗衣机里取出放入烘干机之后，就可以把第二批脏衣服放入洗衣机里进行清洗了。当第一批衣服被烘干之后，就可以将它们叠起来，同时把洗净的下一批湿衣服放入烘干机中，同时再将下一批脏衣服放入洗衣机里清洗。接着让你的室友把第一批衣服从桌子上收好，而你开始叠第二批衣服，这时烘干机中放的是第三批衣服，同时可以把第四批脏衣服放入洗衣机清洗了。这样，所有的洗衣步骤（流水线的步骤）都在同时操作。只要在每一个操作步骤中都有独立的工作单元时，我们就可以采用流水线的方式来快速完成任务了。\n有两种方法可以增加潜在的指令级并行程度：\n第一种是增加流水线的深度以重叠更多的指令。还是用洗衣店的例子来说明，假设洗衣机周期比其他机器的周期要长，我们可以把洗衣机划分成三个机器，分别完成原洗衣机洗、漂、甩三个功能。这样我们就将四级流水线变成了六级流水线。为了达到完全的加速效果，我们需要重新平衡其他步骤使得它们的长度相同，在处理器和洗衣店中都是这样。因为更多的操作被重叠，有更多的并行性被挖掘出来。\n通过增加流水线级数来使更多的指令同时在流水线中重叠执行。超流水线并没有改变CPI的值，CPI还是1，但是，因为理想情况下流水线的加速比与流水段的数目成正比，流水段越多，时钟周期越短，主频越高，指令吞吐率越高，所以超流水线的性能比普通流水线好。然而，流水线级数越多，用于流水段寄存器的开销就越大，因而流水线级数是有限制的，不可能无限增加。\n另一种方法是复制计算机内部部件的数量，使得每个流水级可以启动多条指令。这种技术一般被称为多发射。一个多发射的洗衣店会把原有的一台洗衣机和烘干机替换为三台洗衣机和三台烘干机。还需要雇用更多的洗衣工来折叠和存储三倍于原来的衣服。这种方法的缺点是需要额外的工作让所有机器同时运转并将负载传到下个流水级。\n实现多发射流水线必须完成以下两个任务：指令打包和冒险处理。指令打包任务就是将能够并行处理的多条指令同时发送到发射槽中，因此处理器必须知道每个周期能发射几条指令，哪些指令可以同时发射。这通过推测技术来完成，可以由编译器或处理器通过猜测指令执行结果来调整指令执行顺序。根据推测任务主要由编译器静态完成还是由处理器动态执行，可将多发射技术分为两类：静态多发射和动态多发射：\n静态多发射主要通过编译器静态推测来辅助完成“指令打包”和“冒险处理”。指令打包的结果可看成将同时发射的多条指令合并到一个长指令中。通常将一个时钟周期内发射的多个指令看成一条多个操作的长指令，称为一个“发射包“。所以，静态多发射指令最初被称为“超长指令字”。\n动态多发射由处理器硬件动态进行流水线调度来完成“指令打包“和“冒险处理”，能在一个时钟周期内执行一条以上指令。采用动态多发射流水线技术的处理器称为超标量处理器。在简单的超标量处理器中，指令按顺序发射，每个周期由处理器决定是发射一条或多条指令。能结合动态调度技术提高指令执行并行性。\n数据通路包含哪些 机器指令的执行是在数据通路中完成的，通常将指令执行过程中数据所经过的路径（包括路径上的部件）称为数据通路。程序计数器、ALU、通用寄存器、状态寄存器、cache、MMU（主存管理单元）、浮点运算逻辑、异常和中断处理逻辑等都是指令执行过程中数据流经的部件，都属于数据通路的一部分。通常把数据通路中专门进行数据运算的部件称为执行部件(execution unit) 或功能部件(function unit)。数据通路由控制部件进行控制。控制部件根据每条指令功能的不同生成对数据通路的控制信号，因此数据通路不包括控制部件。\n指令执行所用到的元件有两类：组合逻辑元件（也称操作元件）和时序逻辑元件（也称状态元件或存储元件）。故也可以说数据通路由组合逻辑电路和时序逻辑电路组合而成。\n组合逻辑元件的输出只取决于当前的输人。若输入一样，其输出也一样。组合电路的定时不受时钟信号的控制，所有输入信号到达后，经过一定的逻辑门延迟，输出端的值被改变，并一直保持其值不变，直到输入信号改变。数据通路中常用的组合逻辑元件有多路选择器（MUX） 、加法器（Adder） 、算术逻辑部件（ALU）、译码器（Decoder）等。\n时序逻辑元件具有存储功能，输人状态在时钟控制下被写到电路中，并保持电路的输出值不变，直到下一个时钟到达。输人端状态由时钟决定何时被写入，输出端状态随时可以读出。数据通路中的寄存器是一种典型的状态存储元件，根据功能和实现方式的不同，有各种不同类型的寄存器。\n磁盘初始化 低级格式化（物理格式化）：一个新的磁盘是一个空白版，必须分成扇区以便磁盘控制器能读和写，这个过程称为低级格式化（或物理格式化）。低级格式化为磁盘的每个扇区采用特别的数据结构，包括校验码。 磁盘分区：磁盘分为由一个或多个柱面组成的分区，每个分区可以作为一个独立的磁盘。 逻辑格式化（创建文件系统）：在这一步，操作系统将初始的文件系统数据结构存储到磁盘上，包括创建文件系统的根目录，对空闲磁盘块进行管理的数据结构进行初始化（如位示图、空闲分区表、i结点区） 划分扇区不等于磁盘分区。\nMAC帧的地址 “接化发”\n18年 行地址位数和列地址位数的大小关系 在采用引脚复用时，为了提高DRAM的性价比，通常设置行地址位数$r$和列地址位数$c$满足$r\\leq c$且$|r-c|$最小。\n可以提高文件访问速度的措施 提前读：提前读是指读当前盘块时，将下个可能要访问的盘块数据读入缓冲区，以便需要时直接从缓冲区中读取，提高了文件的访问速度； 为文件分配连续的簇； 延迟写：延迟写是先将写数据写入缓冲区，并置上“延迟写”标志，以备不久之后、问，当缓冲区需要再次被分配出去时才将缓冲区数据写入磁盘，减少了访问磁盘的次数，高了文件的访问速度； 采用磁盘高速缓存； 分用复用 发送方的某些应用进程所发送的不同的应用报文，在传输层使用UDP协议进行封装，称为UDP复用，TCP复用概念类似。传输层发送端使用源端口号来区分不同的应用进程； 不管是UDP封装的UDP用户数据报还是TCP协议封装的TCP报文段，在网络层都需要使用IP协议来封装成IP数据报，称为IP复用，IP数据报首部的协议字段的值用来表明封装的是何种协议数据单元，如取值为6表示封装的是TCP报文段，取值为17表示封装的是UDP用户数据报； 接收方网络层收到IP数据报后进行IP分用，根据IP首部的协议字段来向上交付给传输层对应的协议。 接收方传输层根据UDP数据报或TCP报文段首部的目的端口号，向上交付给应用层的相应应用进程。 19年 森林的遍历、多叉树的遍历 树 森林 二叉树 先根遍历 先序遍历 先序遍历 后根遍历 中序遍历 中序遍历 森林的先序遍历也称为先根遍历，中序遍历也称为中根遍历、后根遍历。\n结合了cache和虚拟存储器的CPU访存过程 cache缺失由硬件完成；缺页处理由软件完成，操作系统通过缺页异常处理程序来实现；TLB缺失既可以由硬件来处理也可以软件来处理。用软件处理时，OS通过专门的TLB缺失异常处理程序来实现。\nDMA的一些细节 DMA的数据传送分为预处理、数据传送和后处理3个阶段。\nDMA预处理阶段需要CPU参与，由CPU完成必要的准备工作，由设备驱动程序设置传送参数**。每类设备都配置一个设备驱动程序，设备驱动程序向上层用户程序提供一组标准接口，负责实现对设备发出各种具体操作指令，**用户程序不能直接和 DMA 打交道。 在DMA传送过程中，DMA控制器直接控制总线传输。每次将一个数据块送到主存中后，在下次数据传送前，DMA控制器会再次请求总线使用权（即DMA请求），该请求的响应无需CPU干预； 在所有所需的块传送完成后，DMA传送结束，进入后处理阶段，DMA控制器发出DMA中断，CPU参与中断的处理。 各种动态分区管理方式特点 首次适应（ First Fit ）算法。空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。 邻近适应（ Next Fit) 算法。又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。 最佳适应（ Best Fit ）算法。空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业，避免“大材小用”。 最坏适应 (Worst Fit ）算法。空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业。 首次适应算法最简单，通常也是最好和最快的。不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时都要经过这些分区，因此增加了开销。\n邻近适应算法试图解决这个问题。但它常常导致在内存空间的尾部（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配）分裂成小碎片。通常比首次适应算法要差。\n最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，会产生最多的外部碎片。\n最坏适应算法与最佳适应算法相反，它选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大内存块，因此性能也非常差。\n物理层介质总结 同轴电缆：coaxial cable\n双绞线：Twisted pair（T）\n绞合的作用：\n减少相邻导线间的电磁干扰 抵御部分来自外界的电磁干扰 光纤：Optical fiber（F）\n光纤的优点：\n通信容量非常大 抗雷电和电磁千扰 性能好，传输损耗小，中继距离长 无串音，干扰保密性好 体积小，重量轻 光线的缺点：\n切割光纤需要较贵的专用设备 目前光电接口还比较昂贵 GBN确认号、TCP确认号 在GBN中，若本次A发送给B的帧序号为n，B发送给A的确认序号为n，说明已经收到了前n个帧；\n在TCP中，若本次B发送的确认报文段中的确认号为n+1，说明已经收到了A发送给B的前n个报文段，期待收到第n+1个报文段；\n","permalink":"https://fireflyyh.top/posts/408/summary02/","summary":"16年 单周期数据通路 单周期数据通路是一种简单的数据通路设计，每个时钟周期执行一条完整的指令，即每条指令的CPI为1，要考虑比较慢的指令，所以处理器的时钟频率较低。 这意味着每条指令执行过程中任何数据通路单元都只能被用一次，如果需要使用多次则必须将该数据通路单元复制多份。\n控制信号是CU根据指令操作码发出的信号，对于单周期处理器来说，每条指令的执行只有一个时钟周期，而在一个时钟周期内控制信号并不会变化。\n单周期数据通路必须有独立的指令存储器和数据存储器，因为处理器在一个周期内只能操作每个部件一次，而在一个周期内不可能对一个单端口存储器进行两次存取。且无法使用单总线数据通路，因为单总线数据通路将所有寄存器的输入出端都连接在一条公共通路上，一个时钟内只允许一次操作，无法完成指令的所有操作。\nTSL指令实现互斥 1 2 3 4 5 6 do { while (TSL(\u0026amp;lock)); critical section; lock = FALSE; ...... } while (TRUE); 退出临界区的进程负责唤醒就绪态进程？\n因为在TSL方法下，一个进程只有两种状态：\n运行态：用户处于了do{ }中，那么不管是是在其中的while (TSL(\u0026amp;lock))不断地循环，还是在访问临界资源，都是占用着CPU的，也就是处于运行态； 就绪态：若是在执行过程中由于并发所需要（如时间片到了），被其他进程占用了CPU，就变成了就绪态； 但是不会处于阻塞态，因为若是在等待临界资源，则会一直处于while (TSL(\u0026amp;lock));中，而且不会主动放弃CPU变成阻塞态（阻塞是一个主动的过程）。故不存在阻塞态的进城来给退出临界区的进程唤醒。\n等待进入临界区的进程不会主动放弃CPU，故上述代码不满足“让权等待”的同步准则。因为会一直停留在执行while(TSL(\u0026amp;lock))的循环中，该语句应在开中断下进行，否则一直处于该循环且不被其他进程中断可能会导致系统终止。\n操作系统的发展 手工发展阶段（无操作系统）：\n所有工作都要人干预，用户独占全机。\n特点：用户独占全机、CPU等待手工操作；\n缺点：人机矛盾及 CPU 和 I/O 设备之间速度不匹配的矛盾，因此发展出了批处理系统。\n批处理阶段（开始出现操作系统）：\n单道批处理：系统对作业的处理是成批进行的，但内存中始终保持一道作业。\n特点：单道性、自动性、顺序性。\n缺点：每次主机内存中仅存放一道作业，每当它在运行时发出I/O请求后，高速的 CPU 便处于等待低速的 I/O 完成的状态。\n为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。 多道批处理：多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU 中交替地运行。\n特点：多道、宏观上并行、微观上串行。\n优点：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用；系统吞吐量大， CPU 和其他资源保持“忙碌”状态。 缺点：用户响应的时间较长；不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。 因此发展出了分时操作系统。 分时操作系统：\n分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时（同时性）与主机进行交互（交互性）操作而互不干扰（独立性）。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意（及时性）。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统。\n特点：同时性、交互性、独立性、及时性。\n优点：较好地解决了人机交互问题。\n缺点：在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统），因此，实时操作系统应运而生。\n描述 特点 优点 缺点 手工操作阶段 所有工作都要人干预 用户独占全机、CPU等待手工操作； 不会出现因资源己被其他用户占用而等待的情况 资源利用率低，人机矛盾及 CPU 和 I/O 设备之间速度不匹配的矛盾，因此发展出了批处理系统。 单道批处理 系统对作业的处理是成批进行的，但内存中始终保持一道作业。 单道性、自动性、顺序性。 （开始出现操作系统） 每次主机内存中仅存放一道作业，每当它在运行时发出I/O请求后，高速的 CPU 便处于等待低速的 I/O 完成的状态。 为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。 多道批处理 多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU 中交替地运行。 多道性、宏观上并行、微观上串行。 资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用；系统吞吐量大， CPU 和其他资源保持“忙碌”状态。 用户响应的时间较长；不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。 因此发展出了分时操作系统。 分时操作系统 用户可以同时（同时性）与主机进行交互（交互性）操作而互不干扰（独立性）。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意（及时性）。 同时性、交互性、独立性、及时性。 较好地解决了人机交互问题。 在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统），因此，实时操作系统应运而生。 实时操作系统 为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。资源利用率不是其主要追求目标。 及时性、可靠性 管程 管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。管程不仅能实现进程间的互斥，而且能实现进程间的同步。","title":"真题总结2"},{"content":"10年 平衡二叉树的调整 LL调整 RR调整 RL调整 例如（原谅我图画的难看😂）：\nLR调整 二分查找的次数（成功失败）、折半查找判定树与二叉搜索树的关系 平衡二叉树是一种特殊的二叉查找树，它要求任何节点的两棵子树的高度差不超过1（同一棵树的不同节点的子树高度差可以为1、0、-1）。平衡二叉树通过在插入和删除节点时做旋转来维持树的平衡。\n折半查找判定树是一种特殊的平衡二叉树，它要求更加严格。同一棵树节点的左子树和右子树的差不能同时存在1和-1（即为统一向上取整或统一向下取整）。查找时，根据比较的结果折半排除一边的树。折半查找判定树中，只有最下面一层才可以不满。 根据完全二叉树的高度计算公式，元素个数为n时，树高 $h=\\lceil log_2(n+1)\\rceil$ 或 $h=\\lfloor log_2(n)\\rfloor+1$ 。在折半查找中，\n查找成功的最小比较次数为1，最大比较次数为$h$； 查找失败的最小比较次数为：若$n=2^h-1$，则为$h$，否则为$h-1$，最大比较次数：$h$。 数据类型转换造成的精度丢失等问题 将高精度数转换为低精度数可能会引起：\n精度丢失：高精度数通常能够表示更大范围和更高精度的数字，但当将其转换为低精度数时，可能会导致小数部分被截断或丢失，从而引起精度丧失。 溢出：如果高精度数的值超出了低精度数所能表示的范围，会导致溢出。 将整型数转换为浮点数一般不会出现问题，但特殊情况下会导致精度丢失，对于非常大或非常小的整数，可能无法精确表示。如int类型数据二进制表示有32位，但是对于float类型，在IEEE 754格式下，尾数部分只有23位，可能无法完全表示某一个int类型数，造成精度的丢失。 单精度与双精度浮点数的运算也有可能会有一些问题，例如10年真题$T_{14}$，$f=1.5678e3,d=1.5e100$，进行$(d+f)-d$运算，在$d+f$时，需要先进行对阶（小阶向大阶对齐），由于格式中的尾数限制，对阶后，$f$的尾数被舍去而变成了0，故$d+f$仍然为$d$，再减去$d$结果为0，而不是$f$。\n字扩展、位扩展与相关的芯片最低地址问题 位扩展\n位扩展是指用若干片位数较少的存储器芯片构成给定字长的存储器，容量改变，位数改变，地址单元个数不变。\n在袁春风老师的《计算机系统基础》中的一个例子如下：\n注意到8个$16M\\times8bit$的芯片扩展构成一个128M内存条。在进行扩展之前，对于单个芯片，地址位数为24bit。即地址单元个数为$16M=2^{24}$ 。每个地址单元存储8bit。\n在进行扩展之后，$128M=2^{27}$，而行列地址位数加起来一共$24bit$，$2^{24}=16M$，则说明此次扩展为位扩展。一个地址单元中的数据位数增加，但是总的地址单元个数并未改变。\n12位行地址$i$和12位列地址$j$分别送到DRAM芯片内部的行地址译码器和列地址译码器，选择行列地址交叉点$(i,j)$的8位数据同时进行读写，8个芯片就可以同时读取64bit，组合成总线所需要的64位传输宽度，再通过存储器总线进行传输。\n字扩展\n字扩展，容量改变，地址单元个数改变，即地址位数会改变，位数不会改变。\n另外，对于某一存储器，由多个DRAM经过字扩展而成，那么对于单个DRAM芯片来说，其行地址RAS位数、列地址CAS位数也不会变，但是整体存储器的总地址位数会变，会增加片选信号位数。 此时，对于一个主存地址，可以理解为芯片序号+芯片内的位置 。 也就是说，无论是位扩展还是字扩展，对于单一的DRAM芯片，其行列地址位数均不含会改变。（14年T15）\n引起进程状态改变的一些典型事件 进程状态可以在以下情况下发生改变：\n创建新进程：当操作系统启动一个新的程序时，会创建一个新的进程，并将其状态设置为就绪状态。\n进程等待：当一个进程等待某些事件发生，例如等待用户输入、等待某个文件就绪等，它的状态会从运行状态变为阻塞状态。\n时间片用完：如果一个进程在分配给它的时间片用完之后，调度器会将其状态从运行状态变为就绪状态，降低其进程优先级，然后选择下一个要执行的进程。\nI/O操作完成：当一个进程等待的I/O操作完成后，它的状态会从阻塞状态变为就绪状态。\n进程终止：当一个进程完成了它的任务，或者由于某种原因需要被终止，它的状态会从运行状态变为终止状态。\n进程被阻塞的资源可用：当一个进程等待的资源（如锁或信号量）变为可用时，它的状态会从阻塞状态变为就绪状态。设备分配是在一个已经存在的进程中进行的，不会导致创建新进程。\n进程被唤醒：在多任务环境中，一个进程可能会被另一个进程唤醒，使得它从阻塞状态变为就绪状态。\n进程被挂起或恢复：操作系统可以将一个进程从内存中挂起（暂时移出内存）或者从挂起状态恢复（重新加载到内存中）。\n父进程等待子进程：当一个父进程等待其子进程结束时，它的状态可能会从运行状态变为阻塞状态。\n发生错误或异常：当一个进程遇到错误或异常情况时，它的状态可能会从运行状态变为终止状态或者阻塞状态（如果它在等待某些事件发生时发生了错误）。\nIO系统的分层结构 碰撞域、广播域 冲突域：在同一个冲突域中，每一个结点都能收到所有其他结点发送的帧。简单地说，冲突域为同一时间内只能有一台设备发送信息的范围。 广播域：网络中能接收任意设备发出的广播帧的所有设备的集合。即，如果站点发出一个广播信号，所有能接收到这个信号的设备范围被称为一个广播域。 通常一个网段为一个冲突域，一个局域网为一个广播域。\n磁盘的调度策略 磁盘调度算法是操作系统中用于管理磁盘上的I/O请求的一种策略。以下是一些常见的磁盘调度算法：\n先来先服务（FCFS）：最简单的磁盘调度算法，按照请求的到达顺序依次执行。但可能会出现“早来的请求等待时间长”的问题。 最短寻道时间优先（SSTF）：选择当前磁头位置最近的请求进行服务，以最小化寻道时间。但可能会导致某些请求长时间等待。 SCAN算法：扫描算法，也称为电梯算法，类似于电梯的运行方式，磁头按一个方向移动，直到最后一个磁道后再改变方向。 C-SCAN算法：循环扫描算法，磁头按同一个方向移动，直到到达最后一个磁道后，立即直接返回到磁道0处，再继续扫描。 LOOK 算法：类似于扫描算法，但在到达最远的请求后不会立即返回，而是根据当前请求的方向决定下一个服务的磁道。在朝一个给定方向移动前查看是否有请求。 C-LOOK 算法：类似于 C-SCAN 算法，但在到达最远的请求后不会立即返回，而是直接返回到最远端的有请求的磁道。 注意，在做题时，若无特别说明，也可以默认SCAN算法和C-SCAN算法为LOOK和C-LOOK调度。\n09年 B树与B+树的异同 B树和B+树都是一种常用的多路搜索树数据结构，用于存储有序的数据集合，特别是在磁盘存储和数据库系统中应用广泛。\n数据存储： B树：B树的叶子节点和非叶子节点的结构基本相同，都可以存储数据。 B+树：在B+树中，只有叶子节点存储数据，非叶子节点只存储索引（有点像文件管理中的索引顺序文件），叶子节点之间通过指针连接，形成一个有序的链表。 范围查询效率： B树：由于B树的叶子节点也存储数据，因此可以直接进行范围查询。 B+树：由于B+树的非叶子节点不存储数据，只有叶子节点存储数据，因此范围查询需要在叶子节点构成的链表上进行。 查询性能： B树：由于B树的非叶子节点也存储数据，单次查询可能直接在非叶子节点找到结果，因此查询性能相对于B+树可能更快。 B+树：B+树的查询性能相对于B树可能稍慢，因为每次查询都需要在叶子节点链表上进行。 浮点数加减的步骤（IEEE 754） 正常方法：对阶（小阶向大阶对齐）、尾数运算、规格化（左规、右规）、舍入、判断溢出（判断舍入后的阶数是否超过了所能表示的范围）；\n偷懒方法：直接计算（按照大的阶数）、在规格化后判断是否溢出（判断阶数是否超过了所能表示的范围）（如10年T13）\nCISC与RISC的区别 CISC 指令系统设计的主要特点如下：\n指令系统复杂且多。指令条数多，寻址方式多，指令格式多而复杂，指令长度可变，操作码长度可变。 各种指令都能访问存储器，有些指令还需要多次访问存储器。 不利于实现流水线。因为指令周期长且差距大。绝大多数指令需要多个时钟周期才能完成，简单指令和复杂指令所用的时钟周期数相差很大。 复杂指令系统使得其实现越来越复杂，不仅增加了研制周期和成本，而且难以保证正确性，甚至因为指令太复杂而无法采用硬连线路控制器，导致大多数系统只能采用慢速的微程序控制器。 难以进行编译优化。由于编译器可选指令序列增多，使得目标代码组合增加，从而增加了目标代码优化的难度。 相关指令会产生显式的条件码，存放在专门的标志寄存器（或称状态寄存器）中，可用于条件转移和条件传送等指令。 相较于CISC，RISC 指令系统设计的主要特点如下：\n**指令数目少且规整。**只包含使用频度高的简单指令，寻址方式少，指令格式少，指令长度一致，指令中操作码和寄存器编号等位置固定，便于取指令、指令译码以及提前读取寄存器中操作数等。 采用 load/store 型指令设计风格。一条指令的执行阶段最多只有一次存储器访问操作。 采用流水线方式执行指令。规整的指令格式有利于采用流水线方式执行，除 load/store指令外，其他指令都只需一个或小于一个时钟周期就可完成，指令周期短。 采用硬连线路控制器。指令少而规整使得控制器的实现变得简单，可以不用或少用微程序控制器。 指令数量少，固然使编译工作量加大，但由于指令系统中的指令都是精选的，编译时间少，反过来对编译程序的优化又是有利的。 采用大量通用寄存器。编译器可将更多的局部变量分配到寄存器中，并且在过程调用时通过寄存器进行参数传递而不是通过栈进行传递，以减少访存次数。 硬布线控制器与微程序控制器的对比 硬布线控制器 微程序控制器 实现方式 通过硬件电路来实现的，通常是由逻辑门、寄存器和触发器等组件组成。 使用一组存储在控制存储器中的微指令序列来实现。 性能 硬件实现，因此执行速度通常非常快 略慢一些，每个微指令的执行需要额外的时钟周期。 复杂性 较高 相对更为简单 灵活性 控制逻辑固定在硬件中，不容易进行修改或升级，缺乏灵活性。 可以通过修改控制存储器中的微指令来改变控制逻辑，灵活性较高。 文件访问控制 口令保护 为文件设置一个“口令“，用户想要访问文件时需要提供口令，由系统验证口令是否正确。 实现开销小，但“口令“一般存放在FCB或索引结点中（也就是存放在系统中）因此不太安全。 加密保护 用一个“密码“对文件加密，用户想要访问文件时，需要提供相同的“密码“才能正确的解密。 安全性高，即使文件被非法获取，没有密码也无法正确读取其中的内容。但加密/解密需要耗费一定的时间。 访问控制 用一个访问控制表 (ACL) 记录各个用户（或各组用户）对文件的访问权限，对文件的访问类型可以分为，读写/执行/删除等。 实现灵活，可以实现复杂的文件保护功能，存放文件访问控制信息的合理位置为FCB或索引节点。 软硬链接的区别 硬链接 硬链接的实现只是在要创建链接的目录中创建了另一个名称，并将其指向原有文件的相同inode号（即低级别名称）。该文件不以任何方式复制。在创建文件的硬链接之后，在文件系统中，原有文件名（file）和新创建的文件名（file2）之间没有区别。实际上，它们都只是指向文件底层元数据的链接，可以在同一个inode中找到。 硬链接有个局限在于：不能创建目录的硬链接（因为担心会在目录树中创建一个环）。不能硬链接到其他磁盘分区或文件系统中的文件（因为 inode 号在特定文件系统中是唯一的，而不是跨文件系统）等等。注意：在Windows操作系统中，磁盘分区通常是以盘符（如C盘、D盘等）来表示的，但这并不等同于Unix或类Unix系统中的文件系统中的概念。如果C盘和D盘属于同一物理磁盘（硬盘），可以在它们之间创建硬链接。然而，如果它们代表了两个不同的物理磁盘，那么在它们之间创建硬链接通常是不可能的。 符号链接（软链接） 因此，人们创建了一种称为符号链接（软链接）的新型链接。符号链接本身实际上是一个不同类型的文件。除了常规文件和目录之外，符号链接是文件系统知道的第三种类型。因为形成符号链接的方式是指向文件的路径名作为链接文件的数据，所以符号链接文件的大小于所指向的文件的路径名的长度有关系，且有可能造成所谓的悬空引用。 奈奎斯特定理和香农定理 奈奎斯特定理规定，为了避免信号在数字化过程中产生失真，需要以至少两倍于信号最高频率的采样率对信号进行采样。\nFTP 在FTP中，数据传输可以采用两种模式：主动模式和被动模式。\n主动模式：\n客户端向FTP服务器的默认数据端口（通常是端口20）发起连接请求，请求建立数据连接。 服务器在接收到客户端的连接请求后，会从自己的数据端口（通常是端口20）向客户端的随机端口发起连接请求，请求建立数据连接。（服务器发起数据连接请求） 被动模式：\n客户端向FTP服务器的命令端口（通常是端口21）发送PASV命令，请求进入被动模式。 服务器收到PASV命令后，会打开一个随机的端口，监听客户端的连接请求，同时将该端口号发送给客户端。 客户端收到服务器返回的端口号后，会从自己的端口向服务器的指定端口发起连接请求，请求建立数据连接。（客户端发起数据连接请求） 11年 计算机性能评价相关词条 IEEE 754格式化 IEEE 754单精度浮点数的解释\n值的类型 符号 阶码 尾数 值 正零 $0$ $0$ $0$ $0$ 负零 $1$ $0$ $0$ $-0$ 正无穷大 $0$ $255(全1)$ $0$ $\\infty$ 负无穷大 $1$ $255(全1)$ $0$ $-\\infty$ 无定义数（非数） $0或1$ $255(全1)$ $\\ne0$ $\\text{NaN}$ 规格化非零正数 $0$ $0\u0026lt;e\u0026lt;255$ $f$ $2^{e-127}(1.f)$ 规格化非零负数 $1$ $0\u0026lt;e\u0026lt;255$ $f$ $-2^{e-127}(1.f)$ 非规格化正数 $0$ $0$ $f\\ne0$ $2^{126}(0.f)$ 非规格化负数 $1$ $0$ $f\\ne0$ $-2^{126}(0.f)$ IEEE 754的范围\n格式 最小值 最大值 单精度 $E=1,M=0$$1.0\\times2^{1-127}=2^{-126}$ $E=254,M=.111\\cdots,1.111\\cdots1\\times2^{254-127}=2^{127}\\times(2-2^{-23})=2^{128}-2^{104}$ 双精度 $E=1,M=0$$1.0\\times2^{1-1023}=2^{-1022}$ $E=2046,M=.111\\cdots,1.111\\cdots1\\times2^{2046-1023}=2^{1023}\\times(2-2^{-52})=2^{1024}-2^{971}$ 加减法法电路 电路\n标志位\n系统总线的各条线传输的是什么 在取指令时，指令便是在数据线上传输的。操作数显然在数据线上传输。中断类型号用以指出中断向量的地址，CPU响应中断请求后，将中断应答信号 (INTR) 发回到数据总线上，CPU从数据总线上读取中断类型号后，查找中断向量表，找到相应的中断处理程序入口。而握手（应答）信号属于通信联络控制信号，应在通信总线上传输。\nOSI模型与TCP/IP模型各层的功能区别 OSI模型：\n物理层：解决使用何种信号来传输比特0和1的问题。负责定义物理媒介、传输速率、编码方法等，提供了物理介质上的原始数据传输。 数据链路层：解决帧在一个网络（或一段链路）上传输的问题。负责数据帧的传输、接收、错误检测和纠正，确保数据在物理层上可靠地传输。 网络层：解决分组在多个网络之间传输（路由）的问题。负责在不同网络之间进行路由选择，进行分组的转发和寻址，以及定义子网等网络层面的逻辑结构。 传输层：解决进程之间基于网络的通信问题。提供端到端的通信，保证数据的可靠传输，处理数据的分段和重组，以及流量控制和拥塞控制。 会话层：解决进程之间进行会话的问题。建立、管理和终止会话连接，提供了通信会话的控制和同步功能。 表示层：解决通信双方交换信息的表示问题。负责数据的格式转换、加密解密、压缩解压缩等，保证数据的可靠传输。 应用层：解决通过应用进程之间的交互来实现特定网络应用的问题。为用户提供各种网络应用服务，如文件传输、电子邮件、远程登录等。 TCP/IP模型：\n应用层：与OSI模型的应用层类似，提供网络应用服务。\n传输层：与OSI模型的传输层类似，负责提供端到端的通信服务。\n网络层：与OSI模型的网络层类似，负责在不同网络之间进行路由选择。\n链路层：包括了OSI模型的物理层和数据链路层的功能，负责在相邻节点间提供可靠的数据传输。\n在实际应用中，TCP/IP模型是目前广泛使用的网络模型，而OSI模型在理论上用于描述通信系统的功能。\n对正确接收到的数据帧进行确认的MAC协议 为什么是CSMA/CA协议？\nCSMA/CA协议，是一种用于在无线网络中进行数据通信的协议，针对无线环境中信道容量有限、易受干扰的特点而设计。它采用了一些机制来避免碰撞并提高数据传输的可靠性：\n监听信道：发送方在发送数据前会先监听信道，确保信道是空闲的，避免发生碰撞（减少概率，不能一定避免）。\nRTS/CTS帧：在CSMA/CA中，还引入了请求发送（Request to Send，RTS）和清除发送（Clear to Send，CTS）帧的概念。发送方在发送数据前会先发送一个RTS帧，接收方如果收到并确认了RTS帧，就会发送一个CTS帧给发送方，表示信道已经为发送方保留。这个过程可以有效避免隐藏节点问题和减少碰撞的发生。\n等待确认：发送方在发送数据后会等待接收方的确认，只有在收到确认后才会发送下一个数据帧。\n重传机制：如果发送方没有收到确认，会认为数据帧可能丢失，会进行重传。\n特殊的IP及其作用、使用方法 以下是RFC文档中的内容Special-Use IPv4 Addresses RFC 3330\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Address Block Present Use Reference --------------------------------------------------------------------- 0.0.0.0/8 \u0026#34;This\u0026#34; Network [RFC1700, page 4] 10.0.0.0/8 Private-Use Networks [RFC1918] 14.0.0.0/8 Public-Data Networks [RFC1700, page 181] 24.0.0.0/8 Cable Television Networks -- 39.0.0.0/8 Reserved but subject to allocation [RFC1797] 127.0.0.0/8 Loopback [RFC1700, page 5] 128.0.0.0/16 Reserved but subject to allocation -- 169.254.0.0/16 Link Local -- 172.16.0.0/12 Private-Use Networks [RFC1918] 191.255.0.0/16 Reserved but subject to allocation -- 192.0.0.0/24 Reserved but subject to allocation -- 192.0.2.0/24 Test-Net 192.88.99.0/24 6to4 Relay Anycast [RFC3068] 192.168.0.0/16 Private-Use Networks [RFC1918] 198.18.0.0/15 Network Interconnect Device Benchmark Testing [RFC2544] 223.255.255.0/24 Reserved but subject to allocation -- 224.0.0.0/4 Multicast [RFC3171] 240.0.0.0/4 Reserved for Future Use [RFC1700, page 4] 12年 上三角矩阵和拓扑排序 若用邻接矩阵存储有向图，矩阵中主对角线及以下的元素均为零（或主对角线及以上的元素均为零），则该图的拓扑序列一定存在，但不一定唯一。\n例如，如果一个有向图使用邻接矩阵进行存储，并且矩阵中主对角线及以下的元素均为零，那么这个图的拓扑序列一定存在。因为拓扑序列是一个图中所有顶点的线性排序，使得对于每一条有向边 \u0026lt;u,v\u0026gt;，顶点 u 在序列中都出现在顶点 v 之前。在这种情况下，由于主对角线以下的元素都是零，表明没有顶点指向自己，也就不存在环路，因此必然存在拓扑排序。\n然而，拓扑序列可能不是唯一的。这是因为在一个有向无环图中，可能存在多个顶点没有前驱（即入度为零），这些顶点的相对顺序可以任意排列，只要它们在拓扑排序中排在其他顶点之前即可。因此，可能存在多个合法的拓扑序列。\n反之，如果存在拓扑序列，邻接矩阵不一定满足主对角线及以下的元素均为零（或主对角线及以上的元素均为零）。\n数据线、地址线、控制线 参考【组成原理·总线】总线的概念和计算\n在单总线结构中：\n数据线：用于在各个设备（包括CPU、主存、外设）之间传递数据。\n地址线：传输地址信息，用于指示要访问的特定内存单元或外设的地址。地址线的数量决定了总线的寻址能力，也就是可以寻址的内存或设备数量。\n控制线：传输各种控制信号，如读取、写入、使能等信号，以控制数据的流动和操作。控制线还可能包括时钟信号等。也可以传输主存返回 CPU 的反馈信号。\n在IO接口中：\n数据线：可以传输IO接口中的命令字、状态字、中断类型号，在接口中的数据缓冲寄存器、内存、CPU中的寄存器之间进行数据传送。**（可双向传输）**同时接口和设备的状态信息被记录在状态寄存器中，通过数据线将状态信息送到 CPU。CPU 对外设的控制命令也通过数据线传送。 地址线：接口中的地址线用于给出要访问的 I/O 接口中的寄存器的地址，它和读/写控制信号一起被送到 I/O 接口的控制逻辑部件。(只能单向) 控制线：通过控制线传送来的读/写信号确认是读寄存器还是写寄存器，此外控制线还会传送一些仲裁信号和握手信号。（只能单向） 中断处理和子程序调用的区别 触发方式： 中断处理：中断是由硬件或外部事件触发的。当发生了某个预定义的事件（如设备输入、时钟周期等），硬件会暂停当前程序的执行，并跳转到相应的中断处理程序中执行。 子程序调用：子程序调用是由程序内部通过软件指令来触发的。程序会通过调用指令跳转到指定的子程序中执行，执行完后再返回到原来的程序。 上下文切换： 中断处理：中断处理涉及到从用户态切换到内核态，然后再返回用户态的过程。这涉及到硬件和操作系统的支持，需要保存和恢复相应的寄存器和状态，如断点（PC）、程序状态字寄存器（PSW）。（中断处理中最重要的两个寄存器） 子程序调用：子程序调用是在同一程序执行流中完成的，没有涉及到从用户态到内核态的切换。因此，它比中断处理的上下文切换开销要小，只需要保存程序断点。 异步性质： 中断处理：中断是异步的，它可以随时发生并打断当前的程序执行。因此，中断处理必须能够处理不可预知的事件。 子程序调用：子程序调用是同步的，它是由程序内部明确地发起的，执行完子程序后会继续执行后续的指令。 权限级别： 中断处理：中断处理通常需要在内核态执行。 子程序调用：子程序可以在用户态或内核态中执行，具体取决于程序的权限和需要。 物理接口各个特性的功能 机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压的范围。 功能特性：指明某条线上出现的某一电平的电压表示何种意义。 过程特性：或称规程特性。指明对于不同功能的各种可能事件的出现顺序。 协议的三部分 协议由语法、语义和同步三部分组成。\n语法规定了传输数据的格式； 语义规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答； 同步规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。 一个完整的协议通常应具有线路管理（建立、释放连接）、差错控制、数据转换等功能。协议并不关心具体如何实现，只要求实现什么功能。\n各层协议有无连接、可不可靠？ 数据链路层：\n以太网的MAC协议提供的是无连接不可靠服务：考虑到局域网信道质量好，以太网采取了两项重要的措施以使通信更简便：采用无连接的工作方式；不对发送的数据帧进行编号，也不要求对方发回确认。因此，以太网提供的服务是不可靠的服务，即尽最大努力的交付。差错的纠正由高层完成。 无线局域网的MAC协议提供的是无连接可靠服务：并没有“握手”的过程，即传输数据之前并没有连接。 网络层：\nIP协议提供的是无连接不可靠服务：IP协议不需要在传输数据前建立连接，也不需要在传输过程中保持连接状态。每个IP数据包都是独立传输的，它们之间没有直接的关联。IP数据包的传输是不可靠的，这意味着它们可能会丢失、延迟、重复或者乱序。IP协议不提供任何机制来保证数据的可靠性，也不负责处理丢失的数据包。 传输层：\nTCP协议提供的是有连接可靠服务：通过序号、确认、重传等机制来保证数据的完整性和有序性。 UDP协议提供的是无连接不可靠服务：将数据分割成报文段，并将报文段发送到目标，无需建立连接或维护会话状态。但是可以通过在应用层实现自定义的可靠性机制，使得UDP的通信变得可靠。 协议A直接为协议B提供服务 协议A 协议B TCP BGP IP OSPF UDP RIP IP ICMP IP TCP IP UDP UDP DNS TCP HTTP TCP SMTP TCP POP3 IP IGMP TCP FTP 13年 最佳归并树 有n个初始归并段，需要做k路平衡归并排序，可以根据哈夫曼树的思想来优化WPL。\nRAID相关知识 RAID0方案是无冗余和无校验的磁盘阵列，而RAID1-5方案均是加入了冗余（镜像）或校验的磁盘阵列。能够提高 RAID 可靠性的措施主要是对磁盘进行镜像处理和奇偶校验。\n条带化技术是一种自动地将I/O的负载均衡到多个物理磁盘上的技术。条带化技术就是将一块连续的数据分成很多小部分并把它们分别存储到不同磁盘上去。这就能使多个进程同时访问数据的多个不同部分但不会造成磁盘冲突，而且在需要对这种数据进行顺序访问的时候可以获得最大程度上的I/O并行能力，从而获得非常好的性能。\n中断I/O方式和DMA方式的比较 中断处理方式： 在设备输入每个数据的过程中，由于无须 CPU 干预，因而可使CPU与I/O设备并行工作。仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理，因此中断申请使用的是 CPU 处理时间； 中断响应发生的时间是在一条指令执行结束之后； 数据是在软件（中断服务程序）的控制下完成传送的。 DMA方式： 数据传输的基本单位是数据块； 每个数据块传送完毕时，都会发生DMA请求，DMA请求每次申请的是总线的使用权，所传送的数据是从设备直接送入内存的，或者相反； 仅在传送一个或多个数据块的开始和结束时，才需 CPU 干预，整块数据的传送是在硬件（DMA控制器）的控制下完成的。 IO密集型的进程和计算密集型的进程优先级 当系统中存在大量IO密集型任务时，优先处理这类任务可以减少IO等待时间，提高IO设备的利用率，同时可以充分利用CPU资源等待IO操作完成。\n操作系统的加载 操作系统最终被加载到RAM中。\n预防死锁、避免死锁的区别 预防死锁：预防死锁的方法是在设计阶段就采取措施，使得系统不会发生死锁。这种方法主要通过破坏死锁产生的四个必要条件（互斥访问、不可剥夺、请求和保持、循环等待）来实现。预防死锁是一种静态的、全局的策略，需要在系统设计和实施阶段进行考虑和实施。 避免死锁：避免死锁是在系统运行时根据进程的动态行为来避免死锁的发生。这种方法会通过对资源的合理分配和释放（如银行家算法）来避免进入死锁状态。避免死锁是一种动态的、局部的策略，根据当前系统状态来进行判断和处理。 物理层基带传输信号 图源《通信原理》（樊昌信\u0026ndash;第六版）\n(a) 单极性非归零编码\n(b) 双极性非归零编码\n(c) 单极性归零编码\n(d) 双极性归零编码\n(e) 差分编码\n图源王道《计算机网络考研复习指导》\n以太网使用的编码方式就是曼彻斯特编码\nSMTP协议 14年 指令cache与数据cache分离的主要目的 可以减少指令流水线资源冲突。如一个进程在取指令时，另一条指令可以同时取数据。\n管道通信的定义、特点 **管道是驻留在内存中的伪文件，可以使用标准文件函数对其进行访问。**与磁盘文件不同，它是临时的，且并不占用磁盘或者其他外部存储的空间，而是占用内存空间。Linux系统直接把管道实现成了一种文件系统，借助VFS给应用程序提供操作接口。所以，Linux上的管道就是一个操作方式为文件的内存缓冲区。 管道的容量大小通常为内存上的一页，它的大小并不是受磁盘容量大小的限制。 它常用于父子进程之间的通信。类似于通信中半双工信道的进程通信机制，一个管道同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。若要实现父子进程双向通信，则需要定义两个管道。 一个进程可以向管道写入数据，另一个进程可以同时从管道读取数据。当管道满时，进程在写管道会被阻塞，而当管道空时，进程在读管道会被阻塞。 从管道读数据是一次性操作，数据一旦被读取，就释放空间以便写更多数据。 关于管道不是文件这一点，参考知乎文章Linux 的进程间通信：管道以及Windows应用开发\n交换区和内存映射 内存映射和交换区（Swap）都是操作系统中用于管理内存的重要机制，但它们有着不同的作用和实现方式。\n内存映射：\n作用：内存映射是一种将磁盘上的文件或设备映射到进程的地址空间中的机制。它允许程序直接访问磁盘上的文件，而无需通过常规的文件读写操作。通过内存映射，程序可以将文件的内容视为内存中的一部分，从而实现对文件的高效访问。\n实现：内存映射是通过将磁盘文件的某个区域映射到进程的虚拟地址空间中，从而让程序可以直接读写这块区域的内容。在某种程度上，内存映射可以看作是文件和内存之间的一个透明的接口。\n交换区：\n作用：交换区是一块硬盘空间，用于暂时存储在物理内存中暂时不活跃的数据和程序。当物理内存不足以容纳当前运行的程序和数据时，操作系统会将一部分数据移到交换区中，从而释放出物理内存。\n实现：交换区是一块硬盘或者固态硬盘的空间，它用于作为物理内存的扩展。当系统需要释放物理内存时，它会将部分不活动的数据和程序写入到交换区中。当需要时，可以将交换区中的数据重新读取到物理内存中。\n区别：\n作用不同：内存映射主要用于实现文件和内存之间的高效访问，而交换区用于在物理内存不足时暂存数据。\n实现方式不同：内存映射是通过将文件或设备映射到进程的地址空间中实现的，而交换区是通过将部分不活动的数据写入到硬盘空间中实现的。\n适用场景不同：内存映射适用于需要频繁访问文件内容的场景，而交换区是用于解决物理内存不足的问题。\n15年 卡特兰数 $\\frac{1}{n+1}C^n_{2n}$\n例如，n个不同的元素进栈，出栈元素不同排列的个数为$\\frac{1}{n+1}C^n_{2n}$\n例如，求先序序列为abcd的不同二叉树的个数也可以利用此解法：\n根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以题意相当于“以序列abcd为入栈次序，则出栈序列的个数为多少”，对于n个不同元素进栈，出栈序列的个数为卡特兰数。\n堆调整时的比较次数 例如，对于大根堆：\n调整乱序初始堆：从全部结点的一半处n/2，开始调整： 调整i及其子树：向下调整：需要先两个孩子进行比较，再和较大者进行交换； i\u0026ndash;：对左兄弟结点或父结点进行调整，重复上一步。 插入节点后：自底向上比较调整，每次向上调整，只需要和父节点进行比较，如果比父节点大，则上移，否则不动；而不是先和兄弟节点比较谁大，因为兄弟节点必定比父节点小。 删除节点后：自顶向下比较调整，每次上下调整，需要先两个孩子进行比较，再和较大者进行交换，因为本节点和两个孩子的大小关系、两个孩子之间的大小都未知。 浮点数溢出问题 对阶操作不会引起阶码上溢或下溢（小阶向大阶对齐，这里前提是小阶能对齐到大阶，如果大的阶数超过了小阶数的阶码所能表示的范围，那么对阶时也会发生溢出）； 左规时可能引起阶码下溢； 右规和尾数舍入（0舍1入法）都可能引起阶码上溢； 尾数溢出时，结果不一定溢出，因为尾数溢出可以通过右规操作来纠正，结果可能产生误差，但不一定会溢出。 DRAM的刷新 对于ROM，即使断电信息也不会丢失。\n对于SRAM，其存储元（区别于存储单位）是双稳态触发器（六晶体管MOS），即使信息被读出后，仍保持原状态而不需要再生（非破坏性读出）。但是断电后信息会丢失。\n对于DRAM，其存储元通常只使用一个晶体管。DRAM电容上的电荷一般只能维持1~2ms，即使电源不断电，信息也会自动消失，因此必须每隔一段时间进行刷新，称为刷新周期，常见的刷新方式有3种：\n集中刷新：指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”。优点是读写操作时不受刷新工作的影响；缺点是在集中刷新期间不能访问存储器。 分散刷新：把对每行的刷新分散到各个工作周期中。这样，一个存储器的系统工作周期分为两部分：前半部分用于正常读、写或保持；后半部分用于刷新。优点是没有死区；缺点是加长了系统的存取周期。 异步刷新：异步刷新是前两种方法的结合。具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求。这样可以避免使CPU连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率。 DRAM 的刷新需要注意以下问题：\n刷新对CPU是透明的，即刷新不依赖于外部的访问，不需要CPU控制； DRAM的刷新单位是行，由芯片内部自行生成行地址； 刷新操作类似于读操作，但又有所不同。另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。 总线定时 **同步定时方式：**系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。\n异步定时方式：没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。\n不互锁方式：主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号。双方不存在互锁关系。速度最快，可靠性最差 半互锁方式：主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系； 全互锁方式：主设备发出“请求”信号后，必须待从设备“回答”后，才撤销“请求”信号；从设备发出“回答”信号，必须待获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系。速度最慢，可靠性最好 优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。 缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢\n半同步定时方式：统一时钟的基础上，增加一个“等待”响应信号；\n分离式通信：$\\cdots$\nDHCP报文地址问题 ","permalink":"https://fireflyyh.top/posts/408/summary01/","summary":"10年 平衡二叉树的调整 LL调整 RR调整 RL调整 例如（原谅我图画的难看😂）：\nLR调整 二分查找的次数（成功失败）、折半查找判定树与二叉搜索树的关系 平衡二叉树是一种特殊的二叉查找树，它要求任何节点的两棵子树的高度差不超过1（同一棵树的不同节点的子树高度差可以为1、0、-1）。平衡二叉树通过在插入和删除节点时做旋转来维持树的平衡。\n折半查找判定树是一种特殊的平衡二叉树，它要求更加严格。同一棵树节点的左子树和右子树的差不能同时存在1和-1（即为统一向上取整或统一向下取整）。查找时，根据比较的结果折半排除一边的树。折半查找判定树中，只有最下面一层才可以不满。 根据完全二叉树的高度计算公式，元素个数为n时，树高 $h=\\lceil log_2(n+1)\\rceil$ 或 $h=\\lfloor log_2(n)\\rfloor+1$ 。在折半查找中，\n查找成功的最小比较次数为1，最大比较次数为$h$； 查找失败的最小比较次数为：若$n=2^h-1$，则为$h$，否则为$h-1$，最大比较次数：$h$。 数据类型转换造成的精度丢失等问题 将高精度数转换为低精度数可能会引起：\n精度丢失：高精度数通常能够表示更大范围和更高精度的数字，但当将其转换为低精度数时，可能会导致小数部分被截断或丢失，从而引起精度丧失。 溢出：如果高精度数的值超出了低精度数所能表示的范围，会导致溢出。 将整型数转换为浮点数一般不会出现问题，但特殊情况下会导致精度丢失，对于非常大或非常小的整数，可能无法精确表示。如int类型数据二进制表示有32位，但是对于float类型，在IEEE 754格式下，尾数部分只有23位，可能无法完全表示某一个int类型数，造成精度的丢失。 单精度与双精度浮点数的运算也有可能会有一些问题，例如10年真题$T_{14}$，$f=1.5678e3,d=1.5e100$，进行$(d+f)-d$运算，在$d+f$时，需要先进行对阶（小阶向大阶对齐），由于格式中的尾数限制，对阶后，$f$的尾数被舍去而变成了0，故$d+f$仍然为$d$，再减去$d$结果为0，而不是$f$。\n字扩展、位扩展与相关的芯片最低地址问题 位扩展\n位扩展是指用若干片位数较少的存储器芯片构成给定字长的存储器，容量改变，位数改变，地址单元个数不变。\n在袁春风老师的《计算机系统基础》中的一个例子如下：\n注意到8个$16M\\times8bit$的芯片扩展构成一个128M内存条。在进行扩展之前，对于单个芯片，地址位数为24bit。即地址单元个数为$16M=2^{24}$ 。每个地址单元存储8bit。\n在进行扩展之后，$128M=2^{27}$，而行列地址位数加起来一共$24bit$，$2^{24}=16M$，则说明此次扩展为位扩展。一个地址单元中的数据位数增加，但是总的地址单元个数并未改变。\n12位行地址$i$和12位列地址$j$分别送到DRAM芯片内部的行地址译码器和列地址译码器，选择行列地址交叉点$(i,j)$的8位数据同时进行读写，8个芯片就可以同时读取64bit，组合成总线所需要的64位传输宽度，再通过存储器总线进行传输。\n字扩展\n字扩展，容量改变，地址单元个数改变，即地址位数会改变，位数不会改变。\n另外，对于某一存储器，由多个DRAM经过字扩展而成，那么对于单个DRAM芯片来说，其行地址RAS位数、列地址CAS位数也不会变，但是整体存储器的总地址位数会变，会增加片选信号位数。 此时，对于一个主存地址，可以理解为芯片序号+芯片内的位置 。 也就是说，无论是位扩展还是字扩展，对于单一的DRAM芯片，其行列地址位数均不含会改变。（14年T15）\n引起进程状态改变的一些典型事件 进程状态可以在以下情况下发生改变：\n创建新进程：当操作系统启动一个新的程序时，会创建一个新的进程，并将其状态设置为就绪状态。\n进程等待：当一个进程等待某些事件发生，例如等待用户输入、等待某个文件就绪等，它的状态会从运行状态变为阻塞状态。\n时间片用完：如果一个进程在分配给它的时间片用完之后，调度器会将其状态从运行状态变为就绪状态，降低其进程优先级，然后选择下一个要执行的进程。\nI/O操作完成：当一个进程等待的I/O操作完成后，它的状态会从阻塞状态变为就绪状态。\n进程终止：当一个进程完成了它的任务，或者由于某种原因需要被终止，它的状态会从运行状态变为终止状态。\n进程被阻塞的资源可用：当一个进程等待的资源（如锁或信号量）变为可用时，它的状态会从阻塞状态变为就绪状态。设备分配是在一个已经存在的进程中进行的，不会导致创建新进程。\n进程被唤醒：在多任务环境中，一个进程可能会被另一个进程唤醒，使得它从阻塞状态变为就绪状态。\n进程被挂起或恢复：操作系统可以将一个进程从内存中挂起（暂时移出内存）或者从挂起状态恢复（重新加载到内存中）。\n父进程等待子进程：当一个父进程等待其子进程结束时，它的状态可能会从运行状态变为阻塞状态。\n发生错误或异常：当一个进程遇到错误或异常情况时，它的状态可能会从运行状态变为终止状态或者阻塞状态（如果它在等待某些事件发生时发生了错误）。\nIO系统的分层结构 碰撞域、广播域 冲突域：在同一个冲突域中，每一个结点都能收到所有其他结点发送的帧。简单地说，冲突域为同一时间内只能有一台设备发送信息的范围。 广播域：网络中能接收任意设备发出的广播帧的所有设备的集合。即，如果站点发出一个广播信号，所有能接收到这个信号的设备范围被称为一个广播域。 通常一个网段为一个冲突域，一个局域网为一个广播域。\n磁盘的调度策略 磁盘调度算法是操作系统中用于管理磁盘上的I/O请求的一种策略。以下是一些常见的磁盘调度算法：\n先来先服务（FCFS）：最简单的磁盘调度算法，按照请求的到达顺序依次执行。但可能会出现“早来的请求等待时间长”的问题。 最短寻道时间优先（SSTF）：选择当前磁头位置最近的请求进行服务，以最小化寻道时间。但可能会导致某些请求长时间等待。 SCAN算法：扫描算法，也称为电梯算法，类似于电梯的运行方式，磁头按一个方向移动，直到最后一个磁道后再改变方向。 C-SCAN算法：循环扫描算法，磁头按同一个方向移动，直到到达最后一个磁道后，立即直接返回到磁道0处，再继续扫描。 LOOK 算法：类似于扫描算法，但在到达最远的请求后不会立即返回，而是根据当前请求的方向决定下一个服务的磁道。在朝一个给定方向移动前查看是否有请求。 C-LOOK 算法：类似于 C-SCAN 算法，但在到达最远的请求后不会立即返回，而是直接返回到最远端的有请求的磁道。 注意，在做题时，若无特别说明，也可以默认SCAN算法和C-SCAN算法为LOOK和C-LOOK调度。","title":"真题总结1"},{"content":"本博客使用了Hugo等技术进行搭建，使用的主题为PaperMod，并对其进行了一定的修改，在这过程也参考了其他博客的实现，如Sulv\u0026rsquo;s Blog。\n你也可以通过以下途径联系我：\nGithub 邮箱 ","permalink":"https://fireflyyh.top/about/","summary":"about","title":"About me"}]