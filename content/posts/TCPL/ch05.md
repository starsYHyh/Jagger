---
title: "Cè¯­è¨€ç¨‹åºè®¾è®¡ç¬¬äºŒç‰ˆè¯¾åä¹ é¢˜--ç¬¬äº”ç« " 
date: 2024-10-11
draft: false
tags: ["TCPL"]
categories: ["Learning"]
---

> éƒ¨åˆ†ç­”æ¡ˆå‚è€ƒäº†å®˜æ–¹é¢˜è§£å’Œç½‘ä¸Šçš„ç­”æ¡ˆï¼Œä»…ä¾›å‚è€ƒï¼Œå¯èƒ½ä¹Ÿæœ‰éƒ¨åˆ†bugæœªå‘ç°æˆ–è§£å†³ã€‚ä»£ç åœ¨[gitee](https://gitee.com/starsyhyh/tcpllearning)ä¸Šé¢ã€‚ä¸€äº›é¢˜ç›®å› ä¸ªäººèƒ½åŠ›ä¸è¶³ï¼Œå†™ä¸å‡ºæ¥ï¼Œçœ‹ç€ç­”æ¡ˆéƒ½ä¸ä¼šå†™çš„é‚£ç§ğŸ˜­ã€‚

## exercise5-1

```c
int getint(int *pn)
{
    int c, sign;
    while (isspace(c = getch())) /* skip white space */
        ;
    if (!isdigit(c) && c != EOF && c != '+' && c != '-')
    {
        ungetch(c); /* it is not a number */
        return 0;
    }
    sign = (c == '-') ? -1 : 1;
    if (c == '+' || c == '-')
        c = getch();
    for (*pn = 0; isdigit(c); c = getch())
        *pn = 10 * *pn + (c - '0');
    *pn *= sign;
    if (c != EOF)
        ungetch(c);
    return c;
}
```

> åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå¦‚æœç¬¦å·+æˆ–-çš„åé¢ç´§è·Ÿçš„ä¸æ˜¯æ•°å­—ï¼Œgetint å‡½æ•°å°†æŠŠç¬¦å·è§†ä¸ºæ•°å­— 0 çš„æœ‰æ•ˆè¡¨è¾¾æ–¹å¼ã€‚ä¿®æ”¹è¯¥å‡½æ•°ï¼Œå°†è¿™ç§å½¢å¼çš„+æˆ–-ç¬¦å·é‡æ–°å†™å›åˆ°è¾“å…¥æµä¸­ã€‚

```c
#include <stdio.h>
#include <ctype.h>

#define SIZE 100
#define BUFSIZE 100

char buf[BUFSIZE]; /* buffer for ungetch */
int bufp = 0;      /* next free position in buf */
int notdigit = 0;  /* flag for not a digit */

/* getint: get next integer from input into *pn */
int getint(int *pn)
{
    notdigit = 0;
    int c, sign, foundSign;
    while (isspace(c = getch())) /* skip white space */
        ;
    if (!isdigit(c) && c != EOF && c != '+' && c != '-')
    {
        notdigit = 1;
        // è‹¥ä¸æ˜¯æ•°å­—ï¼Œå°†å­—ç¬¦æ”¾å›è¾“å…¥æµï¼Œä½†æ˜¯ä¸‹æ¬¡ä¾ç„¶ä¼šè¯»å–åˆ°è¿™ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥éœ€è¦æ³¨é‡Šæ‰ungtch(c)
        // ungetch(c); /* it is not a number */
        return 0;
    }
    sign = (c == '-') ? -1 : 1;
    if (foundSign = (c == '+' || c == '-'))
        c = getch();
    if (c != EOF && !isdigit(c))
    {
        // ungetch(c);
        if (foundSign)
            ungetch((sign = -1) ? '-' : '+');   // å°†ç¬¦å·æ”¾å›
        return 0;
    }
    for (*pn = 0; isdigit(c); c = getch())
        *pn = 10 * *pn + (c - '0');
    *pn *= sign;
    if (c != EOF)
        ungetch(c);
    return c;
}

int main()
{
    int n, array[SIZE], getint(int *);
    for (n = 0; n < SIZE && getint(&array[n]) != EOF; n++)
    {
        if (notdigit)
        {
            printf("Not a number\n");
            continue;
        }
        printf("%d\n", array[n]);
    }
}
```

```shell
-1 2
-1
2
s2
Not a number
2
-s2
0
-2
```

## exercise5-2

> æ¨¡ä»¿å‡½æ•° getint çš„å®ç°æ–¹æ³•ï¼Œç¼–å†™ä¸€ä¸ªè¯»å–æµ®ç‚¹æ•°çš„å‡½æ•° getfloatã€‚getfloat å‡½æ•°çš„è¿”å›å€¼åº”è¯¥æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿ

ä»£ç ï¼š

```c
int getfloat(float *pn)
{
    notdigit = 0;
    int c, sign, foundSign;
    float power;

    while (isspace(c = getch())) /* skip white space */
        ;
    if (!isdigit(c) && c != EOF && c != '+' && c != '-' && c != '.')
    {
        notdigit = 1;
        return 0;
    }
    sign = (c == '-') ? -1 : 1;
    if (foundSign = (c == '+' || c == '-'))
        c = getch();
    if (c != EOF && !isdigit(c) && c != '.')
    {
        if (foundSign)
            ungetch((sign == -1) ? '-' : '+');   // å°†ç¬¦å·æ”¾å›
        return 0;
    }
    for (*pn = 0; isdigit(c); c = getch())
        *pn = 10 * *pn + (c - '0');
    if (c == '.')
        c = getch();
    for (power = 1.0; isdigit(c); c = getch())
    {
        *pn = 10 * *pn + (c - '0');
        power *= 10;
    }
    *pn = sign * (*pn / power);
    if (c != EOF)
        ungetch(c);
    return c;
}
```

è¿è¡Œï¼š

```shell
1.23
1.230000
```

## exercise5-3

> ç”¨æŒ‡é’ˆæ–¹å¼å®ç°ç¬¬ 2 ç« ä¸­çš„å‡½æ•° strcatã€‚å‡½æ•° strcat(s, t)å°† t æŒ‡å‘çš„å­—ç¬¦ä¸²å¤åˆ¶åˆ° s æŒ‡å‘çš„å­—ç¬¦ä¸²çš„å°¾éƒ¨ã€‚

ä»£ç ï¼š

```c
#define MAXLINE 1024

/* strcat: å°† t æŒ‡å‘çš„å­—ç¬¦ä¸²å¤åˆ¶åˆ° s æŒ‡å‘çš„å­—ç¬¦ä¸²çš„å°¾éƒ¨ */
void mstrcat(char *s, const char *t) {
    // æ‰¾åˆ° s çš„æœ«å°¾
    while (*s) {
        s++;
    }
    // å°† t çš„å†…å®¹å¤åˆ¶åˆ° s çš„æœ«å°¾
    while (*t) {
        *s = *t;
        s++;
        t++;
    }
    // æ·»åŠ å­—ç¬¦ä¸²ç»“æŸç¬¦
    *s = '\0';
}

int main() {
    char s[MAXLINE];
    char t[MAXLINE];

    printf("Please input S and T:\n");
    scanf("%s", s);
    scanf("%s", t);
    mstrcat(s, t);

    printf("ans is: %s\n", s);
    
    return 0;
}
```

è¿è¡Œï¼š

```shell
Please input S and T:
abc def
ans is: abcdef
```

## exercise5-4

> ç¼–å†™å‡½æ•° strend(s, t)ã€‚å¦‚æœå­—ç¬¦ä¸² t å‡ºç°åœ¨å­—ç¬¦ä¸² s çš„å°¾éƒ¨ï¼Œè¯¥å‡½æ•°è¿”å› 1ï¼›å¦åˆ™è¿”å› 0ã€‚

```c
int strend(const char *s, const char *t) {
    int i = strlen(s) - 1;
    int j = strlen(t) - 1;

    if (j > i)
        return 0;

    while (j >= 0) 
        if (s[i--] != t[j--])
            return 0;
    
    return 1;
}

int main() {
    char s[MAXLINE];
    char t[MAXLINE];

    printf("Please input S and T:\n");
    scanf("%s", s);
    scanf("%s", t);

    if (strend(s, t)) 
        printf("T appears at the end of S.\n");
    else 
        printf("T does not appear at the end of S.\n");
}
```

è¿è¡Œï¼š

```shell
Please input S and T:
good
o
String T does not appear at the end of string S.
```

## exercise5-5

> å®ç°åº“å‡½æ•° strncpyã€strncat å’Œ strncmpï¼Œå®ƒä»¬æœ€å¤šå¯¹å‚æ•°å­—ç¬¦ä¸²ä¸­çš„å‰ n ä¸ªå­—ç¬¦è¿›è¡Œæ“ä½œã€‚ä¾‹å¦‚ï¼Œå‡½æ•° strncpy(s, t, n)å°† t ä¸­æœ€å¤šå‰ n ä¸ªå­—ç¬¦å¤åˆ¶åˆ° sä¸­ã€‚

```c
/* mstrncpy: å°† t ä¸­æœ€å¤šå‰ n ä¸ªå­—ç¬¦å¤åˆ¶åˆ° s ä¸­ */
char *mstrncpy(char *s, const char *t, int n)
{
    char *ans = s;
    while (n-- && (*s++ = *t++))
        ;
    while ((n--) > 0)
        *s++ = '\0';
    return ans;
}

/* mstrncat: å°† t ä¸­æœ€å¤šå‰ n ä¸ªå­—ç¬¦è¿æ¥åˆ° s çš„æœ«å°¾ */
char *mstrncat(char *s, const char *t, int n)
{
    char *ans = s;
    s += strlen(s);
    while (n-- && (*s++ = *t++))
        ;
    *s = '\0';
    return ans;
}

/* mstrncmp: æ¯”è¾ƒ s å’Œ t ä¸­æœ€å¤šå‰ n ä¸ªå­—ç¬¦ */
int mstrncmp(const char *s, const char *t, int n)
{
    while (n-- && *s && (*s++ == *t++))
        ;
    return n == -1 ? 0 : (*s - *t) != 0;
}

int main()
{
    char s1[MAXLINE] = "gooooood";
    char s2[MAXLINE] = "idea";
    char s3[MAXLINE] = "good";

    int n1 = 4;
    int result = mstrncmp(s1, s3, n1);
    printf("mstrncmp(%s, %s, %d):\n %d\n", s1, s3, n1, result);

    int n2 = 5;
    mstrncpy(s1, s3, 5);
    printf("mstrncpy(%s, %s, %d):\n %s\n", s1, s3, n2, s1);

    int n3 = 3;
    mstrncat(s2, s3, 3);
    printf("mstrncat(%s, %s, %d):\n %s\n", s2, s3, n3, s2);

    return 0;
}
```

è¿è¡Œï¼š

```shell
mstrncmp(gooooood, good, 4):
 1
mstrncpy(good, good, 5):
 good
mstrncat(ideagoo, good, 3):
 ideagoo
```

## exercise5-7

> é‡å†™å‡½æ•° readlinesï¼Œå°†è¾“å…¥çš„æ–‡æœ¬è¡Œå­˜å‚¨åˆ°ç”± main å‡½æ•°æä¾›çš„ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œè€Œä¸æ˜¯å­˜å‚¨åˆ°è°ƒç”¨ alloc åˆ†é…çš„å­˜å‚¨ç©ºé—´ä¸­ã€‚è¯¥å‡½æ•°çš„è¿è¡Œé€Ÿåº¦æ¯”æ”¹å†™å‰å¿«å¤šå°‘ï¼Ÿ

```c
#include <stdio.h>
#include <string.h>
#include <malloc.h>

#define MAXLINES 5000 /* max #lines to be sorted */
#define MAXLEN 1000   /* max length of any input line */

char *lineptr[MAXLINES]; /* pointers to text lines */

int Getline(char line[])
{
    int c, i;
    for (i = 0; i < MAXLEN - 1 && (c = getchar()) != EOF && c != '\n'; i++)
        line[i] = c;
    if (c == '\n')
    {
        line[i] = c;
        i++;
    }
    line[i] = '\0';
    return i;
}

/* swap: interchange v[i] and v[j] */
void swap(char *v[], int i, int j)
{
    char *temp;
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}

/* qsort: sort v[left]...v[right] into increasing order */
void qsort(char *v[], int left, int right)
{
    int i, last;
    void swap(char *v[], int i, int j);
    if (left >= right) /* do nothing if array contains */
        return;        /* fewer than two elements */
    swap(v, left, (left + right) / 2);
    last = left;
    for (i = left + 1; i <= right; i++)
        if (strcmp(v[i], v[left]) < 0)
            swap(v, ++last, i);
    swap(v, left, last);
    qsort(v, left, last - 1);
    qsort(v, last + 1, right);
}

/* readlines: read input lines */
int readlines(char *lineptr[], int maxlines)
{
    int len, nlines;
    char *p, line[MAXLEN];
    nlines = 0;
    while ((len = Getline(line)) > 0)
        if (nlines >= maxlines || (p = malloc(len)) == NULL)
            return -1;
        else
        {
            line[len - 1] = '\0'; /* delete newline */
            strcpy(p, line);
            lineptr[nlines++] = p;
        }
    return nlines;
}

/* writelines: write output lines */
void writelines(char *lineptr[], int nlines)
{
    int i;
    for (i = 0; i < nlines; i++)
        printf("%s\n", lineptr[i]);
}

/* sort input lines */
int main()
{
    int nlines; /* number of input lines read */
    printf("Please input lines:\n");
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0)
    {
        qsort(lineptr, 0, nlines - 1);
        printf("Sorted lines(sorted by first word):\n");
        writelines(lineptr, nlines);
        return 0;
    }
    else
    {
        printf("error: input too big to sort\n");
        return 1;
    }
}

```

å¢åŠ å‡½æ•°ï¼š

```c
int readlines2(char linesarray[][MAXLEN], int maxlines)
{
    int len, nlines;
    nlines = 0;
    while ((len = Getline(linesarray[nlines])) > 0)
        if (nlines >= maxlines)
            return -1;
        else
            linesarray[nlines++][len - 1] = '\0';
    return nlines;
}

int main(int argc, char *argv[])
{
    printf("Please input lines:");
    if (argc > 1 && *argv[1] == '2')
    {
        printf("(by readlines2):\n");
        int nlines = readlines2(linesarray, MAXLINES);
    }
    else
    {
        printf("(by readlines):\n");
        int nlines = readlines(lineptr, MAXLINES);
    }
    return 0;
}
```

## exercise5-8

> å‡½æ•° day_of_year å’Œ month_day ä¸­æ²¡æœ‰è¿›è¡Œé”™è¯¯æ£€æŸ¥ï¼Œè¯·è§£å†³è¯¥é—®é¢˜ã€‚

å¯¹è¾“å…¥çš„æœˆä»½ã€å¤©æ•°è¿›è¡Œæ£€æŸ¥

```c
#include <stdio.h>
static char daytab[2][13] = {
    {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
    {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
};
/* day_of_year: set day of year from month & day */
int day_of_year(int year, int month, int day)
{
    int i, leap;
    if (month < 1 || month > 12 || day < 1)
        return -1;
    leap = year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    if (day > daytab[leap][month])
        return -1;
    for (i = 1; i < month; i++)
        day += daytab[leap][i];
    return day;
}
/* month_day: set month, day from day of year */
int month_day(int year, int yearday, int *pmonth, int *pday)
{
    int i, leap;
    if (yearday < 1)
        return -1;
    leap = year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    if ((leap && yearday > 366) || (!leap && yearday > 365))
        return -1;
    for (i = 1; yearday > daytab[leap][i]; i++)
        yearday -= daytab[leap][i];
    *pmonth = i;
    *pday = yearday;
    return 0;
}

int main(void)
{
    int year, month, day, yearday;
    printf("Test day_of_year()\nPlease input year, month and day: ");
    scanf("%d %d %d", &year, &month, &day);
    yearday = day_of_year(year, month, day);
    if (yearday == -1)
        printf("Wrong date!\n");
    else 
        printf("%d-%d-%d: the %d day in %d\n", year, month, day, yearday, year);
    
    printf("\nTest month_day()\nPlease input year and yearday: ");
    scanf("%d %d", &year, &yearday);
    int ans = month_day(year, yearday, &month, &day);
    if (ans == -1)
        printf("Wrong date!\n");
    else 
        printf("the %d day in %d: %d-%d-%d\n", yearday, year, year, month, day);
    return 0;
}
```

è¿è¡Œï¼š

```shell
Test day_of_year()
Please input year, month and day: 2002 10 14
2002-10-14: the 287 day in 2002

Test month_day()
Please input year and yearday: 2002 287
the 287 day in 2002: 2002-10-14
```

## exercise5-9

> ç”¨æŒ‡é’ˆæ–¹å¼ä»£æ›¿æ•°ç»„ä¸‹æ ‡æ–¹å¼æ”¹å†™å‡½æ•° day_of_year å’Œ month_dayã€‚

```c
int day_of_year_ptr(int year, int month, int day)
{
    int i, leap;
    if (month < 1 || month > 12 || day < 1)
        return -1;
    leap = year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    char *p = &daytab[leap][1];
    if (day > *(p + month - 1))
        return -1;
    for (i = 1; i < month; i++)
    {
        day += *p;
        ++p;
    }
    return day;
}
/* month_day: set month, day from day of year */
int month_day_ptr(int year, int yearday, int *pmonth, int *pday)
{
    int i, leap;
    if (yearday < 1)
        return -1;
    leap = year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    if ((leap && yearday > 366) || (!leap && yearday > 365))
        return -1;
    char *p = &daytab[leap][1];
    for (i = 1; yearday > *p; i++)
    {
        yearday -= *p;
        ++p;
    }
    *pmonth = i;
    *pday = yearday;
    return 0;
}
```

è¿è¡Œï¼š

```shell
Test day_of_year_ptr()
Please input year, month and day: 2002 10 14
2002-10-14: the 287 day in 2002

Test month_day_ptr()
Please input year and yearday: 2002 287
the 287 day in 2002: 2002-10-14
```

## exercise5-10

> ç¼–å†™ç¨‹åº exprï¼Œä»¥è®¡ç®—ä»å‘½ä»¤è¡Œè¾“å…¥çš„é€†æ³¢å…°è¡¨è¾¾å¼çš„å€¼ï¼Œå…¶ä¸­æ¯ä¸ªè¿ç®—ç¬¦æˆ–æ“ä½œæ•°ç”¨ä¸€ä¸ªå•ç‹¬çš„å‚æ•°è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼Œå‘½ä»¤
expr 2 3 4 + *
å°†è®¡ç®—è¡¨è¾¾å¼ 2 Ã— (3 + 4)çš„å€¼ã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#define NUMBER '0'
#define MAXVAL 100  /* maximum depth of val stack */
int sp = 0;         /* next free stack position */
double val[MAXVAL]; /* value stack */

int isnumber(char *s)
{
    if (strlen(s) == 1 && (s[0] == '/' || s[0] == '*' || s[0] == '+' || s[0] == '-'))
        return s[0];

    int i = 0;
    if (s[i] == '-' || s[i] == '+')
        i++;
    for (; isdigit(s[i]); i++)
        ;
    if (s[i] == '.')
        i++;
    for (; isdigit(s[i]); i++)
        ;
    return s[i] == '\0' ? NUMBER : -1;
}

/* push: push f onto value stack */
void push(double f)
{
    if (sp < MAXVAL)
        val[sp++] = f;
    else
        printf("error: stack full, can't push %g\n", f);
}

/* pop: pop and return top value from stack */
double pop(void)
{
    if (sp > 0)
        return val[--sp];
    else
    {
        printf("error: stack empty\n");
        return 0.0;
    }
}

int main(int argc, char **argv)
{
    int i;
    double value;
    for (i = 1; i < argc; ++i)
    {
        switch (isnumber(argv[i]))
        {
        case NUMBER:
            push(atof(argv[i]));
            break;
        case '+':
            push(pop() + pop());
            break;
        case '-':
            value = pop();
            push(pop() - value);
            break;
        case '*':
            push(pop() * pop());
            break;
        case '/':
            value = pop();
            push(pop() / value);
            break;
        default:
            printf("wrong argument: %s\n", argv[i]);
            break;
        }
    }
    printf("%g\n", pop());
    return 0;
}
```

è¿è¡Œï¼ˆå‘½ä»¤è¡Œä¸­ï¼Œ'*'éœ€è¦åæ–œæ æ¥è½¬ä¹‰ï¼‰ï¼š

```shell
âœ  ch05 git:(main) âœ— ./Exercise5-10 2 3 4 + \*
14
```

## exercise5-13

> ç¼–å†™ç¨‹åº tailï¼Œå°†å…¶è¾“å…¥ä¸­çš„æœ€å n è¡Œæ‰“å°å‡ºæ¥ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œn çš„å€¼ä¸º10ï¼Œä½†å¯é€šè¿‡ä¸€ä¸ªå¯é€‰å‚æ•°æ”¹å˜ n çš„å€¼ï¼Œå› æ­¤ï¼Œå‘½ä»¤`tail -n`å°†æ‰“å°å…¶è¾“å…¥çš„æœ€å n è¡Œã€‚æ— è®ºè¾“å…¥æˆ– n çš„å€¼æ˜¯å¦åˆç†ï¼Œè¯¥ç¨‹åºéƒ½åº”è¯¥èƒ½æ­£å¸¸è¿è¡Œã€‚ç¼–å†™çš„ç¨‹åºè¦å……åˆ†åœ°åˆ©ç”¨å­˜å‚¨ç©ºé—´ï¼›è¾“å…¥è¡Œçš„å­˜å‚¨æ–¹å¼åº”è¯¥åŒ 5.6 èŠ‚ä¸­æ’åºç¨‹åºçš„å­˜å‚¨æ–¹å¼ä¸€æ ·ï¼Œè€Œä¸é‡‡ç”¨å›ºå®šé•¿åº¦çš„äºŒç»´æ•°ç»„ã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#define MAXLINES 5000 /* max #lines to be sorted */
#define MAXLEN 1000   /* max length of any input line */

char *lineptr[MAXLINES];           /* pointers to text lines */
char linesarray[MAXLINES][MAXLEN]; /*array that store lines*/

int Getline(char line[])
{
    int c, i;
    for (i = 0; i < MAXLEN - 1 && (c = getchar()) != EOF && c != '\n'; i++)
        line[i] = c;
    if (c == '\n')
    {
        line[i] = c;
        i++;
    }
    line[i] = '\0';
    return i;
}

/* readlines: read input lines */
int readlines(char *lineptr[], int maxlines)
{
    int len, nlines;
    char *p, line[MAXLEN];
    nlines = 0;
    while ((len = Getline(line)) > 0)
        if (nlines >= maxlines || (p = malloc(len)) == NULL)
            return -1;
        else
        {
            line[len - 1] = '\0'; /* delete newline */
            strcpy(p, line);
            lineptr[nlines++] = p;
        }
    return nlines;
}

/* writelines: write output lines */
void writelines(char *lineptr[], int nlines, int n)
{
    int i;
    for (i = nlines - n > 0 ? nlines - n : 0; i < nlines; i++)
        printf("%s\n", lineptr[i]);
}

int main(int argc, char *argv[])
{
    printf("Please input lines:\n");
    int nlines = readlines(lineptr, MAXLINES);
    if (argc > 1 && argv[1][0] == '-')
    {
        int n = atoi(argv[1] + 1);
        printf("The last %d lines are:\n", n);
        writelines(lineptr, nlines, n);
    }
    else {
        printf("The last 10 lines are:\n");
        writelines(lineptr, nlines, 10);
    }
    
    return 0;
}

```

è¿è¡Œï¼š

```shell
âœ  ch05 git:(main) âœ— ./Exercise5-13 -2
Please input lines:
sdui
qi
a
The last 2 lines are:
qi
a
```

## exercise5-14

> ä¿®æ”¹æ’åºç¨‹åºï¼Œä½¿å®ƒèƒ½å¤„ç†-r æ ‡è®°ã€‚è¯¥æ ‡è®°è¡¨æ˜ï¼Œä»¥é€†åºï¼ˆé€’å‡ï¼‰æ–¹å¼æ’åºã€‚è¦ä¿è¯-r å’Œ-n èƒ½å¤Ÿç»„åˆåœ¨ä¸€èµ·ä½¿ç”¨ã€‚

```c
int reverse;

int mstrcmp(char *s1, char *s2)
{
    char *news1 = reverse ? s2 : s1;
    char *news2 = reverse ? s1 : s2;
    return strcmp(news1, news2);
}

/* numcmp: compare s1 and s2 numerically */
int mnumcmp(char *s1, char *s2)
{
    char *news1 = reverse ? s2 : s1;
    char *news2 = reverse ? s1 : s2;

    double v1, v2;
    v1 = atof(news1);
    v2 = atof(news2);
    if (v1 < v2)
        return -1;
    else if (v1 > v2)
        return 1;
    else
        return 0;
}

/* qsort: sort v[left]...v[right] into increasing order */
void mqsort(void *v[], int left, int right, int (*comp)(void *, void *))
{
    int i, last;
    if (left >= right) /* do nothing if array contains */
        return;        /* fewer than two elements */
    swap(v, left, (left + right) / 2);
    last = left;
    for (i = left + 1; i <= right; i++)
        if ((*comp)(v[i], v[left]) < 0)
            swap(v, ++last, i);
    swap(v, left, last);
    mqsort(v, left, last - 1, comp);
    mqsort(v, last + 1, right, comp);
}

int main(int argc, char *argv[])
{
    int nlines;      /* number of input lines read */
    int numeric = 0; /* 1 if numeric sort */
    reverse = 0;     /* 1 if reverse sort */
    if (argc > 1 && strcmp(argv[1], "-n") == 0)
        numeric = 1;
    if (argc > 2 && strcmp(argv[2], "-r") == 0)
        reverse = 1;
    printf("Please input data:\n");
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0)
    {
        mqsort((void **)lineptr, 0, nlines - 1,
              (int (*)(void *, void *))(numeric ? mnumcmp : mstrcmp));
        printf("After sorted:\n");
        writelines(lineptr, nlines);
        return 0;
    }
    else
    {
        printf("input too big to sort\n");
        return 1;
    }
}
```

è¿è¡Œï¼š

```shell
âœ  ch05 git:(main) âœ— ./Exercise5-14 -n -r
Please input data:
76 
44   
98
After sorted:
98
76
44
```

## exercise5-15

> å¢åŠ é€‰é¡¹-fï¼Œä½¿å¾—æ’åºè¿‡ç¨‹ä¸è€ƒè™‘å­—æ¯å¤§å°å†™ä¹‹é—´çš„åŒºåˆ«ã€‚ä¾‹å¦‚ï¼Œæ¯”è¾ƒ a å’Œ A æ—¶è®¤ä¸ºå®ƒä»¬ç›¸ç­‰ã€‚

```c
int mstrcmp(char *s1, char *s2)
{
    char *news1 = reverse ? s2 : s1;
    char *news2 = reverse ? s1 : s2;
    return fold == 1 ? strcasecmp(news1, news2) : strcmp(news1, news2);
}

int main(int argc, char *argv[])
{
    int nlines;      /* number of input lines read */
    int numeric = 0; /* 1 if numeric sort */
    reverse = 0;     /* 1 if reverse sort */
    for (int i = 1; i < argc; i++)
        switch (argv[i][1])
        {
        case 'n':
            numeric = 1;
            break;
        case 'r':
            reverse = 1;
            break;
        case 'f':
            fold = 1;
            break;
        }
    printf("Please input data:\n");
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0)
    {
        mqsort((void **)lineptr, 0, nlines - 1,
               (int (*)(void *, void *))(numeric ? mnumcmp : mstrcmp));
        printf("After sorted:\n");
        writelines(lineptr, nlines);
        return 0;
    }
    else
    {
        printf("input too big to sort\n");
        return 1;
    }
}
```

```shell
âœ  ch05 git:(main) âœ— ./Exercise5-14 -f
Please input data:
aB
Ab
After sorted:
aB
Ab
```

## exercise5-16

> å¢åŠ é€‰é¡¹-dï¼ˆä»£è¡¨ç›®å½•é¡ºåºï¼‰ã€‚è¯¥é€‰é¡¹è¡¨æ˜ï¼Œåªå¯¹å­—æ¯ã€æ•°å­—å’Œç©ºæ ¼è¿›è¡Œæ¯”è¾ƒã€‚è¦ä¿è¯è¯¥é€‰é¡¹å¯ä»¥å’Œ-f ç»„åˆåœ¨ä¸€èµ·ä½¿ç”¨ã€‚

```c
int charcmp(char c1, char c2)
{
    if (dir)
    {
        if (!isalnum(c1) && c1 != ' ')
            return 0;
        if (!isalnum(c2) && c2 != ' ')
            return 0;
    }
    if (fold)
    {
        c1 = tolower(c1);
        c2 = tolower(c2);
    }
    return c1 - c2;
}

int mstrcmp(char *s1, char *s2)
{
    char *news1 = reverse ? s2 : s1;
    char *news2 = reverse ? s1 : s2;

    while (*news1 && *news2)
    {
        int cmp = charcmp(*news1, *news2);
        if (cmp != 0)
            return cmp;
        news1++;
        news2++;
    }
    return *news1 ? 1 : (*news2 ? -1 : 0);
}

/* numcmp: compare s1 and s2 numerically */
int mnumcmp(char *s1, char *s2)
{
    char *news1 = reverse ? s2 : s1;
    char *news2 = reverse ? s1 : s2;

    double v1, v2;
    v1 = atof(news1);
    v2 = atof(news2);
    if (v1 < v2)
        return -1;
    else if (v1 > v2)
        return 1;
    else
        return 0;
}

/* qsort: sort v[left]...v[right] into increasing order */
void mqsort(void *v[], int left, int right, int (*comp)(void *, void *))
{
    int i, last;
    if (left >= right) /* do nothing if array contains */
        return;        /* fewer than two elements */
    swap(v, left, (left + right) / 2);
    last = left;
    for (i = left + 1; i <= right; i++)
        if ((*comp)(v[i], v[left]) < 0)
            swap(v, ++last, i);
    swap(v, left, last);
    mqsort(v, left, last - 1, comp);
    mqsort(v, last + 1, right, comp);
}

int main(int argc, char *argv[])
{
    int nlines;      /* number of input lines read */
    int numeric = 0; /* 1 if numeric sort */
    reverse = 0;     /* 1 if reverse sort */
    for (int i = 1; i < argc; i++)
        switch (argv[i][1])
        {
        case 'n':
            numeric = 1;
            break;
        case 'r':
            reverse = 1;
            break;
        case 'f':
            fold = 1;
            break;
        case 'd':
            dir = 1;
            break;
        }
    printf("Please input data:\n");
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0)
    {
        mqsort((void **)lineptr, 0, nlines - 1,
               (int (*)(void *, void *))(numeric ? mnumcmp : mstrcmp));
        printf("After sorted:\n");
        writelines(lineptr, nlines);
        return 0;
    }
    else
    {
        printf("input too big to sort\n");
        return 1;
    }
}
```

è¿è¡Œï¼š

```shell
âœ  ch05 git:(main) âœ— ./Exercise5-16 -d -f
Please input data:
A+b
a-B
After sorted:
A+b
a-B
Please input data:
a-B
A+b
After sorted:
a-B
A+b
```

...æœªå®Œå¾…ç»­
